---
title: 'Leetcode84 柱状图中最大的矩形'
date: 2020-03-01
mathjax: true
categories:
- Computer Science
- OJ
- leetcode
tags:
- C/C++
---

## [题目描述](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

> 题目图片会403。。

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

示例:

```
输入: [2,1,5,6,2,3]
输出: 10
```

<!-- more -->

## 解决方案

官方已经给出很多中方法了：[leetcode官方解答](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode/)

但是有些感觉没说清楚的地方，主要是两种思路，**分治法**和**栈**

### 分治法

对一个区间我们可以认为最大矩形只有三种情况，假设最短下标为*i*

- 下标*i*为最大矩形的高，此时宽就是整个区间
- 最大矩形出现在下标*i*的左边
- 最大矩形出现在下标*i*的右边

这样子就可以将大问题分而治之，代码如下：

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        return divide(heights, 0, heights.size() - 1);
    }

    int divide(vector<int>& heights, int l, int r) {
        if(l > r) {
            return 0;
        }
        int min_index = l;
        for(int i = l;i <= r;i++) {
            if(heights[i] < heights[min_index]) {
                min_index = i;
            }
        }
        int area = heights[min_index]*(r-l+1);
        area = max(area, divide(heights, l, min_index-1));
        area = max(area, divide(heights, min_index+1, r));
        return area;
    }
};
```

其中的复杂度是$n\log n$，但是在有序数列的情况下，会达到 $n^2$，有时候leetcode会超时（多提交几次没准就过哈哈）

### 栈

这个方法就十分巧妙了，看了好久的官方代码才明白

其中的主要思想是：**如何求一根高为*h*的柱子的最大矩形**。这个思路就很清楚了，分别从此柱子下标开始向两边寻找第一个高度小于它的（在往两边拓展则会高度变小），就可以了

这个栈的思路也是如此：**维护一个非递减栈**，通过一遍遍历，即可完成所有以此柱子为高的最大矩形面积的确定

当我们从左往右将柱子**下标**加入栈，直到遇到一个**破坏非递减关系**的柱子（即$heights[i]<heights[i-1]$），记此时的下标为*i*。我们假设此时栈中满足高度**小于**[^1] *i*柱子的最大下标为*j*，那么在区间 $(i,j)$之间的柱子的最大面积都可以确定

令$z \in (i,j)$，下标为*z*的柱子它们的右边界就是*i*，它们的左边界就是在栈中位于它们之下的那个下标，假设为*k*，有了这些*z*的最大面积也可以得出来了 

利用栈的后进先出特性，此时我们可以一个个的从栈中弹出下标，直到遇到上面的“*j*”，可以得出计算面积的表达式：
$$
(i-stack[top-1]\times heights[stack[top]])
$$
在多次入栈出栈后，栈内的坐标会变得的不再连续，而且上面的规则隐藏了一些深的特性

假设 *stack[top-1]* 的值为 *k*，每个区间的特别意义如下：

- 从左到右排列：$j,k,z,i$ 注意此时*i*并未入栈
- $(j,k)$：此区间的高度均大于或等于[^2]$heights[i]$
- $(k,z)$：此区间高度均大于或等于 $heights[z]$（当*k,z*不连续时，此时比*z*小的都在之前被弹出了栈）
- $(z,i)$：此区间最大矩形均已确定，按以上表达式

在最后如果栈不为空，则说明栈内的下标对应高度**呈非递减趋势**。此时依次出栈计算面积，计算表达式为：
$$
heights[stack[top]]*(heights.size - stack[top-1] - 1) \\
因为stack[top-1]之后高度均大于等于stack[top]
$$

### 代码如下

```c++
// 栈
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int res = 0;
        stack<int> st; st.push(-1); // 方便处理栈底的处理
        for(int i = 0;i < heights.size();i++) {
            // 此时找到了一个非递增的
            // 注意大于等于都可以
            while(st.top() != -1 && heights[st.top()] >= heights[i]) {
                int height_index = st.top(); st.pop();
                res = max(res, heights[height_index]*(i - 1 - st.top()));
            }
            st.push(i);
        }
        while(st.top() != -1) {
            int height_index = st.top(); st.pop();
            res = max(res, (int)(heights[height_index]*(heights.size() - st.top() - 1)));
        }
        return res;
    }
};
```
[社区题解](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhao-liang-bian-di-yi-ge-xiao-yu-ta-de-zhi-by-powc/)有个更巧妙的，在heights数组前和后加入高度0，可以避免最后以此的清空栈操作和对栈底弹出时的特别处理（此处使用加入-1作为特别处理）

代码如下：

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        res = 0
        n = len(heights)
        for i in range(n):
            left_i = i
            right_i = i
            while left_i >= 0 and heights[left_i] >= heights[i]:
                left_i -= 1
            while right_i < n and heights[right_i] >= heights[i]:
                right_i += 1
            res = max(res, (right_i - left_i - 1) * heights[i])
        return res
```





---

[^1]: 其实在此处小于等于也是可以的
[^2]: 根据注解1处的不同而不同（1处若为小于等于，此处则仅大于）