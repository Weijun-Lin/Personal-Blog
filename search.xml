<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Retro Snake Easyx版本</title>
    <url>/2018/09/15/2018-09-15-Retro-Snake/</url>
    <content><![CDATA[<h2 id="部分文件说明">部分文件说明</h2>
<h3 id="snakeprev.h"><strong>Snakeprev.h</strong></h3>
<ol type="1">
<li>蛇节点声明 <code>struct snake;</code></li>
<li>蛇存储结构链表 <code>snake * snakelist(int,int*);</code></li>
<li>增加节点方法 <code>void addsnake(snake *);</code></li>
<li>绘画蛇身 <code>void drawsnake(snake *,char);</code></li>
<li>清空蛇 <code>void clearsnake(snake *);</code></li>
</ol>
<span id="more"></span>
<h3 id="mapgraph.h"><strong>mapgraph.h</strong></h3>
<p>主要是页面布局 背景（box map)的制作 布局</p>
<h3 id="main.cpp"><strong>main.cpp</strong></h3>
<p>主要方法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">welcomegraph</span><span class="params">()</span></span>;<span class="comment">//欢迎界面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">()</span></span>;<span class="comment">//结束界面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clickcontrol</span><span class="params">()</span></span>;<span class="comment">//鼠标控制</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Movingsnake</span><span class="params">(<span class="type">char</span>)</span></span>;<span class="comment">//蛇身移动控制</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Changesnakebody</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span> )</span></span>;<span class="comment">//蛇身改变控制</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Eating</span><span class="params">()</span></span>;<span class="comment">//吃到食物的操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Deadjudge</span><span class="params">()</span></span>;<span class="comment">//死亡判断</span></span><br></pre></td></tr></table></figure>
<h3 id="运行截图">运行截图</h3>
<ul>
<li><strong>Start</strong></li>
</ul>
<figure>
<img
src="https://github.com/LWJ9527/Retro-Snake/blob/master/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/start.png?raw=true"
alt="Start" />
<figcaption aria-hidden="true">Start</figcaption>
</figure>
<ul>
<li><strong>Run</strong></li>
</ul>
<figure>
<img
src="https://github.com/LWJ9527/Retro-Snake/blob/master/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/run.png?raw=true"
alt="Run" />
<figcaption aria-hidden="true">Run</figcaption>
</figure>
<ul>
<li><strong>Over</strong></li>
</ul>
<figure>
<img
src="https://github.com/LWJ9527/Retro-Snake/blob/master/%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA/over.png?raw=true"
alt="Over" />
<figcaption aria-hidden="true">Over</figcaption>
</figure>
<h3 id="注意事项及运行说明">注意事项及运行说明</h3>
<p><strong>WASD：</strong>　来操控蛇的上下左右移动
注意打开英文输入<br />
<strong>初始界面：</strong> 用户名及密码只是模拟 回车键确定输入<br />
<strong>EXE目录：</strong> exe文件在debug目录下
release发布因为其优化运行出错<br />
<strong>源代码下载：</strong>
<code>https://github.com/LWJ9527/Retro-Snake.git</code><br />
<strong>C控制台源代码：</strong>
<code>https://blog.csdn.net/qq_40953281/article/details/79315254</code><br />
<strong>To Be Continue...</strong> &gt; Easyx 下载地址
<code>https://www.easyx.cn/downloads/</code><br />
&gt; 更新 2018-9-10</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Game</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 爬取有道翻译</title>
    <url>/2018/09/18/2018-09-18-youdao/</url>
    <content><![CDATA[<p><a
href="https://www.cnblogs.com/sss4/p/7809821.html"><strong>爬虫原理</strong></a></p>
<blockquote>
<p>Attention: Python3 将urlib2 urlib3 结合为urlib</p>
</blockquote>
<ul>
<li><strong>Urlib</strong>:<a
href="https://www.cnblogs.com/xiao-apple36/p/8433400.html">Python3中urllib详细使用方法(header,代理,超时,认证,异常处理)</a></li>
<li><strong>urlib2</strong> :<a
href="https://blog.csdn.net/u010409445/article/details/73438816">python
urllib2详解及实例(从底层说起)</a></li>
</ul>
<h2 id="基本原理">基本原理</h2>
<ul>
<li><p>通过给网页提供一个数据，然后获取其反馈</p></li>
<li><p>使用到的模块</p>
<ul>
<li><strong>urllib.request:</strong> 访问网站，提出请求，获取反馈</li>
<li><strong>urllib.parse:</strong> 格式化请求数据</li>
<li><strong>json:</strong> 格式化反馈信息，使其格式化为字典</li>
</ul></li>
<li><p>新版有道翻译爬取实现比较复杂 这里是对老的版本的爬取</p></li>
</ul>
<span id="more"></span>
<h2 id="实现过程及代码">实现过程及代码</h2>
<h3 id="分步解释">分步解释</h3>
<p><strong>1.</strong>
获取处理翻译信息的网页（这里采用的是谷歌浏览器）<br />
打开有道翻译网页 进入开发者模式<br />
选择Network <img src="/assets/ArticleImg/2018/Youdao1.png"
alt="Youdao1" /><br />
然后在左边的输入框随便输入一个单词 会发现多了很多文件 <img
src="/assets/ArticleImg/2018/Youdao2.png" alt="Youdao2" />
<strong>Headers</strong> 里面就是我们需要发送给他的信息<br />
其中 <strong>Request Url</strong> 就是真正处理翻译的网页<br />
由于我们采用旧版所以将url里的 <strong>"translate_o"</strong> 改为
<strong>"translate"</strong></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 真正翻译的网址 Request Url</span></span><br><span class="line">url = <span class="string">&#x27;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.</strong> 发送信息包 如下 <img
src="/assets/ArticleImg/2018/Youdao3.png" alt="Youdao3" />
将其包装成字典 并且格式化为网页可以识别的格式</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建列表 模拟传入数据</span></span><br><span class="line">data = &#123;&#125;</span><br><span class="line">data[<span class="string">&#x27;i&#x27;</span>] = String</span><br><span class="line">data[<span class="string">&#x27;from&#x27;</span>] = <span class="string">&#x27;AUTO&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;AUTO&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;smartresult&#x27;</span>] = <span class="string">&#x27;dict&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;client&#x27;</span>] = <span class="string">&#x27;fanyideskweb&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;doctype&#x27;</span>] = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;version&#x27;</span>] = <span class="string">&#x27;2.1&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;keyfrom&#x27;</span>] = <span class="string">&#x27;fanyi.web&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;action&#x27;</span>] = <span class="string">&#x27;FY_BY_REALTIME&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;typoResult&#x27;</span>] = <span class="string">&#x27;false&#x27;</span></span><br><span class="line"><span class="comment">#该变格式</span></span><br><span class="line">data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>3.</strong> 获取反馈并处理<br />
<img src="/assets/ArticleImg/2018/Youdao4.png" alt="Youdao4" /></p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = urllib.request.urlopen(url, data)  <span class="comment"># 得到回复</span></span><br><span class="line">html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 重新编码</span></span><br><span class="line">result = json.loads(html)  <span class="comment"># json 字典化</span></span><br><span class="line"><span class="comment"># return result[&quot;translateResult&quot;][0][0][&quot;tgt&quot;] 返回结果</span></span><br></pre></td></tr></table></figure></p>
<h3 id="全部代码如下">全部代码如下</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Author: Joke-R</span></span><br><span class="line"><span class="string">    IDE: python3.6</span></span><br><span class="line"><span class="string">    Purpose: translate words by youdao</span></span><br><span class="line"><span class="string">    Time: 2018-09-18</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Translate</span>(<span class="params">String</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        String: str</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 真正翻译的网址 Request Url</span></span><br><span class="line">    url = <span class="string">&#x27;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&#x27;</span></span><br><span class="line">    <span class="comment"># 新建列表 模拟传入数据</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    data[<span class="string">&#x27;i&#x27;</span>] = String</span><br><span class="line">    data[<span class="string">&#x27;from&#x27;</span>] = <span class="string">&#x27;AUTO&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;AUTO&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;smartresult&#x27;</span>] = <span class="string">&#x27;dict&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;client&#x27;</span>] = <span class="string">&#x27;fanyideskweb&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;doctype&#x27;</span>] = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;version&#x27;</span>] = <span class="string">&#x27;2.1&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;keyfrom&#x27;</span>] = <span class="string">&#x27;fanyi.web&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;action&#x27;</span>] = <span class="string">&#x27;FY_BY_REALTIME&#x27;</span></span><br><span class="line">    data[<span class="string">&#x27;typoResult&#x27;</span>] = <span class="string">&#x27;false&#x27;</span></span><br><span class="line"></span><br><span class="line">    data = urllib.parse.urlencode(data).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    response = urllib.request.urlopen(url, data)  <span class="comment"># 得到回复</span></span><br><span class="line">    html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 重新编码</span></span><br><span class="line">    result = json.loads(html)  <span class="comment"># json 字典化</span></span><br><span class="line">    <span class="keyword">return</span> result[<span class="string">&quot;translateResult&quot;</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="string">&quot;tgt&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(__doc__)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            String = <span class="built_in">input</span>(<span class="string">&quot;please input a string:\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;result:&quot;</span>, Translate(String))</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> reason:</span><br><span class="line">            <span class="built_in">print</span>(reason + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串算法</title>
    <url>/2018/10/01/2018-10-01-manacher/</url>
    <content><![CDATA[<blockquote>
<p>leetcode5:<code>https://leetcode-cn.com/problems/longest-palindromic-substring/description/</code><br />
可以自己提交看看对不对</p>
</blockquote>
<h2 id="暴力搜索">暴力搜索</h2>
<p>这个应该是最容易的方法了，但是一看复杂度O(n<sup>3</sup>)，还是放弃好了。</p>
<p>但是这个方法也是遍历所有字符串字串的一种方法。下面是暴力搜索的代码：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">maxPalindromeStringForce</span><span class="params">(<span class="keyword">final</span> String target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">BeginIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; target.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindromeString(target.substring(i, j + <span class="number">1</span>)) &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                BeginIndex = i;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring(BeginIndex, BeginIndex + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindromeString</span><span class="params">(<span class="keyword">final</span> String target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> target.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.charAt(l) != target.charAt(r)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中心拓展法">中心拓展法</h2>
<p>这个比暴力搜索复杂度要少一个数量级<br />
为什么呢？它用到了回文串的一个特性左右对称<br />
其实在暴力搜索的判断是否为回文串的时候我们已经用了这个特性了<br />
但是我们是对每一段字串用这个特性<u><strong>即用它去判断而不是去获取</strong></u><br />
所以我们对每一个字符从中间向外展开以获取以此字符为中心的最长回文字串<br />
这样外循环为字符串遍历 内循环为获得回文子串
复杂度最差意思就是O(n<sup>2</sup>)<br />
但是有一个地方必须注意，<u><strong><em>中心拓展</em></strong></u>中心一词是相对于长度为奇数的串的，<br />
对于偶数串我们要单独判断，方法也很简单看看该字符后一个字符是不是一样就行，代码里有解释<br />
代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中心向外拓展</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">maxPalindromeStringCenter</span><span class="params">(<span class="keyword">final</span> String target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target; <span class="comment">// 如果是空字符串则直接返回</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">beg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">// 回文串是奇数</span></span><br><span class="line">        <span class="keyword">while</span> (target.charAt(l) == target.charAt(r)) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span> (l == -<span class="number">1</span> || r == target.length())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="keyword">if</span> (r - l &gt; end - beg) &#123;</span><br><span class="line">            beg = l;</span><br><span class="line">            end = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回文串是偶数</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; target.length() - <span class="number">1</span> &amp;&amp; target.charAt(i + <span class="number">1</span>) == target.charAt(i)) &#123;</span><br><span class="line">            r = i + <span class="number">1</span>;</span><br><span class="line">            l = i;</span><br><span class="line">            <span class="keyword">while</span> (target.charAt(l) == target.charAt(r)) &#123;</span><br><span class="line">                l--;</span><br><span class="line">                r++;</span><br><span class="line">                <span class="keyword">if</span> (l == -<span class="number">1</span> || r == target.length())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">if</span> (r - l &gt; end - beg) &#123;</span><br><span class="line">                beg = l;</span><br><span class="line">                end = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring(beg, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp动态规划">Dp动态规划</h2>
<p>字符串类的题目怎么可能少了动态规划呢<br />
那么状态该怎么转移呢</p>
<p><strong><em>dp[i][j] = true ,if dp[i+1][j-1] == true &amp;&amp;
str[i]==str[j]</em></strong><br />
否则 <strong><em>dp[i][j] = false</em></strong></p>
<p>至于为什么，因为我们在已经知道串[i,j]是回文字串的时候<br />
只要 <strong><em>str[i-1] == str[j+1]</em></strong>
那么[i-1,j+1]也是一个回文子串<br />
为了更好找到最长所以这里将微循环设置为长度循环，内循环为字串头地址<br />
需要注意的是预处理，每个字母都是一个长度为1 的回文串<br />
和中心拓展类似偶数串中心是两个相同的字母所以还要考虑相邻字母相同的情况<br />
复杂度虽然和中心拓展一个数量级但是还是要比它快许多哦<br />
代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dp动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">maxPalindromeStringDp</span><span class="params">(<span class="keyword">final</span> String target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> target.length();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="type">int</span> <span class="variable">beginIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] isPalindrom = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            isPalindrom[i][j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        isPalindrom[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; target.charAt(i) == target.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">            isPalindrom[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            beginIndex = i;</span><br><span class="line">            maxLen = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">strlen</span> <span class="operator">=</span> <span class="number">3</span>; strlen &lt;= len; strlen++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len - strlen; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> i + strlen - <span class="number">1</span>; <span class="comment">// 字串结束的位置</span></span><br><span class="line">            <span class="keyword">if</span> (isPalindrom[i + <span class="number">1</span>][end - <span class="number">1</span>] == <span class="literal">true</span> &amp;&amp; target.charAt(i) == target.charAt(end)) &#123;</span><br><span class="line">                isPalindrom[i][end] = <span class="literal">true</span>;</span><br><span class="line">                maxLen = strlen;</span><br><span class="line">                beginIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring(beginIndex, beginIndex + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="manacher算法">Manacher算法</h2>
<p>很多人也许和我一样听到最长回文子串还有O(n)解法的时候是不相信的<br />
但是事实就是如此，这个算法也叫马拉车算法（只是谐音哦）<br />
我认为它也是一种动态规划思想 但是用的更加的巧妙<br />
在某种程度上和KMP算法有异曲同工之处</p>
<h3 id="统一格式化源字符串">1.统一格式化源字符串</h3>
<p>不知道是否有人注意到了上面几种算法在某些方面都考虑奇数串和偶数串的情况<br />
为了简化考虑情况设置一下规则：</p>
<p><span class="math inline">\(abcd\rightarrow
\#a\#b\#c\#d\#\)</span></p>
<p>这样所有的字符串就都是奇数串了</p>
<h3 id="设置映射关系">2.设置映射关系</h3>
<p>我们需要的是源字符串啊<br />
处理成那种乱七八糟的字符串，即使得到了结果还要将所有 <strong>#</strong>
取代<br />
所以我们看看能不能找到新串和原串之间的关系<br />
这样处理后表达一个回文串最好的方式就是中心mid（也就是为什么统一为奇数串的原因）和半径来表示r<br />
在我们知道mid和r的时候怎么确定原串呢。<br />
假设有串 <strong><em>#c#a#b#a#</em></strong> 原串是
<strong><em>caba</em></strong><br />
显而易见的是 <strong><em>aba</em></strong>
是回文串a在原串的下标是1<br />
在新串中下标是5，也就是 <strong><em>mid = 5 , r = 4</em></strong><br />
乍一看就是 <strong><em>beginIndex = mid-r</em></strong><br />
但是 <strong><em>#a#b#a# 此时 mid = 3， r = 4</em></strong> 那么
<strong><em>beginIndex = -1</em></strong><br />
显然不对所以我们在最开始处加上一个与#不同的符号$，那么新串即是
$#a#b#a#<br />
此时 <strong><em>mid = 4 r = 4</em></strong> 那就很符合了<br />
但是对 <strong><em>#c#a#b#a#</em></strong>
又不符合了，所以我们找到了新的关系 <strong><em>beginIndex =
(mid-r)/2</em></strong> 这是最符合的 感兴趣的小伙伴可以自己推一推</p>
<h3 id="找到-mid-以及-r">3.找到 <strong>mid</strong> 以及
<strong>r</strong></h3>
<p><strong><em>p[i] = mostRight &gt; i ? min(p[2 * mid - i], mostRight -
i) : 1;</em></strong><br />
p[i] 为以i为中心的半径 mostRight是已知的回文串右端点最右的那个的下标
mid则是其中心<br />
由于回文串的对称性 <strong><em>p[i] = min(p[2 * mid - i], mostRight -
i)</em></strong> p[2*mid-i]是其对称中心点下标<br />
他们两个在以mid为中心的<u><strong>回文串内</strong></u>对称部分相同也就是半径相同(一定注意是回文串内)<br />
在外面的部分我们无从得知只能老老实实匹配
也就是置为1（自己就是回文串）</p>
<h3 id="复杂度">4.复杂度</h3>
<p>因为每次循环内要不是用到以前的结论（对于的中心点）要么就是向右拓展<br />
所以复杂度是O(n)<br />
并不是有两个循环复杂度就是O(n<sup>2</sup>)</p>
<h3
id="代码如下其实先看代码可能更好理解">5.代码如下（其实先看代码可能更好理解）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manacher</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">maxPalindromeStringManacher</span><span class="params">(<span class="keyword">final</span> String target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;$#&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.length(); i++) &#123;</span><br><span class="line">        temp.append(target.charAt(i) + <span class="string">&quot;#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止$#a#b#a# 读到最后a的时候向两边扩散的时候溢出 C++则不需要C++字符串有/0结束符最后加的字符不能为$否则还是会溢出</span></span><br><span class="line">    temp.append(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="type">int</span>[] p = <span class="keyword">new</span> <span class="title class_">int</span>[temp.length() + <span class="number">1</span>]; <span class="comment">//以i为中心的半径</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 已知回文串所能达到的最右边的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 已知最右边的回文串的中心下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">resLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resMid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; temp.length() - <span class="number">1</span>; i++) &#123; <span class="comment">// 注意是从1开始第一个字符不算在内</span></span><br><span class="line">        <span class="comment">// 最关键一步 初始化已知的 p[i]</span></span><br><span class="line">        p[i] = mostRight &gt; i ? Math.min(p[<span class="number">2</span> * mid - i], mostRight - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.charAt(i + p[i]) == temp.charAt(i - p[i]))</span><br><span class="line">            p[i]++;</span><br><span class="line">        <span class="keyword">if</span> (mostRight &lt; i + p[i]) &#123;</span><br><span class="line">            mostRight = i + p[i];</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resLen &lt; p[i]) &#123;</span><br><span class="line">            resLen = p[i];</span><br><span class="line">            resMid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target.substring((resMid - resLen) / <span class="number">2</span>, (resMid - resLen) / <span class="number">2</span> + resLen - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果还有疑惑 可以参考下面两篇文章（我觉得很不错的）：<br />
<code>https://www.cnblogs.com/grandyang/p/4475985.html</code>(我也是这里学习的)
<code>https://mp.weixin.qq.com/s/Zrj35DrnQKtAENiR5llrcw</code>(漫画的形式讲的很清楚)
不好的地方 欢迎提出(￣▽￣)"</p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>IF I STAY</title>
    <url>/2019/01/12/2019-01-12-If_I_Stay/</url>
    <content><![CDATA[<blockquote>
<p>A Song To Share And Save</p>
</blockquote>
<span id="more"></span>
<h1 id="if-i-stay">IF I STAY</h1>
<figure>
<img src="/assets/ArticleImg/Life/If_I_Stay.jpg" alt="if i stay" />
<figcaption aria-hidden="true">if i stay</figcaption>
</figure>
<p>作曲 : <strong><em>逃跑计划</em></strong></p>
<p>作词 : <strong><em>Shaun Gibson</em></strong></p>
<p><a
href="http://music.163.com/song?id=37782201&amp;userid=592448485"><strong>Click
To Listening</strong></a></p>
<p><strong>Don’t you ever question why</strong></p>
<p>你从未问过我</p>
<p><strong>I’m by your side</strong></p>
<p>为何我会陪伴在你左右</p>
<p><strong>I’m here when you cry</strong></p>
<p>你哭泣时我在你身旁</p>
<p><strong>Cause he told you lies so slyly</strong></p>
<p>因为他那么狡猾 对你说尽谎言</p>
<p><strong>I run my fingers through your hair</strong></p>
<p>我的手指穿过你的秀发</p>
<p><strong>And show I care</strong></p>
<p>对你表明我多么在乎你</p>
<p><strong>But I’m not the one</strong></p>
<p>而我却不是那个</p>
<p><strong>That your heart belongs to nightly</strong></p>
<p>你每晚牵挂的唯一</p>
<p><strong>But if I stay would you kiss me in the summer
rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
<p><strong>I’ve loved you without regret</strong></p>
<p>我爱你无怨无悔</p>
<p><strong>Since the day we met</strong></p>
<p>自从我们相遇的那一天起</p>
<p><strong>If what you see’s what you get</strong></p>
<p>如果眼前的人就是你终会拥有的人</p>
<p><strong>Well I’ve had nothing yet</strong></p>
<p>那我认了 我依然一无所有</p>
<p><strong>For these past years</strong></p>
<p>即使过去了这么多年</p>
<p><strong>Tell me will you ever feel the same</strong></p>
<p>告诉我 你是否有过和我同样的感受</p>
<p><strong>If my love won’t tame?</strong></p>
<p>如果我的爱永不消减</p>
<p><strong>Or just like cellophane</strong></p>
<p>或者它就如玻璃纸一般脆弱</p>
<p><strong>Will I call your name unto deaf ears?</strong></p>
<p>我是否会在你耳畔轻唤你名字 就算你置若罔闻</p>
<p><strong>And if I stay would you kiss me in the summer
rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
<p><strong>If I stay would you kiss me in the summer rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
<p><strong>But if I stay would you kiss me in the summer
rain</strong></p>
<p>但我若留在你身边你会不会在夏日细雨中吻我</p>
<p><strong>Or let me wash away into the sand</strong></p>
<p>还是让我如雨水涤荡的尘沙 就此疏淡</p>
<p><strong>Would we lie together underneath the burning sun</strong></p>
<p>我们会不会一同躺在骄阳之下</p>
<p><strong>And let our two hearts beat as one</strong></p>
<p>两颗心跳动如一</p>
<p><strong>If I stay would you let me hold you in my arms</strong></p>
<p>若我留在你身边 你会让我拥你入怀吗</p>
<p><strong>And later take a walk beneath the stars</strong></p>
<p>然后我们漫步在星空之下</p>
<p><strong>Woah, tell me someday this could all be real</strong></p>
<p>喔 告诉我终有一天这一切都会成真</p>
<p><strong>And end this heartache I’m pained to feel</strong></p>
<p>结束这让我难熬的心痛</p>
]]></content>
      <categories>
        <category>Life Record</category>
      </categories>
      <tags>
        <tag>Songs</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的二进制阅读器</title>
    <url>/2018/11/02/2018-11-02-BinaryFileReader/</url>
    <content><![CDATA[<blockquote>
<p>在学习BMP位图的构成时，对网上的收费16进制查看器很是烦躁，notepad查看时卡到放弃人生</p>
<p>因为只是为了初步学习图片知识，以及查看2进制文件内部构成的话，可以自己实现一个</p>
</blockquote>
<h2 id="思路">思路</h2>
<ul>
<li><p>使用C++的文件操作进行二进制的读操作，这里默认以1个字节为单位（2位16进制）</p></li>
<li><p>每次读一个字节，就将其转化位16进制，读取的时候需要注意有符号数和无符号数的区别，我这里用<strong>unsigned
Char</strong> 来存取每一个字节的内容</p></li>
<li><p>对于C++的文件读写网上很多介绍</p></li>
<li><p>对于每一个读取的数写入文本文件内（.txt文件）便于查看</p></li>
<li><p>计算文件大小
通过C++的文件指针移动即首尾文件指针差除以1024即文件大小（KB）</p></li>
</ul>
<span id="more"></span>
<h2 id="代码如下">代码如下</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> HEX[<span class="number">16</span>] = &#123; <span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transfrom</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span>* hexNumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		hexNumber[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">while</span> (num != <span class="number">0</span> &amp;&amp; index &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		hexNumber[index--] = HEX[num % <span class="number">16</span>];</span><br><span class="line">		num = num / <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">getFileName</span><span class="params">(string&amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = filename.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (filename[i] == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			index = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> filename.<span class="built_in">substr</span>(index + <span class="number">1</span>, filename.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;    <span class="comment">//The Byte have been read</span></span><br><span class="line">	string path_r;</span><br><span class="line">	string path_w;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please input the File for read and write&#x27;s name: &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ifstream in;</span><br><span class="line">	ofstream out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;The file path to read: &quot;</span>;</span><br><span class="line">		<span class="built_in">getline</span>(cin, path_r);</span><br><span class="line">		in = ifstream(path_r, ios::binary);</span><br><span class="line">		<span class="keyword">if</span> (!in.<span class="built_in">is_open</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Error: File Path is Wrong&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Get the file path to Write</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The File Path to save(.txt): &quot;</span>;</span><br><span class="line">	<span class="built_in">getline</span>(cin, path_w);</span><br><span class="line">	out = <span class="built_in">ofstream</span>(path_w);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Get the File size</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> Beg = in.<span class="built_in">tellg</span>();</span><br><span class="line">	in.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::end);</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> End = in.<span class="built_in">tellg</span>();</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> fileSize = End - Beg;</span><br><span class="line">	in.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::beg);</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; <span class="built_in">getFileName</span>(path_r) &lt;&lt; <span class="string">&quot;\tFile Size: &quot;</span> &lt;&lt; fileSize / <span class="number">1024.0</span> &lt;&lt; 	<span class="string">&quot;KB&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//The index of every row</span></span><br><span class="line">	<span class="type">char</span> hexNumber[<span class="number">9</span>] = <span class="string">&quot;00000000&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Print the first row&#x27;s index</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> temp;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;\t\t&quot;</span>; <span class="comment">//Format index</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) out &lt;&lt; HEX[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	out &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Read and Write File</span></span><br><span class="line">	<span class="keyword">while</span> (in.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;temp, <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (num % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			out &lt;&lt; endl;</span><br><span class="line">			<span class="built_in">transfrom</span>(num, hexNumber);</span><br><span class="line">			out &lt;&lt; hexNumber &lt;&lt; <span class="string">&quot;:\t&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num++;</span><br><span class="line">		<span class="type">int</span> hex = (<span class="type">unsigned</span>)temp;</span><br><span class="line">		<span class="type">char</span> a = HEX[hex / <span class="number">16</span>];</span><br><span class="line">		<span class="type">char</span> b = HEX[hex % <span class="number">16</span>];</span><br><span class="line">		out &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	out.<span class="built_in">seekp</span>(<span class="number">0</span>,ios::beg);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Close file</span></span><br><span class="line">	in.<span class="built_in">close</span>();</span><br><span class="line">	out.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Read Successfully&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行说明">运行说明</h2>
<ul>
<li>不能输入输出文件名一致（可以自己试试ㄟ( ▔, ▔ )ㄏ）</li>
<li>首先输入需要读的文件（可以直接将文件拖入黑框
系统会自动输入绝对路径）</li>
<li>然后输入用于保存结果的 TXT 文件（如果不存在则在当前目录新建）</li>
</ul>
<h2 id="运行截图">运行截图</h2>
<blockquote>
<p>以读取Bmp图像为例</p>
</blockquote>
<p><img src="/assets/ArticleImg/2018/BinaryInput.jpg" /></p>
<p><img src="/assets/ArticleImg/2018/BinaryOutput.jpg" /></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径的三种算法以及路径还原与负圈判断</title>
    <url>/2018/12/07/2018-12-07-ShortestPath/</url>
    <content><![CDATA[<blockquote>
<p>图的基础，最短路径的几种解答</p>
<p>单源最短路： Bellman-Ford &amp; Dijkstra 及其简单优化
以及负圈的判断</p>
<p>多源最短路：Floyd-Warshall 算法的简单理解</p>
<p>路径还原问题</p>
<p>算法代码及思路主要参考：《挑战程序设计竞赛》</p>
</blockquote>
<p>在此之前读者应对图已经有基础的概念，以及图的邻接表 &amp;
邻接矩阵的表示方法</p>
<span id="more"></span>
<h2 id="bellman-ford">Bellman-Ford</h2>
<p>单源最短路问题是固定一个起点，然后求这个点到其他各个顶点的最短路（最小权值和）</p>
<p>设起点 s 到其他顶点 i 的距离为 d[i] 则很容易可以得到下面这个结论：
<span class="math display">\[
d[i] = min\{d[j] + edge(j,i)\} \quad edge(j,i) \in E
\]</span> 设置初始状态 d[s] = 0 else d[i] = INF
然后只要在循环里不断更新这些值</p>
<p>如果不再更新说明所有路都已达到最短 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123; <span class="type">int</span> from, to, cost;&#125;; <span class="comment">// 定义从点from指向to权值为cost的边</span></span><br><span class="line">Edge edges[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[MAXN]; <span class="comment">// 最短距离</span></span><br><span class="line"><span class="type">int</span> V,E; <span class="comment">// V: 顶点数 E: 边数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从点s到其他点的最小距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; V;i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 到自己为0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> isUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge temp = edges[i];</span><br><span class="line">            <span class="keyword">if</span>(d[temp.from] != INF &amp;&amp; d[temp.to] &gt; d[temp.from]+temp.cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[temp.to] = d[temp.from] + temp.cost;</span><br><span class="line">                isUpdate = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isUpdate) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果图中不存在 s 可达的负圈，那么最短路不会经过一个顶点两次，也就是说
最多通过 V-1 条边，也可以这样理</p>
<p>解，每一次更新都会有更短的路径产生，那么在 V
个点的图中，两个点的最远距离只能是 V-1 条边，所以循环最多</p>
<p>只会执行 V-1 次，这个特性将是我们判断是否存在负圈的重要性质</p>
<p>所以我们也可以将上面的代码简单化为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="type">int</span> s)</span> <span class="comment">// 不存在负圈的情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; V;i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 到自己为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; V<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge temp = edges[i];</span><br><span class="line">            d[temp.to] = <span class="built_in">min</span>(d[temp.to],d[temp.from]+temp.cost)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易可以看出来 Bellman 算法的复杂度为 O(V*E)</p>
<h3 id="负圈的判断">负圈的判断</h3>
<p>在这里，首先要明确<strong>负圈（负权环）</strong>和<strong>负权边</strong>的区别</p>
<p>负圈是指一条环状路径上的综合权值为负的，负权边是指权值为负数的边，在算法中如果图是无向图的话，</p>
<p><strong>负权边</strong>和<strong>负圈</strong>是<strong>等价</strong>的。如下图：也就是在A与B之间形成了一个环，这个环的权值为-2</p>
<p><img src="/assets/ArticleImg/2018/shortpath1.png" /></p>
<p>所以在无向图中负边的存在也就是负圈的存在。所以Bellman主要是可以用来判断有向图中是否存在负圈。</p>
<p>只要存在了负圈，那么 Bellman
的松弛操作（也就是那个每次更新的内容）将会永远的执行下去。</p>
<p>相当于没走一个这个负圈总的权值（路径长度）就会减少。但是我们上面已经得到在不存在负圈的图中最多执行
V-1
次循环，所以我们只要判断在第V次仍然更新了，那么就存在负圈了。代码只要更改一点点就行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="type">int</span> s)</span> <span class="comment">// 不存在负圈的情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; V;i++) d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 到自己为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; V;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge temp = edges[i];</span><br><span class="line">            <span class="keyword">if</span>(d[temp.from] != INF &amp;&amp; d[temp.to] &gt; d[temp.from]+temp.cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[temp.to] = d[temp.from] + temp.cost;</span><br><span class="line">                <span class="comment">// 只要再次加上到第V-1次的特判</span></span><br><span class="line">                <span class="keyword">if</span>(j == V<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;存在负圈&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra">Dijkstra</h2>
<p>我们先考虑不存在负边的情况，在 Bellman
算法中每一次都要全部遍历所有的边，而且如果d[i]本身不是最短路径</p>
<p>那么进行那个松弛操作之后的 d[i]
依然不是最短，所以可以对此进行优化：</p>
<ul>
<li><p>找到最短路径已经确定的顶点，更新从他出发相邻顶点的最短距离</p></li>
<li><p>从此不需要在更新上面已经确定的哪些顶点（即不需要遍历）</p></li>
</ul>
<p>这就衍生出了 Dijkstra 算法。上面两点用图来描述就是：</p>
<p><img src="/assets/ArticleImg/2018/shortpath2.png" /></p>
<p>假设初始点为 A 首先 AC &lt; AB</p>
<p>很清楚的我们可以得出结论 AC 就是A到C的最短路径，因为如果从 AB
方向走的话，AB ＞AC 而且我们的图是没有负边的，所以 BD &gt; 0 也就是说 AB
+ BD.... &gt; AC 是必然成立的。 所以 A-&gt;C
的最短路径已经确定了，之后就需要再去管C点了。算法总的描述如下：</p>
<p>在最开始时，只有起点的最短距离是确定的（而且所有点都未曾使用）。而在尚未使用的顶点中，距离d[i]最小的顶点就是最短距离已经确定的顶点。因为不存在负边，所以
d[i] 不会在以后的更新中变小。这就是 Dijkstra 算法</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAXN][MAXN]; <span class="comment">// cost[i][j] 表示从i到j之间的权值（不存在是为INF）</span></span><br><span class="line"><span class="type">int</span> d[MAXN]; <span class="comment">// 从起点到其他点的最短距离</span></span><br><span class="line"><span class="type">bool</span> used[MAXN]; <span class="comment">// 已经使用过的图（已经确定最短距离的点）</span></span><br><span class="line"><span class="type">int</span> V; <span class="comment">// 点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d,d+V,INF); <span class="comment">// algorithm中的函数 将d数组全部赋为INF</span></span><br><span class="line">    <span class="built_in">fill</span>(used,used+V,<span class="literal">false</span>);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// c从未使用过的点集中取一个距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        	<span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || d[u] &lt; d[v])) v = u;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 所有的点的最短路径确定则退出</span></span><br><span class="line">       	used[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            d[u] = <span class="built_in">min</span>(d[u],d[v]+cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单的优化">简单的优化</h3>
<p>上面代码的时间复杂度是 O(V<sup>2</sup>) ,
我们可以通过堆（优先队列）降为O(E*log(V))</p>
<p>上面有一个操作是找到距离最小的点和标记是否使用，这个就可以使用堆来优化</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; P; <span class="comment">// first 是最短距离 second 是顶点编号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to, cost&#125;;</span><br><span class="line">vector&lt;edge&gt; G[MAXN]; <span class="comment">// 使用邻接表存图</span></span><br><span class="line"><span class="type">int</span> d[MAXN]; <span class="comment">// 从起点到其他点的最短距离</span></span><br><span class="line"><span class="type">bool</span> used[MAXN]; <span class="comment">// 已经使用过的图（已经确定最短距离的点）</span></span><br><span class="line"><span class="type">int</span> V; <span class="comment">// 点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;P,vector&lt;P&gt;, greater&lt;P&gt; &gt; que; <span class="comment">// 定义一个堆 从按最短距离小到的大排</span></span><br><span class="line">    <span class="built_in">fill</span>(d,d+V,INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="built_in">P</span>(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) <span class="comment">// 为空就说明所有节点都已经用过</span></span><br><span class="line">    &#123;</span><br><span class="line">        P temp = que.<span class="built_in">top</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> v = temp.second;</span><br><span class="line">        <span class="keyword">if</span>(d[v] &lt; temp.first) <span class="keyword">continue</span>; <span class="comment">// 没必要更新了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G[v].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.to] &gt; d[v]+e.cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[e.to] = d[v]+e.cost;</span><br><span class="line">                que.<span class="built_in">push</span>(<span class="built_in">P</span>(d[e.to],e.to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd-warshall">Floyd-Warshall</h2>
<blockquote>
<p>Floyd算法简单暴力，主要用于求多源最短路径（任意两个点的最短路径）</p>
</blockquote>
<p>核心代码十分短小精悍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> d[MAXN][MAXN]; <span class="comment">// d[u][v] 表示从u -&gt; v的权值 不存在的时候为0</span></span><br><span class="line"><span class="type">int</span> V; <span class="comment">// 顶点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; V;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; V;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; V;j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>十分暴力复杂度可想而知O(V<sup>3</sup>)</p>
<p>那么这几行代码是什么意思呢？ 这其实还是 DP</p>
<p>我们用 d[k+1][i][j] 来表示只使用 0~k和 i,j 顶点的情况下的最短路</p>
<p>初始状态为 d[0][i][j] = cost[i][j] 所以我们可以得到下面这个式子：
<span class="math display">\[
d[k][i][j] =
\begin{cases}
d[k-1][i][j] 　(不经过点K)\\
d[k-1][i][k] + d[k-1][k][j]　（经过K点）\\
\end{cases}　＝　min(d[k-1][i][j],d[k-1][i][k] + d[k-1][k][j])
\]</span> 当然
我们可以稍微优化一下，时间以及到极限了，我们可以想办法把空间复杂度降下来</p>
<p>也就是我们上面那个形式，也就是为什么 K 必须放在最外面的原因</p>
<p>我们观察三维的那个式子与K相关的就只有 K 与 K-1
所以我们可以进行降维操作</p>
<p>也就是当K=s的时候，在执行状态压缩之前 d[i][j] 的值存都是的
d[k-1][i][j]</p>
<p>也就是将上一个状态动态保存起来了 所以才有上面的简短的代码</p>
<h2 id="路径还原">路径还原</h2>
<p>最后的问题就是当我们知道最短路径多少的时候，难免有时候需要知道该怎么走才有这条最短路径呢</p>
<p>用 Dijkstra 来演示路径还原 其他的算法也都可以用这个来解决</p>
<p>在此算法中满足 d[j] = d[k] +
cost[k][j]的点K我们称为j的前驱结点，也就是在到j之前必须经过点K</p>
<p>我们用一个数组 prev
来存相应节点的前驱结点，不断寻找前驱结点就可以找到最短路了，不过这是从后往前找，最后需要反转一下得到最后的答案。</p>
<p>示例代码如下： 注意第25行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cost[MAXN][MAXN]; <span class="comment">// cost[i][j] 表示从i到j之间的权值（不存在是为INF）</span></span><br><span class="line"><span class="type">int</span> d[MAXN]; <span class="comment">// 从起点到其他点的最短距离</span></span><br><span class="line"><span class="type">bool</span> used[MAXN]; <span class="comment">// 已经使用过的图（已经确定最短距离的点）</span></span><br><span class="line"><span class="type">int</span> V; <span class="comment">// 点的个数</span></span><br><span class="line"><span class="type">int</span> prev[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d,d+V,INF); <span class="comment">// algorithm中的函数 将d数组全部赋为INF</span></span><br><span class="line">    <span class="built_in">fill</span>(used,used+V,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">fill</span>(prev,prev+V,<span class="number">-1</span>); <span class="comment">// -1表示到头了 即没有前驱结点</span></span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// c从未使用过的点集中取一个距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        	<span class="keyword">if</span>(!used[u] &amp;&amp; (v == <span class="number">-1</span> || d[u] &lt; d[v])) v = u;</span><br><span class="line">        <span class="keyword">if</span>(v == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 所有的点的最短路径确定则退出</span></span><br><span class="line">       	used[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>;u &lt; V;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            d[u] = <span class="built_in">min</span>(d[u],d[v]+cost[v][u]);</span><br><span class="line">            prev[u] = v; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到顶点t的最短路</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_path</span><span class="params">(<span class="type">int</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(; t != <span class="number">-1</span>;t = prev[t]) path.<span class="built_in">push_pack</span>(t);</span><br><span class="line">    <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(),path.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>The end</strong> !!!</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>图像库stb_image &amp; stb_image_write</title>
    <url>/2019/02/24/2019-02-24-stb_image/</url>
    <content><![CDATA[<blockquote>
<p>Github: https://github.com/nothings/stb/</p>
</blockquote>
<h2 id="stb_image">stb_image</h2>
<blockquote>
<p>stb的库像素数据都是从左到右，从上到下存储</p>
<p>使用 stbi_set_flip_vertically_on_load(true); 上下翻转</p>
<p>使用 stbi_flip_vertically_on_write(true); 在写数据的时候翻转
（在stb_write_image中）</p>
</blockquote>
<span id="more"></span>
<h3 id="使用库">- 使用库</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;...&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION	<span class="comment">// include之前必须定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="局限">- 局限</h3>
<ul>
<li>no 12-bit-per-channel JPEG</li>
<li>no JPEGs with arithmetic coding</li>
<li>GIF always returns *comp=4</li>
</ul>
<h3 id="基础用法">- 基础用法</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x,y,n;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = stbi_load(<span class="string">&quot;filename&quot;</span>,&amp;x,&amp;y,&amp;n,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// filename : 文件名</span></span><br><span class="line"><span class="comment">// x : 图片宽 </span></span><br><span class="line"><span class="comment">// y : 图片高</span></span><br><span class="line"><span class="comment">// n : 颜色通道个数</span></span><br><span class="line"><span class="comment">// 最后一个为自己设置的颜色通道个数，如果非0就按照此数值读取图像</span></span><br><span class="line"><span class="comment">// 返回值非NULL说明导入成功</span></span><br><span class="line"><span class="comment">// Do Something</span></span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure>
<h4 id="颜色通道">颜色通道</h4>
<ul>
<li>1： 灰度图</li>
<li>2： 灰度Alpha图</li>
<li>3： 红绿蓝三色图</li>
<li>4： 红绿蓝三色Alpha图</li>
</ul>
<h4 id="错误信息">错误信息</h4>
<figure class="highlight plaintext"><figcaption><span>char* stbi_failure_reason()```返回错误信息字符串</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 定义 STBI_NO_FAILURE_STRINGS  避免编译这些字符串</span><br><span class="line">- 定义 STBI_FAILURE_USERMSG 使错误信息更加容易阅读</span><br><span class="line"></span><br><span class="line">#### Unicode</span><br><span class="line"></span><br><span class="line">Windows环境下可能需要满足Unicode的文件名</span><br><span class="line"></span><br><span class="line">`#define STBI_WINDOWS_UTF8`可以使文件名满足Unicode</span><br><span class="line"></span><br><span class="line">也可以使用`stbiw_convert_wchar_to_utf8`将`Windows wchar_t` 转换为 `utf8`.</span><br><span class="line"></span><br><span class="line">#### Addition</span><br><span class="line"></span><br><span class="line">- 预编译取消对某个格式的解析 ：#define STBI_NO_PNG....</span><br><span class="line">- 预编译限制只能某个格式解析 ：#define STBI_ONLY_PNG...</span><br><span class="line"></span><br><span class="line">### Else</span><br><span class="line"></span><br><span class="line">获取x,y位置的像素信息，data为图像指针,n为颜色通道数</span><br><span class="line"></span><br><span class="line">data[w\*n\*x+n\*y+i] (i = 0,1,..,n-1)</span><br><span class="line"></span><br><span class="line">作者还介绍了 SIMD支持， HDR图像支持， Iphone PNG支持</span><br><span class="line"></span><br><span class="line">## stb_image_write</span><br><span class="line"></span><br><span class="line">### - 使用库</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;...&gt;</span><br><span class="line">#define #define STB_IMAGE_WRITE_IMPLEMENTATION	// include之前必须定义</span><br><span class="line">#include &quot;stb_image_write.h&quot;</span><br></pre></td></tr></table></figure>
<h3 id="简单的使用">- 简单的使用</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stbi_write_png</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *filename, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> comp, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> stride_in_bytes)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">stbi_write_bmp</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *filename, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> comp, <span class="type">const</span> <span class="type">void</span> *data)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">stbi_write_tga</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *filename, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> comp, <span class="type">const</span> <span class="type">void</span> *data)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">stbi_write_jpg</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *filename, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> comp, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">int</span> quality)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">stbi_write_hdr</span><span class="params">(<span class="type">char</span> <span class="type">const</span> *filename, <span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> comp, <span class="type">const</span> <span class="type">float</span> *data)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="else">- Else</h3>
<p>作者还提到了PNG压缩，可提供自己的压缩函数，还有JPG质量的参数</p>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stb_image.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_WRITE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stb_image_write.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setAlpha</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n, <span class="type">int</span> w, <span class="type">int</span> alpha, <span class="type">unsigned</span> <span class="type">char</span> *data)</span> &#123;</span><br><span class="line">	data[w*n*x + y * n + n - <span class="number">1</span>] = alpha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *filepath = <span class="string">&quot;demo.png&quot;</span>;</span><br><span class="line">	<span class="type">int</span> w, h, n;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *data = stbi_load(filepath, &amp;w, &amp;h, &amp;n, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROE_FILE_NOT_LOAD&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; h &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="comment">// 将上半身设置为透明</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h / <span class="number">2</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">				setAlpha(i, j, n, w, <span class="number">0</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 写的时候翻转</span></span><br><span class="line">		stbi_flip_vertically_on_write(<span class="literal">true</span>);</span><br><span class="line">		stbi_write_png(<span class="string">&quot;out.png&quot;</span>, w, h, n, data, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">        stbi_image_free(data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>原图像 <img src="https://img-blog.csdnimg.cn/20190224135232798.png"
alt="在这里插入图片描述" /></li>
<li>处理后 <img src="https://img-blog.csdnimg.cn/20190224135301289.png"
alt="在这里插入图片描述" /></li>
</ul>
<p>作者还有一个<code>stb_image_resize.h</code>支持对图像的简单放缩平移等操作</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual Box 配置虚拟机 Ubuntu</title>
    <url>/2019/02/14/2019-02-14-VirtualBox_Ubuntu/</url>
    <content><![CDATA[<h2 id="虚拟机的简单概念">虚拟机的简单概念</h2>
<blockquote>
<p>摘自百度百科</p>
</blockquote>
<p>​ 虚拟机（Virtual
Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。
​
虚拟系统通过生成现有操作系统的全新虚拟镜像，它具有真实windows系统完全一样的功能，进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响
，而且具有能够在现有系统与虚拟镜像之间灵活切换的一类操作系统。虚拟系统和传统的虚拟机（Parallels
Desktop ，Vmware，VirtualBox，Virtual
pc）不同在于：虚拟系统不会降低电脑的性能，启动虚拟系统不需要像启动windows系统那样耗费时间，运行程序更加方便快捷；虚拟系统只能模拟和现有操作系统相同的环境，而虚拟机则可以模拟出其他种类的操作系统；而且虚拟机需要模拟底层的硬件指令，所以在应用程序运行速度上比虚拟系统慢得多。</p>
<span id="more"></span>
<h2 id="下载-virtual-box">1. 下载 Virtual Box</h2>
<h3 id="下载位置">下载位置</h3>
<p><code>https://www.virtualbox.org/wiki/Downloads</code></p>
<p>下载相应的版本即可</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_1.jpg"
alt="Download_Virtual_Box" />
<figcaption aria-hidden="true">Download_Virtual_Box</figcaption>
</figure>
<h2 id="下载ubuntu镜像文件">2. 下载Ubuntu镜像文件</h2>
<h3 id="下载位置-1">下载位置</h3>
<p><strong>官方网站：</strong><code>https://www.ubuntu.com/download/desktop</code></p>
<p><strong>网易镜像：</strong><code>http://mirrors.163.com/ubuntu-releases/</code>
=&gt; <strong>ubuntu-18.10-desktop-amd64.iso</strong></p>
<p>选一个合适的版本即可 这里采用的是Ubuntu-18.10,
国内镜像可能会快一些，你也可以采用其他镜像源</p>
<h2 id="开始安装">3. 开始安装</h2>
<h3 id="新建虚拟机">- 新建虚拟机</h3>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_2.jpg"
alt="add a VM" />
<figcaption aria-hidden="true">add a VM</figcaption>
</figure>
<p>后面都只需要默认即可</p>
<h3 id="配置选项">- 配置选项</h3>
<p>在这里设置内存大小，处理器等设置，内存、处理器酌情增加，太小巨卡</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_3.jpg"
alt="set VM" />
<figcaption aria-hidden="true">set VM</figcaption>
</figure>
<p>在第二个小光盘出点击选择一个虚拟光盘文件，也就是前面下载的Ubuntu镜像文件</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_4.jpg"
alt="set VM" />
<figcaption aria-hidden="true">set VM</figcaption>
</figure>
<h3 id="双击开启安装">- 双击开启安装</h3>
<p>语言可以先设置为中文简体，后面都只需要默认即可</p>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_5.jpg"
alt="apply" />
<figcaption aria-hidden="true">apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_9.jpg"
alt="apply" />
<figcaption aria-hidden="true">apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_6.jpg"
alt="apply" />
<figcaption aria-hidden="true">apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_7.jpg"
alt="apply" />
<figcaption aria-hidden="true">apply</figcaption>
</figure>
<figure>
<img src="\assets\ArticleImg\2019\virtualBox_Ubuntu_8.jpg"
alt="apply" />
<figcaption aria-hidden="true">apply</figcaption>
</figure>
<h3 id="最后重启即可">- 最后重启即可</h3>
<h3 id="注意事项">- 注意事项</h3>
<p><a
href="https://jingyan.baidu.com/article/ab0b56305f2882c15afa7dda.html">BIOS可能未开启虚拟化</a></p>
<p>一般不行就删掉重新来一遍，一般都可以</p>
<p>处理器最好选择2个以上，不然容易中途安装失败</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CYK Algorithm</title>
    <url>/2019/05/03/2019-05-03-CYK/</url>
    <content><![CDATA[<blockquote>
<p>原理参考：<a
href="https://blog.csdn.net/ssaalkjhgf/article/details/80435676"
class="uri">https://blog.csdn.net/ssaalkjhgf/article/details/80435676</a></p>
</blockquote>
<span id="more"></span>
<h3 id="实现过程">实现过程</h3>
<h4 id="类说明">类说明</h4>
<h5 id="cnf">CNF</h5>
<p>由一个字典初始化，输入为规范的范式</p>
<p><code>find_product</code>方法实现输入一个变元组合返回其生成变元</p>
<h5 id="cyk">CYK</h5>
<p>由一个CNF初始化，<code>find</code>方法用于判断字符串是否在CNF中</p>
<p>并保存推导过程，即动态规划数组</p>
<h5 id="input">Input</h5>
<p>实现自己的输入函数，一直等待输入直到输入EOF（Ctrl + Z）</p>
<p>并对输入字符串进行简单处理，切分</p>
<p>输入字符串格式为：<span class="math display">\[A -&gt; BC|AD|b
\]</span></p>
<p>其中空格可含可不含</p>
<h5 id="visualization">Visualization</h5>
<p>可视化类，将推导过程输出到<code>.csv</code>文件中</p>
<p>将<code>.csv</code>文件使用<strong>Excel</strong>打开便可查看完整推导过程</p>
<p>代码中已有完整注释和使用说明</p>
<h4 id="代码">代码</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Used for judging a string whether be in the CFL (presented in CNF) using CYK algorithm</span></span><br><span class="line"><span class="string">Author: Weijun-Lin</span></span><br><span class="line"><span class="string">Time: 2019-4-27</span></span><br><span class="line"><span class="string">Introduction: </span></span><br><span class="line"><span class="string">    For reading CNF you should use the format &quot;A -&gt; BC|a|b&quot; (the blank space is allowed except &quot;-&gt;&quot;)</span></span><br><span class="line"><span class="string">    The first character will be considered as CFL&#x27;s Start Symbol</span></span><br><span class="line"><span class="string">    And end inputing by input &quot;Ctrl + Z&quot;</span></span><br><span class="line"><span class="string">    For testing strings, you can input as many as strings you want</span></span><br><span class="line"><span class="string">    And exit by using &quot;ctrl + Z&quot;</span></span><br><span class="line"><span class="string">    For Output, the output format is the .csv file whcih should be checked by Excel</span></span><br><span class="line"><span class="string">    The output file name can be changed in codes (the default is &quot;result.csv&quot;)</span></span><br><span class="line"><span class="string">Attention:</span></span><br><span class="line"><span class="string">    When you test a new string, you must closed the last .csv file</span></span><br><span class="line"><span class="string">    Otherwise you will meet a I/O Error because the read-write conflict</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CNF</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cnf: <span class="built_in">dict</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; cnf: [str:list] &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.cnf = cnf</span><br><span class="line">        self.S = <span class="built_in">list</span>(cnf.keys())[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_product</span>(<span class="params">self, target: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; find the productor  &#x27;&#x27;&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> self.cnf.items():</span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> value:</span><br><span class="line">                res.append(key)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CYK</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cnf: CNF</span>):</span><br><span class="line">        self.cnf = cnf</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, target: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; judge if the target is in the CNF &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.dp_mat = [[<span class="string">&quot;&quot;</span>]*<span class="built_in">len</span>(target) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target))]</span><br><span class="line">        <span class="comment"># initialize</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)):</span><br><span class="line">            self.dp_mat[i][i] = <span class="built_in">list</span>(<span class="built_in">set</span>(self.cnf.find_product(target[i])))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(target) + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i,j are the position in dp_mat</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target) - length + <span class="number">1</span>):</span><br><span class="line">                j = i + length - <span class="number">1</span></span><br><span class="line">                temp = []</span><br><span class="line">                <span class="comment"># split the sub_target</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, j):</span><br><span class="line">                    list1 = self.dp_mat[i][k]</span><br><span class="line">                    list2 = self.dp_mat[k+<span class="number">1</span>][j]</span><br><span class="line">                    temp += self.find_product(list1, list2)</span><br><span class="line">                self.dp_mat[i][j] = <span class="built_in">list</span>(<span class="built_in">set</span>(temp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.cnf.S <span class="keyword">in</span> self.dp_mat[<span class="number">0</span>][<span class="built_in">len</span>(target) - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_product</span>(<span class="params">self, list1: <span class="built_in">list</span>, list2: <span class="built_in">list</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; find all productions from Cartesian product of two lists &#x27;&#x27;&#x27;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(list2)):</span><br><span class="line">                temp = self.cnf.find_product(list1[i]+list2[j])</span><br><span class="line">                <span class="keyword">if</span> temp != <span class="literal">None</span>:</span><br><span class="line">                    res += temp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; my input class for reading the CNF &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getDictItemFromInput</span>(<span class="params">self, s: <span class="built_in">str</span></span>):</span><br><span class="line">        s = s.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># delete extra blank spacing</span></span><br><span class="line">        temp = s.split(<span class="string">&quot;-&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> temp[<span class="number">0</span>], temp[<span class="number">1</span>].split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getInput</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; return a dict CNF &#x27;&#x27;&#x27;</span></span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                s = <span class="built_in">input</span>()</span><br><span class="line">                dict_item = self.getDictItemFromInput(s)</span><br><span class="line">                res[dict_item[<span class="number">0</span>]] = dict_item[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Visualization</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    make the deduction visualized</span></span><br><span class="line"><span class="string">    use dp_mat from class CYK to initialize</span></span><br><span class="line"><span class="string">    and creat .csv file to show in Excel</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data: <span class="built_in">list</span></span>):</span><br><span class="line">        self.data = [[<span class="string">&quot;&quot;</span>]*<span class="built_in">len</span>(data) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            temp = data[i][i:]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - i):</span><br><span class="line">                self.data[<span class="built_in">len</span>(data) - j - <span class="number">1</span>][i] = temp[j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">seeAsCsv</span>(<span class="params">self, filename: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; write data to filename as .csv &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.data)):</span><br><span class="line">                line = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.data[i])):</span><br><span class="line">                    temp = <span class="string">&quot;&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">type</span>(self.data[i][j]) == <span class="built_in">str</span>:</span><br><span class="line">                        temp = self.data[i][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        temp = <span class="string">&quot;\&quot;X&#123;&#125;,&#123;&#125;=&quot;</span>.<span class="built_in">format</span>(j+<span class="number">1</span>,<span class="built_in">len</span>(self.data)-i)+<span class="string">&quot;&#123;&quot;</span></span><br><span class="line">                        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.data[i][j])):</span><br><span class="line">                            temp = temp + self.data[i][j][k]</span><br><span class="line">                            <span class="keyword">if</span> k != <span class="built_in">len</span>(self.data[i][j]) - <span class="number">1</span>:</span><br><span class="line">                                temp = temp + <span class="string">&quot;,&quot;</span></span><br><span class="line">                        temp = temp + <span class="string">&quot;&#125;\&quot;&quot;</span></span><br><span class="line">                    line = line + temp + <span class="string">&quot;,&quot;</span></span><br><span class="line">                f.write(line + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Please Input the CNF: (The First Character must be Start symbol until Ctrl+Z )&quot;</span>)</span><br><span class="line">    myinput = Input()</span><br><span class="line">    <span class="comment"># get the CNF read until miss ctrl + Z</span></span><br><span class="line">    data_dict = myinput.getInput()</span><br><span class="line">    <span class="comment"># creat my CYK algorithm</span></span><br><span class="line">    cyk = CYK(CNF(data_dict))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;input the string: (until Ctrl+Z)&quot;</span>)</span><br><span class="line">    <span class="comment"># test the input string until read the ctrl + z</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            target_str = <span class="built_in">input</span>()</span><br><span class="line">            <span class="keyword">if</span> cyk.find(target_str):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br><span class="line">            visual = Visualization(cyk.dp_mat)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                visual.seeAsCsv(<span class="string">&quot;result.csv&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Write Error: Please Close Last csv file&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>图像旋转算法实现 Python</title>
    <url>/2019/05/12/2019-05-13-Img_Rotation/</url>
    <content><![CDATA[<h3 id="旋转原理">旋转原理</h3>
<blockquote>
<p>参考博客：<a
href="https://blog.csdn.net/liyuan02/article/details/6750828"
class="uri">https://blog.csdn.net/liyuan02/article/details/6750828</a></p>
</blockquote>
<span id="more"></span>
<p>如下图，推导点<span class="math inline">\((x_0,y_0)\)</span>旋转<span
class="math inline">\(\theta\)</span>到到点<span
class="math inline">\((x,y)\)</span>，半径为R</p>
<p><img src="/assets/ArticleImg/2019/ImgRotation_1.png" /></p>
<p>对于两点坐标可以这样表示：</p>
<p><span class="math display">\[
\begin{align}
x_0 =&amp; R*\cos\alpha \\
y_0 =&amp; R*\sin\alpha \\
For:x\\
x =&amp; R*\cos(\alpha-\theta) \\
=&amp; R*(\cos\alpha\cos\theta+\sin\alpha\sin\theta) \\
=&amp; x_0\cos\theta+y_0\sin\theta \\
For:y\\
y =&amp; R*(\sin(\alpha-\theta)) \\
=&amp; R*(\sin\alpha\cos\theta-\cos\alpha\sin\theta) \\
=&amp; y_0\cos\theta-x_0\sin\theta
\end{align}
\]</span></p>
<p>使用矩阵表示有：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
\]</span></p>
<p>此为顺时针旋转<span class="math inline">\(\theta\)</span>
，逆时针旋转<span class="math inline">\(\theta\)</span>只需要将 <span
class="math inline">\(\theta=-\theta\)</span> 即可，易得：<span
class="math inline">\((x,y)\rightarrow(x_0,y_0)\)</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
\cos\theta &amp; \sin\theta &amp; 0 \\
-\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
\]</span></p>
<h3 id="用于实际的旋转矩阵">用于实际的旋转矩阵</h3>
<p>上一部分的旋转矩阵是以数字坐标系推导的，而图像坐标系是以左上角为原点的图像坐标系，我们需要将图像坐标系转换为数字坐标系，方便的也需要从数字坐标系到图像坐标系的逆转换</p>
<p>假设原图片大小为<span
class="math inline">\(W,H\)</span>，旋转后所包含图片的最小矩形大小为<span
class="math inline">\(W^{&#39;},H^{&#39;}\)</span></p>
<p>设数字坐标系点为<span
class="math inline">\((x,y)\)</span>其相应的图像坐标系点为 <span
class="math inline">\((x_0,y_0)\)</span> 有如下表达式：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
-0.5W &amp; 0.5H &amp; 1
\end{matrix} \right]
\]</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix} \right]=
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
0.5W^{&#39;} &amp; 0.5H^{&#39;} &amp; 1
\end{matrix} \right]
\]</span></p>
<p>假设在图像坐标系中有点<span
class="math inline">\((x_0,y_0)\)</span>顺时针旋转<span
class="math inline">\(\theta\)</span> 到<span
class="math inline">\((x,y)\)</span>处转换后大小为<span
class="math inline">\(W^{&#39;},H^{&#39;}\)</span>，转换公式有：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix}
\right]=
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix}
\right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp;0 \\
-0.5W &amp; 0.5H &amp; 0 \\
\end{matrix}
\right]
*
\left[
\begin{matrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
0.5W^{&#39;} &amp; 0.5H^{&#39;} &amp; 1
\end{matrix} \right]\tag{1}
\]</span></p>
<p><span class="math display">\[
\left[
\begin{matrix}
x_0 &amp; y_0 &amp; 1
\end{matrix}
\right]=
\left[
\begin{matrix}
x &amp; y &amp; 1
\end{matrix}
\right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp; 0 \\
-0.5W^{&#39;} &amp; 0.5H^{&#39;} &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
\cos\theta &amp; \sin\theta &amp; 0 \\
-\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{matrix} \right]
*
\left[
\begin{matrix}
1 &amp; 0 &amp; 0 \\
0 &amp; -1 &amp;0 \\
0.5W &amp; 0.5H &amp; 0 \\
\end{matrix}
\right]\tag{2}
\]</span></p>
<p>(1)式为前向映射（直接从原图映射到旋转后的图），（2）式为后向映射（用于旋转后映射到旋转前）</p>
<h4
id="为什么需要后向映射而不是前向映射">为什么需要后向映射而不是前向映射</h4>
<p>之所以有<strong>后向映射</strong>是因为在<strong>前向映射</strong>中获取的旋转后坐标是浮点数，但是像素只能是整数，所以就产生了像素缺失</p>
<p>而从后向前映射像素信息都是存在的，但又存在映射到原图中的浮点坐标改如何选择颜色信息的问题</p>
<p>这就有内插值的问题，提供的解决办法有三个，<strong>最邻近内插</strong>、<strong>双线性内插</strong>、<strong>双三次内插</strong>，最邻近就是直接对浮点坐标取整，取最接近它的像素值，双线性内插就是取与它相邻的4个点，求线性渲染值</p>
<p>其本质就是：假设在数轴上有两个点A，B（A&lt;B)
AB中间有个点X，那么双线性内插就和知道X到点A的距离求X的值是一个道理，不过双线性需要对X和Y两个方向求值</p>
<p>双三次内插有点麻烦，这里。。我也不清楚，嘿嘿</p>
<p>可以参考<a
href="https://blog.csdn.net/caomin1hao/article/details/81092134"
class="uri">https://blog.csdn.net/caomin1hao/article/details/81092134</a></p>
<h3 id="python-实践">Python 实践</h3>
<p>所需外部库：</p>
<ul>
<li>numpy（矩阵计算）</li>
<li>matplotlib (效果演示)</li>
<li>skimage （只读取使用其内置图片 换cv2读自己图片也可以）</li>
</ul>
<blockquote>
<p>使用按像素遍历，比较耗时</p>
</blockquote>
<p>后向映射中使用最邻近内插和双线性内插（双三次内插暂未处理）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> skimage.data</span><br><span class="line"><span class="keyword">import</span> skimage.io</span><br><span class="line"></span><br><span class="line">angle = <span class="number">30</span>*np.pi/<span class="number">180</span></span><br><span class="line"><span class="comment"># 读取库图片 Attention 转换 默认为int8 运算时可能会溢出</span></span><br><span class="line">img = skimage.data.chelsea().astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># 设置新的图像大小</span></span><br><span class="line">h,w = img.shape[<span class="number">0</span>],img.shape[<span class="number">1</span>]</span><br><span class="line">newW = <span class="built_in">int</span>(w*<span class="built_in">abs</span>(np.cos(angle)) + h*<span class="built_in">abs</span>(np.sin(angle)))+<span class="number">1</span></span><br><span class="line">newH = <span class="built_in">int</span>(w*<span class="built_in">abs</span>(np.sin(angle)) + h*<span class="built_in">abs</span>(np.cos(angle)))+<span class="number">1</span></span><br><span class="line"><span class="comment"># Attention dtype</span></span><br><span class="line">newimg1 = np.zeros((newH,newW,<span class="number">3</span>),dtype = <span class="built_in">int</span>)</span><br><span class="line">newimg2 =  np.zeros((newH,newW,<span class="number">3</span>),dtype = <span class="built_in">int</span>)</span><br><span class="line">newimg3 =  np.zeros((newH,newW,<span class="number">3</span>),dtype = <span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># 设置旋转矩阵 scr -&gt; dex</span></span><br><span class="line">trans1 = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">0.5</span>*w,<span class="number">0.5</span>*h,<span class="number">1</span>]])</span><br><span class="line">trans1 = trans1.dot(np.array([[np.cos(angle),-np.sin(angle),<span class="number">0</span>],[np.sin(angle),np.cos(angle),<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]))</span><br><span class="line">trans1 = trans1.dot(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0.5</span>*newW,<span class="number">0.5</span>*newH,<span class="number">1</span>]]))</span><br><span class="line"><span class="comment"># des -&gt; src</span></span><br><span class="line">trans2 = np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">0.5</span>*newW,<span class="number">0.5</span>*newH,<span class="number">1</span>]])</span><br><span class="line">trans2 = trans2.dot(np.array([[np.cos(angle),np.sin(angle),<span class="number">0</span>],[-np.sin(angle),np.cos(angle),<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]))</span><br><span class="line">trans2 = trans2.dot(np.array([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0.5</span>*w,<span class="number">0.5</span>*h,<span class="number">1</span>]]))</span><br><span class="line"><span class="comment"># 开始旋转</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">        newPos = np.array([x,y,<span class="number">1</span>]).dot(trans1)</span><br><span class="line">        newimg1[<span class="built_in">int</span>(newPos[<span class="number">1</span>])][<span class="built_in">int</span>(newPos[<span class="number">0</span>])] = img[y][x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(newW):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(newH):</span><br><span class="line">        srcPos = np.array([x,y,<span class="number">1</span>]).dot(trans2)</span><br><span class="line">        <span class="keyword">if</span> srcPos[<span class="number">0</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> srcPos[<span class="number">0</span>] &lt; w <span class="keyword">and</span> srcPos[<span class="number">1</span>] &gt;= <span class="number">0</span> <span class="keyword">and</span> srcPos[<span class="number">1</span>] &lt; h:</span><br><span class="line">            <span class="comment"># 最邻近内插</span></span><br><span class="line">            newimg2[y][x] = img[<span class="built_in">int</span>(srcPos[<span class="number">1</span>])][<span class="built_in">int</span>(srcPos[<span class="number">0</span>])]</span><br><span class="line">            <span class="comment"># 双线性内插</span></span><br><span class="line">            bix,biy = <span class="built_in">int</span>(srcPos[<span class="number">0</span>]),<span class="built_in">int</span>(srcPos[<span class="number">1</span>]) <span class="comment"># 取左上角坐标</span></span><br><span class="line">            <span class="comment"># 避免最后一行溢出</span></span><br><span class="line">            <span class="keyword">if</span> bix &lt; w-<span class="number">1</span> <span class="keyword">and</span> biy &lt; h-<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 沿 X 方向线性内插</span></span><br><span class="line">                rgbX1 = img[biy][bix] + (img[biy][bix+<span class="number">1</span>] - img[biy][bix])*(srcPos[<span class="number">0</span>]-bix)</span><br><span class="line">                rgbX2 = img[biy+<span class="number">1</span>][bix] + (img[biy+<span class="number">1</span>][bix+<span class="number">1</span>] - img[biy+<span class="number">1</span>][bix])*(srcPos[<span class="number">0</span>]-bix)</span><br><span class="line">                <span class="comment"># 沿 Y  方向内插</span></span><br><span class="line">                rgb = rgbX1 + (rgbX2-rgbX1)*(srcPos[<span class="number">1</span>]-biy)</span><br><span class="line">                newimg3[y][x] = rgb</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">sub.set_title(<span class="string">&quot;Src Img&quot;</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">sub.set_title(<span class="string">&quot;Src-&gt;Des&quot;</span>)</span><br><span class="line">plt.imshow(newimg1)</span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">sub.set_title(<span class="string">&quot;Des-&gt;Src &amp; Nearest&quot;</span>)</span><br><span class="line">plt.imshow(newimg2)</span><br><span class="line">sub = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">sub.set_title(<span class="string">&quot;Des-&gt;Src &amp; Bilinear&quot;</span>)</span><br><span class="line">plt.imshow(newimg3)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="效果图展示">效果图展示</h3>
<p><img src="\assets\ArticleImg\2019\ImgRotation_2.png" /></p>
<p>可以看出来双线性比最邻近好的多了</p>
<p><img src="\assets\ArticleImg\2019\ImgRotation_3.png" /></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>DIP</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 01-03 从汇编到C语言</title>
    <url>/2020/01/24/2020-01-24-30OSMakeNote01-03/</url>
    <content><![CDATA[<h1 id="day-note">01-03-Day-Note</h1>
<blockquote>
<p>第一天到第三天的笔记</p>
</blockquote>
<span id="more"></span>
<h2 id="运行环境准备">1. 运行环境准备</h2>
<p>中文源码（包含每章节最终的翻译代码）：https://github.com/yourtion/30dayMakeOS</p>
<p>可以直接在作者提供的开发包中执行作者提供的文件，执行过程如下：</p>
<ol type="1">
<li>将对应<code>project</code>中包含源代码的目录复制到<code>tolset</code>中</li>
<li>执行对应的<code>Makefile</code>指令</li>
</ol>
<p><strong>需要在Windows的Shell环境下执行，在Git
Bash执行会存在命令的不一致问题</strong></p>
<p>作者在<code>nasm</code>的基础上开发了名为<code>nask</code>的汇编编译器，然后通过<code>imgtol</code>制作img镜像文件，最后通过<code>qemu</code>虚拟机运行此镜像文件，作者已经写好所有样例代码以及运行的脚本文件（批处理文件和Makefile）</p>
<p>上面所有的作者工具都在书本配套文件的<code>tolset</code>中</p>
<p>当然以上基础编译工具都可以使用已有工具代替（作者的类似很古老了）</p>
<h4 id="其他工具替代">其他工具替代</h4>
<ul>
<li><p>使用<code>nasm</code>替代<code>nask</code></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nasm infile.asm -o outfile.img</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用最新的 <code>qemu</code> 替代（此处为qemu4)</p>
<p><code>qemu</code>基本命令行参数参考
https://www.datarelab.com/blog/Technical_literature/562.html</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -fda youros.img</span><br></pre></td></tr></table></figure></p></li>
<li><p>代替作者的<code>imgtol</code></p>
<p>可以使用Linux的<code>dd</code>命令替换 Windows
下可在此处下载：http://www.chrysocome.net/download</p>
<p><code>dd</code>是类似<code>cp</code>的一个工具，不过<code>dd</code>针对的是块而cp针对的是文件</p>
<p>可参考：http://blackblog.tech/2018/07/19/CreateOSDay3/#comments</p></li>
</ul>
<h2 id="汇编">2. 汇编</h2>
<h3 id="i.-寄存器">i. 寄存器</h3>
<h4 id="位寄存器">16 位寄存器</h4>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">名字</th>
<th style="text-align: left;">功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">AX</td>
<td style="text-align: left;">accumulator， 累加寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">CX</td>
<td style="text-align: left;">counter， 计数寄存器</td>
</tr>
<tr class="odd">
<td style="text-align: left;">DX</td>
<td style="text-align: left;">data， 数据寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">BX</td>
<td style="text-align: left;">base， 基址寄存器</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SP</td>
<td style="text-align: left;">stack pointer， 栈指针寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">BP</td>
<td style="text-align: left;">base pointer， 基址指针寄存器</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SI</td>
<td style="text-align: left;">source index， 源变址寄存器</td>
</tr>
<tr class="even">
<td style="text-align: left;">DI</td>
<td style="text-align: left;">destination index， 目的变址寄存器</td>
</tr>
</tbody>
</table>
<h4 id="位寄存器-1">8 位寄存器</h4>
<table>
<thead>
<tr class="header">
<th>名字</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AL</td>
<td>累加寄存器低位（accumulator low）</td>
</tr>
<tr class="even">
<td>CL</td>
<td>计数寄存器低位（counter low）</td>
</tr>
<tr class="odd">
<td>DL</td>
<td>数据寄存器低位（data low）</td>
</tr>
<tr class="even">
<td>BL</td>
<td>基址寄存器低位（base low）</td>
</tr>
<tr class="odd">
<td>AH</td>
<td>累加寄存器高位（accumulator high）</td>
</tr>
<tr class="even">
<td>CH</td>
<td>计数寄存器高位（counter high）</td>
</tr>
<tr class="odd">
<td>DH</td>
<td>数据寄存器高位（data high）</td>
</tr>
<tr class="even">
<td>BH</td>
<td>基址寄存器高位（base high）</td>
</tr>
</tbody>
</table>
<h4 id="段寄存器">段寄存器</h4>
<table>
<thead>
<tr class="header">
<th>名字</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ES</td>
<td>附加段寄存器（extra segment）</td>
</tr>
<tr class="even">
<td>CS</td>
<td>代码段寄存器（code segment）</td>
</tr>
<tr class="odd">
<td>SS</td>
<td>栈段寄存器（stack segment）</td>
</tr>
<tr class="even">
<td>DS</td>
<td>数据段寄存器（data segment）</td>
</tr>
<tr class="odd">
<td>FS</td>
<td>没有名称（segment part 2）</td>
</tr>
<tr class="even">
<td>GS</td>
<td>没有名称（segment part 3）</td>
</tr>
</tbody>
</table>
<h4 id="位拓展寄存器">32 位拓展寄存器</h4>
<p>EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI （加了个extend拓展的标签）</p>
<h3 id="ii.-基础指令">ii. 基础指令</h3>
<ul>
<li><p>DB：按字节定义类似的还有DW（定义字），DD（定义双字）</p></li>
<li><p>MOV：移动指令<code>mov A, B</code>意为<code>A = B</code>,
<code>mov</code>后的寄存器或者字面量加上<code>[]</code>则代表引用此地址的值</p>
<p>如：<code>MOV AL, BYTE [BX]</code>，会将指定段寄存器乘16倍将上BX的值形成目标地址</p>
<p>BX、 BP、 SI、 DI这几个。 剩下的AX、 CX、 DX、
SP不能用来指定内存地址</p></li>
<li><p>JMP：跳转指令 跳转到指定内存地址</p></li>
<li><p>INT：软件中断指令 后接中断号，调用BIOS预设的函数（功能）</p></li>
<li><p>JE：相等则跳转（工具FLAGS寄存器的标志寄存器的值跳转）</p></li>
<li><p>CMP：比较两个寄存器（书面量）的值，修改对应的标志寄存器</p></li>
<li><p>HLT：让CPU进入待机状态只要外部发生变化， 比如按下键盘，
或是移动鼠标， CPU就会醒过来， 继续执行程序</p></li>
<li><p>RESB：填充指定数量字节的0x00</p></li>
<li><p>ORG：将指令加载到指定位置，详情可见：https://blog.csdn.net/yuduoluogongwu/article/details/7359242</p></li>
</ul>
<h3 id="iii.-nasm-和-nask-的区别">iii. NASM 和 NASK 的区别</h3>
<p>nask 和 nasm 部分语法不同，差别如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">NASK代码</th>
<th style="text-align: left;">NASM代码</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">JMP entry</td>
<td style="text-align: left;">JMP SHORT entry</td>
</tr>
<tr class="even">
<td style="text-align: right;">RESB <填充字节数></td>
<td style="text-align: left;">TIMES <填充字节数> DB <填充数据></td>
</tr>
<tr class="odd">
<td style="text-align: right;">RESB 0x7dfe-$</td>
<td style="text-align: left;">TIMES 0x1fe-($-$$) DB 0</td>
</tr>
<tr class="even">
<td style="text-align: right;">ALIGNB 16</td>
<td style="text-align: left;">ALIGN 16, DB 0</td>
</tr>
</tbody>
</table>
<p>在文中出现了美元符代表的意思如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ 是当前位置</span><br><span class="line">$$ 是段开始位置</span><br><span class="line">$ - $$ 是当前位置在段内的偏移</span><br></pre></td></tr></table></figure>
<h2 id="makefile">3. Makefile</h2>
<p>Makefile就像是一个非常聪明的批处理文件</p>
<p>具体操作说明可参考：http://www.ruanyifeng.com/blog/2015/02/make.html</p>
<h2 id="ipl">4. IPL</h2>
<h3 id="软盘-fat12">软盘 FAT12</h3>
<p>作者使用的是格式为<code>FAT12</code>格式的软盘</p>
<p>用Windows或MS-DOS格式化出来的软盘就是这种格式。
作者的helloos也采用了这种格式， 其中容纳了作者开发的操作系统。
这个格式兼容性好， 在Windows上也能用，
而且剩余的磁盘空间还可以用来保存自己喜欢的文件。</p>
<p>1张软盘有80个柱面， 2个磁头， 18个扇区， 且一个扇区有512字节。 所以，
一张软盘的容量是： 80×2×18×512 = 1474560 Byte = 1440KB</p>
<h3 id="启动区">启动区</h3>
<p>（boot sector） 软盘第一个的扇区称为启动区。 那么什么是扇区呢？
计算机读写软盘的时候， 并不是一个字节一个字节地读写的，
而是以512字节为一个单位进行读写。 因此,软盘的512字节就称为一个扇区。
一张软盘的空间共有1440KB， 也就是1474560字节， 除以512得2880，
这也就是说一张软盘共有2880个扇区。 那为什么第一个扇区称为启动区呢？
那是因为计算机首先从最初一个扇区开始读软盘，
然后去检查这个扇区最后2个字节的内容。如果这最后2个字节不是0x55 AA，
计算机会认为这张盘上没有所需的启动程序， 就会报一个不能启动的错误。
（也许有人会问为什么一定是0x55AA呢？ 那是当初的设计者随便定的，
笔者也没法解释） 。 如果计算机确认了第一个扇区的最后两个字节正好是0x55
AA， 那它就认为这个扇区的开头是启动程序， 并开始执行这个程序。</p>
<h3 id="ipl-启动程序装载器">IPL 启动程序装载器</h3>
<p>initial program loader的缩写。 启动程序加载器。
启动区只有区区512字节， 实际的操作系统不像hello-os这么小，
根本装不进去。 所以几乎所有的操作系统，
都是把加载操作系统本身的程序放在启动区里的。 有鉴于此，
有时也将启动区称为IPL。 但hello-os没有加载程序的功能，
所以HELLOIPL这个名字不太顺理成章。 如果有人正义感特别强，
觉得“这是撒谎造假， 万万不能容忍！ ”， 那也可以改成其他的名字。
但是必须起一个8字节的名字， 如果名字长度不到8字节的话，
需要在最后补上空格</p>
<h3 id="制作-ipl">制作 IPL</h3>
<p>计算机加载操作系统的流程如下：</p>
<ol type="1">
<li>从特定位置读取操作系统数据（USB或者软盘，软盘已经淘汰了），但这里使用的是软盘</li>
<li>软盘的第一个512字节的扇区作为启动区，执行此启动区指令</li>
<li>该启动区将软盘内容加载到内存指定位置(0x7c00)运行，根据最后两字节判断是否是启动区</li>
</ol>
<p>文中的IPL加载了软盘的10个柱面</p>
<p>文中的IPL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; haribote-ipl</span><br><span class="line">; TAB=4</span><br><span class="line"></span><br><span class="line">CYLS	EQU		10				; 声明CYLS=10</span><br><span class="line"></span><br><span class="line">		ORG		0x7c00			; 指明程序装载地址</span><br><span class="line"></span><br><span class="line">; 标准FAT12格式软盘专用的代码 Stand FAT12 format floppy code</span><br><span class="line"></span><br><span class="line">		JMP		entry</span><br><span class="line">		DB		0x90</span><br><span class="line">		DB		&quot;HARIBOTE&quot;		; 启动扇区名称（8字节）</span><br><span class="line">		DW		512				; 每个扇区（sector）大小（必须512字节）</span><br><span class="line">		DB		1				; 簇（cluster）大小（必须为1个扇区）</span><br><span class="line">		DW		1				; FAT起始位置（一般为第一个扇区）</span><br><span class="line">		DB		2				; FAT个数（必须为2）</span><br><span class="line">		DW		224				; 根目录大小（一般为224项）</span><br><span class="line">		DW		2880			; 该磁盘大小（必须为2880扇区1440*1024/512）</span><br><span class="line">		DB		0xf0			; 磁盘类型（必须为0xf0）</span><br><span class="line">		DW		9				; FAT的长度（必??9扇区）</span><br><span class="line">		DW		18				; 一个磁道（track）有几个扇区（必须为18）</span><br><span class="line">		DW		2				; 磁头数（必??2）</span><br><span class="line">		DD		0				; 不使用分区，必须是0</span><br><span class="line">		DD		2880			; 重写一次磁盘大小</span><br><span class="line">		DB		0,0,0x29		; 意义不明（固定）</span><br><span class="line">		DD		0xffffffff		; （可能是）卷标号码</span><br><span class="line">		DB		&quot;HARIBOTEOS &quot;	; 磁盘的名称（必须为11字?，不足填空格）</span><br><span class="line">		DB		&quot;FAT12   &quot;		; 磁盘格式名称（必??8字?，不足填空格）</span><br><span class="line">		RESB	18				; 先空出18字节</span><br><span class="line"></span><br><span class="line">; 程序主体</span><br><span class="line"></span><br><span class="line">entry:</span><br><span class="line">		MOV		AX,0			; 初始化寄存器</span><br><span class="line">		MOV		SS,AX</span><br><span class="line">		MOV		SP,0x7c00</span><br><span class="line">		MOV		DS,AX</span><br><span class="line"></span><br><span class="line">; 读取磁盘</span><br><span class="line"></span><br><span class="line">		MOV		AX,0x0820</span><br><span class="line">		MOV		ES,AX</span><br><span class="line">		MOV		CH,0			; 柱面0</span><br><span class="line">		MOV		DH,0			; 磁头0</span><br><span class="line">		MOV		CL,2			; 扇区2</span><br><span class="line"></span><br><span class="line">readloop:</span><br><span class="line">		MOV		SI,0			; 记录失败次数寄存器</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">		MOV		AH,0x02			; AH=0x02 : 读入磁盘</span><br><span class="line">		MOV		AL,1			; 1个扇区</span><br><span class="line">		MOV		BX,0</span><br><span class="line">		MOV		DL,0x00			; A驱动器</span><br><span class="line">		INT		0x13			; 调用磁盘BIOS</span><br><span class="line">		JNC		next			; 没出错则跳转到fin</span><br><span class="line">		ADD		SI,1			; 往SI加1</span><br><span class="line">		CMP		SI,5			; 比较SI与5</span><br><span class="line">		JAE		error			; SI &gt;= 5 跳转到error</span><br><span class="line">		MOV		AH,0x00</span><br><span class="line">		MOV		DL,0x00			; A驱动器</span><br><span class="line">		INT		0x13			; 重置驱动器</span><br><span class="line">		JMP		retry</span><br><span class="line">next:</span><br><span class="line">		MOV		AX,ES			; 把内存地址后移0x200（512/16十六进制转换）</span><br><span class="line">		ADD		AX,0x0020</span><br><span class="line">		MOV		ES,AX			; ADD ES,0x020因为没有ADD ES，只能通过AX进行</span><br><span class="line">		ADD		CL,1			; 往CL里面加1</span><br><span class="line">		CMP		CL,18			; 比较CL与18</span><br><span class="line">		JBE		readloop		; CL &lt;= 18 跳转到readloop</span><br><span class="line">		MOV		CL,1</span><br><span class="line">		ADD		DH,1</span><br><span class="line">		CMP		DH,2</span><br><span class="line">		JB		readloop		; DH &lt; 2 跳转到readloop</span><br><span class="line">		MOV		DH,0</span><br><span class="line">		ADD		CH,1</span><br><span class="line">		CMP		CH,CYLS</span><br><span class="line">		JB		readloop		; CH &lt; CYLS 跳转到readloop</span><br><span class="line"></span><br><span class="line">; 读取完毕，跳转到haribote.sys执行！</span><br><span class="line">		MOV		[0x0ff0],CH		; IPLがどこまで読んだのかをメモ</span><br><span class="line">		JMP		0xc200</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">		MOV		SI,msg</span><br><span class="line"></span><br><span class="line">putloop:</span><br><span class="line">		MOV		AL,[SI]</span><br><span class="line">		ADD		SI,1			; 给SI加1</span><br><span class="line">		CMP		AL,0</span><br><span class="line">		JE		fin</span><br><span class="line">		MOV		AH,0x0e			; 显示一个文字</span><br><span class="line">		MOV		BX,15			; 指定字符颜色</span><br><span class="line">		INT		0x10			; 调用显卡BIOS</span><br><span class="line">		JMP		putloop</span><br><span class="line"></span><br><span class="line">fin:</span><br><span class="line">		HLT						; 让CPU停止，等待指令</span><br><span class="line">		JMP		fin				; 无限循环</span><br><span class="line"></span><br><span class="line">msg:</span><br><span class="line">		DB		0x0a, 0x0a		; 换行两次</span><br><span class="line">		DB		&quot;load error&quot;</span><br><span class="line">		DB		0x0a			; 换行</span><br><span class="line">		DB		0</span><br><span class="line"></span><br><span class="line">		RESB	0x7dfe-$		; 填写0x00直到0x001fe</span><br><span class="line"></span><br><span class="line">		DB		0x55, 0xaa</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后以0x55aa结尾说明是启动区</p>
<p>该启动区代码包含了试错，循环读取扇区和柱面</p>
<p>主要注意：</p>
<ol type="1">
<li><p>第41行：<code>MOV        AX,0x0820</code></p>
<p>这段是把第一个柱面的第二个扇区（第一个为启动扇区），加载到内存<code>0x8200</code>的位置，0x13通过段寄存器ES和BX设置，这里ES为<code>0x0820</code>需要扩大16倍即为<code>0x8200</code></p>
<p>这里BIOS将系统启动代码（第一个扇区）加载到<code>0x8000</code>处，然后我们的IPL加载之后的扇区，所以将AX赋值为<code>0x0820</code>然后在赋值给ES</p></li>
<li><p>第82行：<code>JMP        0xc200</code></p>
<p>这里是启动区代码执行成功后，跳转到<code>0xc200</code>处执行代码</p>
<p>我们的真正的OS代码保留在软盘的<code>0x4200</code>的位置，软盘的第一个扇区的位置是<code>0x8000</code>所以有<code>0x8000+0x4200 = 0xc200</code>，所以跳转到此位置</p>
<p><code>0x4200</code>是因为向软盘写文件时一帮保存到此位置</p></li>
<li><p>第107行：<code>RESB  0x7dfe-$        ; 填写0x00直到0x001fe</code></p>
<p>只是将启动区后续部分填充为0</p>
<p><code>0x7dfe = 0x7c00 + 511</code>得到，表示512字节的启动区</p></li>
</ol>
<h2 id="导入c语言">5. 导入C语言</h2>
<p>文章中将C语言代码<code>bootpack.c</code>编译为32位汇编，要使用C语言，在操作系统中必然是C语言和汇编是混合复用的，所以需要专门的代码进行链接，文章中给出的是<code>asmhead.nas</code>,这里进行了对显卡显示模式的设置，以及对C语言的导入操作，可以到此文件中看一看，作者给出了很清楚的注释。（中文代码：https://github.com/yourtion/30dayMakeOS/blob/master/03_day/）</p>
<p>对C语言的处理作者分为以下几步：</p>
<ul>
<li>使用cc1.exe从bootpack.c生成bootpack.gas</li>
<li>使用gas2nask.exe从bootpack.gas生成bootpack.nas</li>
<li>使用nask.exe从bootpack.nas生成bootpack.obj</li>
<li>使用obj2bim.exe从bootpack.obj生成bootpack.bim</li>
<li>使用bim2hrb.exe从bootpack.bim生成bootpack.hrb</li>
<li>这样就做成了机器语言，
再使用copy指令将asmhead.bin与bootpack.hrb单纯结合到起来，
就成了haribote.sys</li>
</ul>
<p><code>cc1</code>是C编译器， 将C语言代码编译为32位的GAS的汇编代码</p>
<p><code>gas2nask</code>是将gas汇编编译为nasm识别的汇编格式了,通过nask（nasm）编译位OBJ目标文件</p>
<p><code>obj2bim</code>将目标文件编译为二进制镜像文件，方便不同的目标文件进行合并</p>
<p><code>bim2hrb</code>将最后的合并目标文件编译为<code>hrb</code>文件（这个是适合作者的这个编译环境的最终二进制文件）</p>
<h3 id="c语言调用汇编">C语言调用汇编</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB=4</span><br><span class="line"></span><br><span class="line">[FORMAT &quot;WCOFF&quot;]				; 制作目标文件的模式	</span><br><span class="line">[BITS 32]						; 制作32位模式用的机器语言</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 制作目标文件的信息</span><br><span class="line"></span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]			; 源文件名信息</span><br><span class="line"></span><br><span class="line">		GLOBAL	_io_hlt			; 程序中包含的函数名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 以下是实际的函数</span><br><span class="line"></span><br><span class="line">[SECTION .text]		; 目标文件中写了这些后再写程序</span><br><span class="line"></span><br><span class="line">_io_hlt:	; void io_hlt(void);</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>
<p>将此文件的<code>obj</code>文件和C语言的<code>obj</code>文件一起编译为<code>bim</code>即可(使用作者自带的工具)</p>
<p>有几个需要注意的地方：</p>
<ol type="1">
<li>需要和C语言链接的函数都需要标识为<code>GLOBAL</code>，反义为<code>LOCAL</code></li>
<li>导出的函数需要前加<code>_</code>，这样才能和C语言链接，C语言编译后的函数会加<code>_</code></li>
</ol>
<p>可以看看作者的<code>Makefile</code>可以更好的明白整个编译的过程</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 笔记目录</title>
    <url>/2020/01/24/2020-01-24-30OSMakeNoteAll/</url>
    <content><![CDATA[<h1 id="daysmakeos-note">30DaysMakeOS-Note</h1>
<blockquote>
<p>《30天自制操作系统》（川合秀实）阅读笔记</p>
</blockquote>
<h2 id="笔记目录">笔记目录</h2>
<ul>
<li><a
href="https://Weijun-Lin.top/2020/01/24/2020-01-24-30OSMakeNote01-03/">第一天到第三天——从汇编到C语言</a></li>
<li><a
href="https://Weijun-Lin.top/2020/01/26/2020-01-26-30OSMakeNote04/">第四天——C语言和画面显示的练习</a></li>
</ul>
<hr />
<span id="more"></span>
<p>书本实现了一个名为OSASK的只有80KB的简单操作系统，效果图如下</p>
<p><img src="/assets/Note/30DaysOs/Screen.png" style="zoom:50%;" /></p>
<h2 id="书本各章内容概要摘自原文">书本各章内容概要（摘自原文）</h2>
<h3 id="第一周第1天-第7天">第一周（第1天 ～ 第7天）</h3>
<p>一开始首先要考虑怎么来写一个“只要一通电就能运行的程序”。
这部分用C语言写 起来有些困难， 所以主要还是用汇编语言来写。
这步完成之后， 下一步就要写一个从磁盘读取操作系统的程序。
这时即便打开电脑 电源， 它也不会自动地将操作系统全部都读进来，
它只能读取磁盘上最开始的512 字节的内容，
所以我们要编写剩余部分的载入程序。 这个程序也要用汇编语言编 写。
一旦完成了这一步， 以后的程序就可以用C语言来编写了。 我们就尽快使用C语言
来学习开发显示画面的程序。 同时， 我们也能慢慢熟悉C语言语法。
这个时候我们 好像在做自己想做的事， 但事实上我们还没有自由操纵C语言。
接下来， 为了实现“移动鼠标”这一雄心， 我们要对CPU进行细致的设定，
并掌握中 断处理程序的写法。 从全书总体看来，
这一部分是水平相当高的部分， 笔者也觉得 放在这里有些不妥，
但从本书条理上讲， 这些内容必须放在这里， 所以只好请大家 忍耐一下了。
在这里， CPU的规格以及电脑复杂的规格都会给我们带来各种各样的 麻烦。
而且开发语言既有C语言， 又有汇编语言， 这又给我们造成了更大的混乱。
这个时候我们一点儿也不会觉得这是在做自己想做的事， 怎么看都像是在“受人摆
布”。 渡过这个痛苦的时期， 第一周就该结束了。</p>
<h3 id="第二周第8天-第14天">第二周（第8天 ～ 第14天）</h3>
<p>一周的苦战还是很有意义的， 回头一看，
我们就会发现自己还是斩获颇丰的。 这时 我们已经基本掌握了C语言的语法，
连汇编语言的水平也能达到本书的要求了。
所以现在我们就可以着手开发像样的操作系统了。
但是这一次我们又要为算法头痛 了。 即使掌握了编程语言的语法，
如果不懂得好的算法的话， 也还是不能开发出来 自己想要的操作系统。
所以这一周我们就边学习算法边慢慢地开发操作系统。 不过 到了这一阶段，
我们就能感觉到基本上不会再受技术问题限制了。</p>
<h3 id="第三周第15天-第21天">第三周（第15天 ～ 第21天）</h3>
<p>现在我们的技术已经相当厉害了， 可以随心所欲地开发自己的操作系统了。
首先是 要支持多任务， 然后是开发命令行窗口，
之后就可以着手开发应用程序了。 到本周 结束时， 就算还不够完备，
我们也能拿出一个可以称之为操作系统的软件了。</p>
<h3 id="第四周第22天-第28天">第四周（第22天 ～ 第28天）</h3>
<p>在这个阶段， 我们可以尽情地给操作系统增加各种各样的功能，
同时还可以开发出 大量像模像样的应用程序来。
这个阶段我们已经能做得很好了， 这可能也是我们最 高兴的时期。
这部分要讲解的内容很少， 笔者也不用再煞费苦心地去写那些文字说 明了，
可以把精力都集中在编程上（笑） 。 对了， 说起文字才想起来， 正好在这个
时期可以让我们的操作系统显示文字了。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 04 C语言和画面显示的练习</title>
    <url>/2020/01/26/2020-01-26-30OSMakeNote04/</url>
    <content><![CDATA[<h1 id="c语言和画面显示的练习">04 C语言和画面显示的练习</h1>
<p>原文中作者花了很大的力气讲解C语言的有关知识，这里就不多赘述了。。</p>
<span id="more"></span>
<h2 id="显示模式和显存">1. 显示模式和显存</h2>
<p>前一天的内容作者就将我们的操作系统的显示设置为<code>VGA 320*200 8 位调色板</code>模式，8位意味着我们可以使用256种颜色，但本质上VGA还是RGB成色模式，需要3个字节表示一个完整的颜色，我们只能设置色号，就是一个8位数到24位颜色的映射，设置的方法后面介绍。</p>
<p>并且将显示的分辨率设置为<code>320*200</code>，每一个像素都需要一个字节（8位）来表示颜色</p>
<p>此模式下显存的地址范围为<code>0xa0000 -0xaffff</code>，但是一个像素存储一个字节只需要<code>320*200</code>字节，但是显存范围是64K比存储像素的大一些，也不知是什么原因。。</p>
<h2 id="汇编实现内存写入">2. 汇编实现内存写入</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_write_mem8: ; void write_mem8(int addr, int data);</span><br><span class="line">    MOV ECX,[ESP+4] ; [ESP + 4]中存放的是地址， 将其读入ECX</span><br><span class="line">    MOV AL,[ESP+8] ; [ESP + 8]中存放的是数据， 将其读入AL</span><br><span class="line">    MOV [ECX],AL</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>
<p>这里是32位模式所以我们使用的寄存器都是拓展寄存器，这里C语言编译器函数参数是从右到左压入栈，所以这里只是简单的把一个32位的数据写到指定的32位地址的内存中去</p>
<h2 id="色号设定">3. 色号设定</h2>
<p>前面提到过我们的显示模式是VGA
8位调色板模式，需要自己对不同的256个颜色编号指定不同的颜色。作者使用了16种颜色来绘制他的操作系统，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> table_rgb[<span class="number">16</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,	<span class="comment">/*  0:黑 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,	<span class="comment">/*  1:梁红 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0x00</span>,	<span class="comment">/*  2:亮绿 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x00</span>,	<span class="comment">/*  3:亮黄 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xff</span>,	<span class="comment">/*  4:亮蓝 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0xff</span>,	<span class="comment">/*  5:亮紫 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,	<span class="comment">/*  6:浅亮蓝 */</span></span><br><span class="line">	<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,	<span class="comment">/*  7:白 */</span></span><br><span class="line">	<span class="number">0xc6</span>, <span class="number">0xc6</span>, <span class="number">0xc6</span>,	<span class="comment">/*  8:亮灰 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,	<span class="comment">/*  9:暗红 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x00</span>,	<span class="comment">/* 10:暗绿 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x00</span>,	<span class="comment">/* 11:暗黄 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>,	<span class="comment">/* 12:暗青 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x84</span>,	<span class="comment">/* 13:暗紫 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x84</span>,	<span class="comment">/* 14:浅暗蓝 */</span></span><br><span class="line">	<span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x84</span>	<span class="comment">/* 15:暗灰 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同时作者提供了许多帮助写如端口的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">io_hlt</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 之前出现过的悬停CPU</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">io_cli</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 中断标识位清零</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">io_out8</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> data)</span>;	<span class="comment">// 输出8位数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">io_load_eflags</span><span class="params">(<span class="type">void</span>)</span>;	<span class="comment">// 返回表示寄存器值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">io_store_eflags</span><span class="params">(<span class="type">int</span> eflags)</span>; <span class="comment">// 使用eflags重载表示寄存器</span></span><br></pre></td></tr></table></figure>
<p>其汇编实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB=4</span><br><span class="line"></span><br><span class="line">[FORMAT &quot;WCOFF&quot;]				; 制作目标文件的模式	</span><br><span class="line">[INSTRSET &quot;i486p&quot;]				; 使用到486为止的指令</span><br><span class="line">[BITS 32]						; 3制作32位模式用的机器语言</span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]			; 文件名</span><br><span class="line"></span><br><span class="line">		GLOBAL	_io_hlt, _io_cli, _io_sti, _io_stihlt</span><br><span class="line">		GLOBAL	_io_in8,  _io_in16,  _io_in32</span><br><span class="line">		GLOBAL	_io_out8, _io_out16, _io_out32</span><br><span class="line">		GLOBAL	_io_load_eflags, _io_store_eflags</span><br><span class="line"></span><br><span class="line">[SECTION .text]</span><br><span class="line"></span><br><span class="line">_io_hlt:	; void io_hlt(void);</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_cli:	; void io_cli(void);</span><br><span class="line">		CLI</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_sti:	; void io_sti(void);</span><br><span class="line">		STI</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_stihlt:	; void io_stihlt(void);</span><br><span class="line">		STI</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_in8:	; int io_in8(int port);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,0</span><br><span class="line">		IN		AL,DX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_in16:	; int io_in16(int port);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,0</span><br><span class="line">		IN		AX,DX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_in32:	; int io_in32(int port);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		IN		EAX,DX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_out8:	; void io_out8(int port, int data);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		AL,[ESP+8]		; data</span><br><span class="line">		OUT		DX,AL</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_out16:	; void io_out16(int port, int data);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,[ESP+8]		; data</span><br><span class="line">		OUT		DX,AX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_out32:	; void io_out32(int port, int data);</span><br><span class="line">		MOV		EDX,[ESP+4]		; port</span><br><span class="line">		MOV		EAX,[ESP+8]		; data</span><br><span class="line">		OUT		DX,EAX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_load_eflags:	; int io_load_eflags(void);</span><br><span class="line">		PUSHFD		; PUSH EFLAGS </span><br><span class="line">		POP		EAX</span><br><span class="line">		RET</span><br><span class="line"></span><br><span class="line">_io_store_eflags:	; void io_store_eflags(int eflags);</span><br><span class="line">		MOV		EAX,[ESP+4]</span><br><span class="line">		PUSH	EAX</span><br><span class="line">		POPFD		; POP EFLAGS </span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>
<p>代码中右<code>IN OUT</code>指令，这两个指令是CPU和其他输入输出设备交互的必备指令，<code>IN</code>从指定端口读入数据，<code>OUT</code>则是写数据，注意汇编中（C语言编译后）函数的返回值都是通过EAX寄存器</p>
<p>接下来要开始真正设置色号，VGA 调色板模式设置流程如下：</p>
<ol type="1">
<li>首先在一连串的访问中屏蔽中断（比如CLI） 。</li>
<li>将想要设定的调色板号码写入0x03c8， 紧接着， 按R， G， B的顺序写入
0x03c9。 如果还想继续设定下一个调色板， 则省略调色板号码， 再按照RGB的
顺序写入0x03c9就行了。</li>
<li>如果想要读出当前调色板的状态， 首先要将调色板的号码写入0x03c7， 再从
0x03c9读取3次。 读出的顺序就是R， G， B。 如果要继续读出下一个调色板，
同 样也是省略调色板号码的设定， 按RGB的顺序读出。</li>
<li>如果最初执行了CLI， 那么最后要执行STI</li>
</ol>
<p>对应的C语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">io_hlt</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">io_cli</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">io_out8</span><span class="params">(<span class="type">int</span> port, <span class="type">int</span> data)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">io_load_eflags</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">io_store_eflags</span><span class="params">(<span class="type">int</span> eflags)</span>;</span><br><span class="line"><span class="comment">/*就算写在同一个源文件里， 如果想在定义前使用， 还是必须事先声明一下。 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_palette</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">set_palette</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">unsigned</span> <span class="type">char</span> *rgb)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HariMain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i; <span class="comment">/* 声明变量。 变量i是32位整数型 */</span></span><br><span class="line">	<span class="type">char</span> *p; <span class="comment">/* 变量p是BYTE [...]用的地址 */</span></span><br><span class="line">	init_palette(); <span class="comment">/* 设定调色板 */</span></span><br><span class="line">    p = (<span class="type">char</span> *) <span class="number">0xa0000</span>; <span class="comment">/* 指定地址 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">0xffff</span>; i++) &#123;</span><br><span class="line">    	p[i] = i &amp; <span class="number">0x0f</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		io_hlt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_palette</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> table_rgb[<span class="number">16</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* 0:黑 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* 1:亮红 */</span></span><br><span class="line">    	<span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="comment">/* 2:亮绿 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="comment">/* 3:亮黄 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="comment">/* 4:亮蓝 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="comment">/* 5:亮紫 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="comment">/* 6:浅亮蓝 */</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="comment">/* 7:白 */</span></span><br><span class="line">        <span class="number">0xc6</span>, <span class="number">0xc6</span>, <span class="number">0xc6</span>, <span class="comment">/* 8:亮灰 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* 9:暗红 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="comment">/* 10:暗绿 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="comment">/* 11:暗黄 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="comment">/* 12:暗青 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="comment">/* 13:暗紫 */</span></span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x84</span>, <span class="number">0x84</span>, <span class="comment">/* 14:浅暗蓝 */</span></span><br><span class="line">        <span class="number">0x84</span>, <span class="number">0x84</span>, <span class="number">0x84</span> <span class="comment">/* 15:暗灰 */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	set_palette(<span class="number">0</span>, <span class="number">15</span>, table_rgb);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/* C语言中的static char语句只能用于数据， 相当于汇编中的DB指令 */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">set_palette</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">unsigned</span> <span class="type">char</span> *rgb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, eflags;</span><br><span class="line">    eflags = io_load_eflags(); <span class="comment">/* 记录中断许可标志的值*/</span></span><br><span class="line">    io_cli(); <span class="comment">/* 将中断许可标志置为0， 禁止中断 */</span></span><br><span class="line">    io_out8(<span class="number">0x03c8</span>, start);</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">    	io_out8(<span class="number">0x03c9</span>, rgb[<span class="number">0</span>] / <span class="number">4</span>);</span><br><span class="line">    	io_out8(<span class="number">0x03c9</span>, rgb[<span class="number">1</span>] / <span class="number">4</span>);</span><br><span class="line">    	io_out8(<span class="number">0x03c9</span>, rgb[<span class="number">2</span>] / <span class="number">4</span>);</span><br><span class="line">		rgb += <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    io_store_eflags(eflags); <span class="comment">/* 复原中断许可标志 */</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/assets/Note/30DaysOs/04_1.png" style="zoom:50%;" /></p>
<h2 id="绘制矩形">3. 绘制矩形</h2>
<p>画面坐标系都是左上坐标系（左上角为顶点），所以对于坐标<code>(x,y)</code>我们只需要通过<code>0xa0000 + x + y * 320</code>定为该坐标的对应地址，这么一来绘制矩形就简单多了</p>
<p>绘制矩形代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vram: 对应显存地址 0xa0000</span></span><br><span class="line"><span class="comment">xsize: 对应宽</span></span><br><span class="line"><span class="comment">c: 颜色编号</span></span><br><span class="line"><span class="comment">左上-右下坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">boxfill8</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *vram, <span class="type">int</span> xsize, <span class="type">unsigned</span> <span class="type">char</span> c, <span class="type">int</span> x0, <span class="type">int</span> y0, <span class="type">int</span> x1, <span class="type">int</span> y1)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (y = y0; y &lt;= y1; y++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (x = x0; x &lt;= x1; x++)</span><br><span class="line">			vram[y * xsize + x] = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/assets/Note/30DaysOs/04_2.png" style="zoom:50%;" /></p>
<p>作者最后还绘制了一个简陋的界面都是通过绘制矩形实现这里就不多说了</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《30天自制操作系统》 05-08部分 从字符显示到中断处理</title>
    <url>/2020/02/09/2020-02-09-30OSMakeNote05-08/</url>
    <content><![CDATA[<h2 id="文字鼠标显示">1. 文字鼠标显示</h2>
<h3 id="a.-定义bootinfo结构体">a. 定义BOOTINFO结构体</h3>
<blockquote>
<p>这个结构体包含操作系统的基础信息</p>
</blockquote>
<span id="more"></span>
<p>结构体声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BOOTINFO</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> cyls, leds, vmode, reserve;</span><br><span class="line">	<span class="type">short</span> scrnx, scrny;</span><br><span class="line">	<span class="type">char</span> *vram;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; asmhead.nas</span><br><span class="line">; BOOT_INFO相关</span><br><span class="line">CYLS	EQU		0x0ff0			; 引导扇区设置</span><br><span class="line">LEDS	EQU		0x0ff1</span><br><span class="line">VMODE	EQU		0x0ff2			; 关于颜色的信息</span><br><span class="line">SCRNX	EQU		0x0ff4			; 分辨率X</span><br><span class="line">SCRNY	EQU		0x0ff6			; 分辨率Y</span><br><span class="line">VRAM	EQU		0x0ff8			; 图像缓冲区的起始地址</span><br><span class="line">		ORG		0xc200			;  这个的程序要被装载的内存地址</span><br><span class="line"></span><br><span class="line">; 画面设定</span><br><span class="line"></span><br><span class="line">		MOV		AL,0x13			; VGA显卡，320x200x8bit</span><br><span class="line">		MOV		AH,0x00</span><br><span class="line">		INT		0x10</span><br><span class="line">		MOV		BYTE [VMODE],8	; 屏幕的模式（参考C语言的引用）</span><br><span class="line">		MOV		WORD [SCRNX],320</span><br><span class="line">		MOV		WORD [SCRNY],200</span><br><span class="line">		MOV		DWORD [VRAM],0x000a0000		</span><br></pre></td></tr></table></figure>
<p>作者没有对<code>BOOTINFO.reserve</code>说明，仔细看<code>asmhead.nas</code>可以发现VMODE只有一个字节的内容，但是<code>SCRNX</code>是从<code>0xff4</code>开始，中间有一个字节是没有做任何设定的，由此可以看出这一个字节的内容是暂时保留的。</p>
<p>启动信息的开始地址是0xff0，所以我们通过<code>struct BOOTINFO *binfo = (struct BOOTINFO *) 0x0ff0;</code>设置好我们的结构体。</p>
<h3 id="b.-字符和鼠标指针显示">b. 字符和鼠标指针显示</h3>
<p>简单来说，和之前我们绘制矩形一样的思路，整个屏幕都是就是一个<code>320*200</code>大小的一个画布，需要显示字符只要将对应位置置为一个颜色就可以了，如下</p>
<p><img src="/assets/Note/30DaysOs/05_1.png" style="zoom:50%;" /></p>
<p>其中每一个1代表此处应该置为一个对应颜色，此时的字体大小为16*8</p>
<p>作者给出的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只是将位为1的位置置为对应的颜色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putfont8</span><span class="params">(<span class="type">char</span> *vram, <span class="type">int</span> xsize, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> c, <span class="type">char</span> *font)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">char</span> *p, d <span class="comment">/* data */</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">		p = vram + (y + i) * xsize + x;</span><br><span class="line">		d = font[i];</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x80</span>) != <span class="number">0</span>) &#123; p[<span class="number">0</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x40</span>) != <span class="number">0</span>) &#123; p[<span class="number">1</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x20</span>) != <span class="number">0</span>) &#123; p[<span class="number">2</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x10</span>) != <span class="number">0</span>) &#123; p[<span class="number">3</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x08</span>) != <span class="number">0</span>) &#123; p[<span class="number">4</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x04</span>) != <span class="number">0</span>) &#123; p[<span class="number">5</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x02</span>) != <span class="number">0</span>) &#123; p[<span class="number">6</span>] = c; &#125;</span><br><span class="line">		<span class="keyword">if</span> ((d &amp; <span class="number">0x01</span>) != <span class="number">0</span>) &#123; p[<span class="number">7</span>] = c; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者给出了他为每一个字符定义的字体，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hankaku.txt</span></span><br><span class="line"><span class="comment">// 此文件通过作者的 makefont.exe编译为目标文件</span></span><br><span class="line"><span class="comment">// 只是将其中的字体文件解析相应的字节数据</span></span><br><span class="line"><span class="type">char</span> <span class="number">0x41</span></span><br><span class="line">........</span><br><span class="line">...**...</span><br><span class="line">...**...</span><br><span class="line">...**...</span><br><span class="line">...**...</span><br><span class="line">..*..*..</span><br><span class="line">..*..*..</span><br><span class="line">..*..*..</span><br><span class="line">..*..*..</span><br><span class="line">.******.</span><br><span class="line">.*....*.</span><br><span class="line">.*....*.</span><br><span class="line">.*....*.</span><br><span class="line">***..***</span><br><span class="line">........</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<p>因为这是外部定义的数据，所以在我们的C语言源文件中，需要使用的话需要增加
<strong><em>extern char hankaku[4096];</em></strong></p>
<p>字符串的显示也类似处理即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">putfonts8_asc</span><span class="params">(<span class="type">char</span> *vram, <span class="type">int</span> xsize, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> c, <span class="type">unsigned</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">char</span> hankaku[<span class="number">4096</span>];</span><br><span class="line">	<span class="keyword">for</span> (; *s != <span class="number">0x00</span>; s++) &#123;</span><br><span class="line">		putfont8(vram, xsize, x, y, c, hankaku + *s * <span class="number">16</span>);</span><br><span class="line">		x += <span class="number">8</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标的显示也是类似的，不过作者定义了一个16*16大小的指针，作者这个鼠标太没有美感了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_mouse_cursor8</span><span class="params">(<span class="type">char</span> *mouse, <span class="type">char</span> bc)</span></span><br><span class="line"><span class="comment">/* マウスカーソルを準備（16x16） */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> cursor[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">		<span class="string">&quot;**************..&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOOOOO*...&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOOOO*....&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOOO*.....&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOO*......&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOO*.......&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOO*.......&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOOOOOO*......&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOOO**OOO*.....&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OOO*..*OOO*....&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*OO*....*OOO*...&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*O*......*OOO*..&quot;</span>,</span><br><span class="line">		<span class="string">&quot;**........*OOO*.&quot;</span>,</span><br><span class="line">		<span class="string">&quot;*..........*OOO*&quot;</span>,</span><br><span class="line">		<span class="string">&quot;............*OO*&quot;</span>,</span><br><span class="line">		<span class="string">&quot;.............***&quot;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">16</span>; y++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">16</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cursor[y][x] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">				mouse[y * <span class="number">16</span> + x] = COL8_000000;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (cursor[y][x] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">				mouse[y * <span class="number">16</span> + x] = COL8_FFFFFF;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (cursor[y][x] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">				mouse[y * <span class="number">16</span> + x] = bc;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在https://www.cnblogs.com/bitzhuwei/p/OS-in-30-days-05-initialize-keyboard-and-mouse.html有人给出了一个更好看的鼠标，更加符合Windows风格的鼠标</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> cursor[<span class="number">16</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	<span class="string">&quot;*...............&quot;</span>,</span><br><span class="line">	<span class="string">&quot;**..............&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*O*.............&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OO*............&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOO*...........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOO*..........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOOO*.........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOOOO*........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOOOOO*.......&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OOOO*****......&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*OO*O*..........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*O*.*O*.........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;**..*O*.........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;*....*O*........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;.....*O*........&quot;</span>,</span><br><span class="line">	<span class="string">&quot;......*.........&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后的效果图如下：</p>
<p><img src="/assets/Note/30DaysOs/05_2.png" style="zoom:50%;" /></p>
<h2 id="gdtidt初始化">2. GDT/IDT初始化</h2>
<h3 id="a.-gdtidt基础">a. GDT/IDT基础</h3>
<p>所谓分段，简单来说就是把4GB的内存切分为很多的块，每一块的起始地址都可以看作0来处理，这样子对我们写程序就十分的方便，通过<code>DS:EBX</code>获取对应的地址，在32位模式（保护模式）下，需要对GDT（global（segment）
descriptor table
全局段号记录表）进行相应的配置。（这里DS：EBX是作者给出的32位寻址方式，但是有32位的EDS也可以作为寄存器，我怀疑是否是进行了DS和GDT之间的一个映射）</p>
<p>表示一个段需要有以下几个信息:</p>
<ul>
<li>段的大小是多少</li>
<li>段的起始地址在哪里</li>
<li>段的管理属性（禁止写入， 禁止执行， 系统专用等）</li>
</ul>
<p>CPU使用8个字节的数据来表示这些信息，用于指定段的寄存器只有16位。
或许有人会猜想在32位模式下， 段寄存器会扩展到64位，
但事实上段寄存器仍然是16位。那该怎么办才好呢？
可以模仿图像调色板的做法。 也就是说， 先有一个段号4， 存放在段寄存器里。
然后预先设定好段号与段的对应关系。</p>
<p>段寄存器是16位，但由于CPU设计上的原因，段寄存器的低三位不能够使用（作者也没有表明是用作什么用），所以我们只有13位的段号，范围是0~8191，所以我们需要把8192*8
= 64KB的数据写到内存的对应位置，这一部分的数据就是GDT了。</p>
<p>相应的IDT（interrupt descriptor table
中断记录表）是实现操作系统中断功能必需的。IDT记录了0~255的中断号码与调用函数之间的对应关系，设定方法和GDT十分类似，在对IDT设置之前必须进行GDT的设定。</p>
<h3 id="b.-gdtidt设置">b. GDT/IDT设置</h3>
<p>部分摘自：</p>
<p>https://blog.csdn.net/misskissC/article/details/100593986 (haribote
dsctbl.c 设置GDT和IDT程序阅读注释)</p>
<p>IDT
描述符可参考：https://blog.csdn.net/fwqcuc/article/details/5855460</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">base指的是32位的基地址，在这里分为了low,mid,high三个部分，这里分为3段主要是和80286时代的程序相兼容</span></span><br><span class="line"><span class="comment">limit是指段上限，表示这个段有多少字节</span></span><br><span class="line"><span class="comment">段上限分为高低，但是只有20位，这里看上去有3个字节但是limit_high的高四位用于保存段属性</span></span><br><span class="line"><span class="comment">limit_high的高四位和access_right这12位是段属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEGMENT_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> limit_low, base_low;</span><br><span class="line">    <span class="type">char</span> base_mid, access_right;</span><br><span class="line">    <span class="type">char</span> limit_high, base_high;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">offset_high&amp;&amp;offset_low,</span></span><br><span class="line"><span class="comment">中断或异常处理程序在其所在内存段中的偏移;</span></span><br><span class="line"><span class="comment">selector,处理程序所在内存段的段选择符;</span></span><br><span class="line"><span class="comment">dw_count,保留未用;</span></span><br><span class="line"><span class="comment">access_right,IDT描述符有效位,特权级(DPL),类型(TYPE)等属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GATE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> offset_low, selector;</span><br><span class="line">    <span class="type">char</span> dw_count, access_right;</span><br><span class="line">    <span class="type">short</span> offset_high;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_gdtidt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0x270000~0x27ffff设为GDT，将此处设置为地址并没有特别的意义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SEGMENT_DESCRIPTOR</span> *<span class="title">gdt</span> =</span> (<span class="keyword">struct</span> SEGMENT_DESCRIPTOR *)<span class="number">0x00270000</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GATE_DESCRIPTOR</span> *<span class="title">idt</span> =</span> (<span class="keyword">struct</span> GATE_DESCRIPTOR *)<span class="number">0x0026f800</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* GDT的初始化 这里只是简单的全部初始化为1*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8192</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_segmdesc(gdt + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置1，2两个段1代表的是整个内存，2保留的是我们的bootpack.hrb</span></span><br><span class="line">    set_segmdesc(gdt + <span class="number">1</span>, <span class="number">0xffffffff</span>, <span class="number">0x00000000</span>, <span class="number">0x4092</span>);</span><br><span class="line">    set_segmdesc(gdt + <span class="number">2</span>, <span class="number">0x0007ffff</span>, <span class="number">0x00280000</span>, <span class="number">0x409a</span>);</span><br><span class="line">    <span class="comment">// gdtr保存的是GDT的首地址，修改寄存器需要使用汇编，所以定义在naskfunc.nas</span></span><br><span class="line">    <span class="comment">// 下面这个函数就是设置段上限和起始地址</span></span><br><span class="line">    <span class="comment">// _load_gdtr: ; void load_gdtr(int limit, int addr);</span></span><br><span class="line">    <span class="comment">//     MOV AX,[ESP+4] ; limit</span></span><br><span class="line">    <span class="comment">//     MOV [ESP+6],AX</span></span><br><span class="line">    <span class="comment">//     LGDT [ESP+6]    ; 从ESP+6处读取6个字节内容</span></span><br><span class="line">    <span class="comment">//     RET</span></span><br><span class="line">    load_gdtr(<span class="number">0xffff</span>, <span class="number">0x00270000</span>);</span><br><span class="line">    <span class="comment">/* IDT的初始化 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        set_gatedesc(idt + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    load_idtr(<span class="number">0x7ff</span>, <span class="number">0x0026f800</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_segmdesc,</span></span><br><span class="line"><span class="comment">设置sd指向的GDT段描述符,</span></span><br><span class="line"><span class="comment">sd,GDT段描述符内存首地址;limit,段描述符所描述内存段基于段基址最大偏移;</span></span><br><span class="line"><span class="comment">base,段描述符所描述内存段基址;ar,段描述符特权级,类型等属性。</span></span><br><span class="line"><span class="comment">ar格式为：xxxx0000xxxxxxxx 高四位存入limit_high的高四位低8位保存到access_right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_segmdesc</span><span class="params">(<span class="keyword">struct</span> SEGMENT_DESCRIPTOR *sd, <span class="type">unsigned</span> <span class="type">int</span> limit, <span class="type">int</span> base, <span class="type">int</span> ar)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    高四位格式为GD00,G代表是否*4KB计算，D代表段的模式1为32位模式，0为16位</span></span><br><span class="line"><span class="comment">    如果超过1M大小则将G_bit置为1，此时CPU会将limit*4KB计算段上限</span></span><br><span class="line"><span class="comment">    ar的低8位有以下：</span></span><br><span class="line"><span class="comment">    00000000（0x00） ： 未使用的记录表（descriptor table） 。</span></span><br><span class="line"><span class="comment">    10010010（0x92） ： 系统专用， 可读写的段。 不可执行。</span></span><br><span class="line"><span class="comment">    10011010（0x9a） ： 系统专用， 可执行的段。 可读不可写。</span></span><br><span class="line"><span class="comment">    11110010（0xf2） ： 应用程序用， 可读写的段。 不可执行。</span></span><br><span class="line"><span class="comment">    11111010（0xfa） ： 应用程序用， 可执行的段。 可读不可写</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (limit &gt; <span class="number">0xfffff</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ar |= <span class="number">0x8000</span>; <span class="comment">/* G_bit = 1 */</span></span><br><span class="line">        limit /= <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据GDT段描述符位格式,通过GDT段描述符结构体设置GDT描述符。</span></span><br><span class="line"><span class="comment">    bit[15..0],内存段长度低16位;</span></span><br><span class="line"><span class="comment">    bit[31..16],内存段基址低16位;</span></span><br><span class="line"><span class="comment">    bit[39..32],内存段基址23..16位;</span></span><br><span class="line"><span class="comment">    bit[47..40],有效位P,特权级DPL,类型TYPE等;</span></span><br><span class="line"><span class="comment">    bit[55..48],内存颗粒度,内存段长度19..16位;</span></span><br><span class="line"><span class="comment">    bit[63..56],内存段基址高8位。    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sd-&gt;limit_low = limit &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_low = base &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_mid = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;access_right = ar &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;limit_high = ((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>) | ((ar &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xf0</span>);</span><br><span class="line">    sd-&gt;base_high = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_gatedesc,</span></span><br><span class="line"><span class="comment">设置gd指向的IDT描述符,</span></span><br><span class="line"><span class="comment">gd,IDT描述符内存首地址;offset,处理程序在其所在段的偏移地址;</span></span><br><span class="line"><span class="comment">selector,处理程序所在内存段的段选择符;ar,IDT描述符有效位,特权级,类型等属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_gatedesc</span><span class="params">(<span class="keyword">struct</span> GATE_DESCRIPTOR *gd, <span class="type">int</span> offset, <span class="type">int</span> selector, <span class="type">int</span> ar)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据IDT段描述符位格式,通过IDT描述符结构体设置IDT描述符。</span></span><br><span class="line"><span class="comment">    bit[15..0],处理程序偏移地址低16位;</span></span><br><span class="line"><span class="comment">    bit[31..16],处理程序所在内存段的段选择符;</span></span><br><span class="line"><span class="comment">    bit[39..32],保留未用;</span></span><br><span class="line"><span class="comment">    bit[47..40],有效位P,特权级DPL,类型TYPE等;</span></span><br><span class="line"><span class="comment">    bit[63..48],处理程序偏移地址高16位。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    gd-&gt;offset_low = offset &amp; <span class="number">0xffff</span>;</span><br><span class="line">    gd-&gt;selector = selector;</span><br><span class="line">    gd-&gt;dw_count = (ar &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    gd-&gt;access_right = ar &amp; <span class="number">0xff</span>;</span><br><span class="line">    gd-&gt;offset_high = (offset &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xffff</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中断处理">3. 中断处理</h2>
<p>前面已经正确的将GDT以及IDT初始化完成了，要使用中断还需要初始化<strong><em>PIC（programmable
interrupt controller
可编程中断控制器）</em></strong>，前面提到中断向量表IDT可以配置256个中断向量号，但是x86系列机提供15个可编程中断，其他中断大多是系统中断。</p>
<p>x86使用的是2片PIC（8259A）级联形成的15个可编程中断。如下图主IPC的2号中断和从IPC连接，所以一共只有15个中断。</p>
<p><img src="/assets/Note/30DaysOs/06_1.png" style="zoom:50%;" /></p>
<p>链接：<a
href="https://blog.csdn.net/longintchar/article/details/79439466">8259A详细工作原理</a></p>
<p>PIC 初始化（对相关寄存器进行配置）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_pic</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"><span class="comment">/* PIC初始化 */</span></span><br><span class="line">&#123;</span><br><span class="line">	io_out8(PIC0_IMR,  <span class="number">0xff</span>  ); <span class="comment">/* 禁止所有中断 */</span></span><br><span class="line">	io_out8(PIC1_IMR,  <span class="number">0xff</span>  ); <span class="comment">/* 禁止所有中断 */</span></span><br><span class="line"></span><br><span class="line">	io_out8(PIC0_ICW1, <span class="number">0x11</span>  ); <span class="comment">/* 边缘触发模式（edge trigger mode） */</span></span><br><span class="line">	io_out8(PIC0_ICW2, <span class="number">0x20</span>  ); <span class="comment">/* IRQ0-7由INT20-27接收 */</span></span><br><span class="line">	io_out8(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>); <span class="comment">/* PIC1由IRQ2相连 */</span></span><br><span class="line">	io_out8(PIC0_ICW4, <span class="number">0x01</span>  ); <span class="comment">/* 无缓冲区模式 */</span></span><br><span class="line"></span><br><span class="line">	io_out8(PIC1_ICW1, <span class="number">0x11</span>  ); <span class="comment">/* 边缘触发模式（edge trigger mode） */</span></span><br><span class="line">	io_out8(PIC1_ICW2, <span class="number">0x28</span>  ); <span class="comment">/* IRQ8-15由INT28-2f接收 */</span></span><br><span class="line">	io_out8(PIC1_ICW3, <span class="number">2</span>     ); <span class="comment">/* PIC1由IRQ2连接 */</span></span><br><span class="line">	io_out8(PIC1_ICW4, <span class="number">0x01</span>  ); <span class="comment">/* 无缓冲区模式 */</span></span><br><span class="line"></span><br><span class="line">	io_out8(PIC0_IMR,  <span class="number">0xfb</span>  ); <span class="comment">/* 11111011 PIC1以外全部禁止 */</span></span><br><span class="line">	io_out8(PIC1_IMR,  <span class="number">0xff</span>  ); <span class="comment">/* 11111111 禁止所有中断 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<strong>ICW2</strong>我们实现将IRQ和INT号相绑定</p>
<p>大家可能会对此有兴趣， 所以再详细介绍一下。 中断发生以后，
如果CPU可以受理这个中断， CPU就会命令PIC发送2个字节的数据。
这2个字节是怎么传送的呢？ CPU与PIC用IN或OUT进行数据传送时，
有数据信号线连在一起。 PIC就是利用这个信号线发送这2个字节数据的。
送过来的数据是“0xcd 0x??”这两个字节。 由于电路设计的原因，
这两个字节的数据在CPU看来， 与从内存读进来的程序是完全一样的，
所以CPU就把送过来的“0xcd
0x??”作为机器语言执行。这恰恰就是把数据当作程序来执行的情况。
这里的0xcd就是调用BIOS时使用的那个INT指令。 我们在程序里写的“INT 0x10”，
最后就被编译成了“0xcd0x10”。 所以， CPU上了PIC的当，
按照PIC所希望的中断号执行了INT指令。</p>
<p>注意这里的IRQ全部绑定到了INT
20开始的位置，PIC的中断一般默认都是设置在此位置，其他的中断号一般是为其他类型的中断准备的。</p>
<p><strong>鼠标是IRQ12， 键盘是IRQ1，对应的INT是于INT 0x2c和INT
0x21。</strong>这似乎是规定好的。</p>
<p>中断与函数跳转很相似，但是需要IRETD作为中断返回的标志，这个指令不能使用C语言编写，所以需要汇编的帮助。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;因为inthandler21定义在别的文件所以要加上extern</span><br><span class="line">EXTERN	_inthandler21</span><br><span class="line">_asm_inthandler21:</span><br><span class="line">		PUSH	ES</span><br><span class="line">		PUSH	DS</span><br><span class="line">		PUSHAD</span><br><span class="line">		MOV		EAX,ESP</span><br><span class="line">		PUSH	EAX</span><br><span class="line">		MOV		AX,SS</span><br><span class="line">		MOV		DS,AX</span><br><span class="line">		MOV		ES,AX</span><br><span class="line">		CALL	_inthandler21</span><br><span class="line">		POP		EAX</span><br><span class="line">		POPAD</span><br><span class="line">		POP		DS</span><br><span class="line">		POP		ES</span><br><span class="line">		IRETD</span><br></pre></td></tr></table></figure>
<p>关于在DS和ES中放入SS值的部分， 因为C语言自以为是地认为“DS也好，
ES也好，SS也好， 它们都是指同一个段”， 所以如果不按照它的想法设定的话，
函数inthandler21就不能顺利执行。 所以， 虽然麻烦了一点，
但还是要这样做。</p>
<p>然后我们只需要对<code>inthandler21</code>和其他类似的中断函数进行编写了</p>
<p>通过<code>set_gatedesc</code>配置中断记录表，这个函数在前面提到过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// INT 21键盘中断</span></span><br><span class="line">set_gatedesc(idt + <span class="number">0x21</span>, (<span class="type">int</span>) asm_inthandler21, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INT 27 IRQ中断</span></span><br><span class="line"><span class="comment">PIC0中断的不完整策略</span></span><br><span class="line"><span class="comment">这个中断在Athlon64X2上通过芯片组提供的便利，只需执行一次</span></span><br><span class="line"><span class="comment">这个中断只是接收，不执行任何操作</span></span><br><span class="line"><span class="comment">为什么不处理？</span></span><br><span class="line"><span class="comment">	→  因为这个中断可能是电气噪声引发的、只是处理一些重要的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">set_gatedesc(idt + <span class="number">0x27</span>, (<span class="type">int</span>) asm_inthandler27, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="comment">// INT 2c鼠标中断</span></span><br><span class="line">set_gatedesc(idt + <span class="number">0x2c</span>, (<span class="type">int</span>) asm_inthandler2c, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br></pre></td></tr></table></figure>
<h3 id="fifo-缓冲配置">FIFO 缓冲配置</h3>
<p>中断几乎是无时无刻不再发生的，处理一个中断的过程中可能有其他中断发生，所以我们需要把处理中断的程序编写的越短越好（操作系统中中断是有优先级的，这里作者并没有明确的说明）</p>
<p>所以在我们处理键盘鼠标这类外部设备的中断时，获取到数据之后不用急忙处理，而是将其放置到一个缓冲区中，等到之后处理。这个缓冲区的大小和其他设计很值得考量。作者给出了一个FIFO缓冲区的实现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* FIFO */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bootpack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLAGS_OVERRUN		0x0001</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fifo8_init</span><span class="params">(<span class="keyword">struct</span> FIFO8 *fifo, <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">char</span> *buf)</span></span><br><span class="line"><span class="comment">/* 初始化FIFO缓冲区 */</span></span><br><span class="line">&#123;</span><br><span class="line">	fifo-&gt;size = size;</span><br><span class="line">	fifo-&gt;buf = buf;</span><br><span class="line">	fifo-&gt;<span class="built_in">free</span> = size; <span class="comment">/* 缓冲区大小 */</span></span><br><span class="line">	fifo-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	fifo-&gt;p = <span class="number">0</span>; <span class="comment">/* 下一个数据写入位置 */</span></span><br><span class="line">	fifo-&gt;q = <span class="number">0</span>; <span class="comment">/* 下一个数据读出位置 */</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fifo8_put</span><span class="params">(<span class="keyword">struct</span> FIFO8 *fifo, <span class="type">unsigned</span> <span class="type">char</span> data)</span></span><br><span class="line"><span class="comment">/* 向FIFO传送数据并保存 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;<span class="built_in">free</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* 没有空间了，溢出 */</span></span><br><span class="line">		fifo-&gt;flags |= FLAGS_OVERRUN;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;buf[fifo-&gt;p] = data;</span><br><span class="line">	fifo-&gt;p++;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;p == fifo-&gt;size) &#123;</span><br><span class="line">		fifo-&gt;p = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;<span class="built_in">free</span>--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fifo8_get</span><span class="params">(<span class="keyword">struct</span> FIFO8 *fifo)</span></span><br><span class="line"><span class="comment">/* 从FIFO取得一个数据 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;<span class="built_in">free</span> == fifo-&gt;size) &#123;</span><br><span class="line">		<span class="comment">/* 如果缓冲区为空则返回-1 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	data = fifo-&gt;buf[fifo-&gt;q];</span><br><span class="line">	fifo-&gt;q++;</span><br><span class="line">	<span class="keyword">if</span> (fifo-&gt;q == fifo-&gt;size) &#123;</span><br><span class="line">		fifo-&gt;q = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fifo-&gt;<span class="built_in">free</span>++;</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fifo8_status</span><span class="params">(<span class="keyword">struct</span> FIFO8 *fifo)</span></span><br><span class="line"><span class="comment">/* 报告一下积攒是数据量 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> fifo-&gt;size - fifo-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现还是比较容易的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inthandler21</span><span class="params">(<span class="type">int</span> *esp)</span></span><br><span class="line"><span class="comment">/* 来自PS/2键盘的中断 */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BOOTINFO</span> *<span class="title">binfo</span> =</span> (<span class="keyword">struct</span> BOOTINFO *) ADR_BOOTINFO;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data, s[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">/* 通知PIC IRQ-01 已经受理完毕 否则不处理下一次中断 */</span></span><br><span class="line">	io_out8(PIC0_OCW2, <span class="number">0x61</span>);</span><br><span class="line">	data = io_in8(PORT_KEYDAT);</span><br><span class="line">	fifo8_put(&amp;keyfifo, data);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<code>inthandler21</code>里面只需要对数据保存即可，然后在<code>bootpack.c</code>主循环中显示对应的信息即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bootpack.c</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		io_cli();</span><br><span class="line">		<span class="keyword">if</span> (fifo8_status(&amp;keyfifo) + fifo8_status(&amp;mousefifo) == <span class="number">0</span>) &#123;</span><br><span class="line">			io_stihlt();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (fifo8_status(&amp;keyfifo) != <span class="number">0</span>) &#123;</span><br><span class="line">				i = fifo8_get(&amp;keyfifo);</span><br><span class="line">				io_sti();</span><br><span class="line">				<span class="built_in">sprintf</span>(s, <span class="string">&quot;%02X&quot;</span>, i);</span><br><span class="line">				boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484,  <span class="number">0</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">31</span>);</span><br><span class="line">				putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, <span class="number">0</span>, <span class="number">16</span>, COL8_FFFFFF, s);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fifo8_status(&amp;mousefifo) != <span class="number">0</span>) &#123;</span><br><span class="line">				i = fifo8_get(&amp;mousefifo);</span><br><span class="line">				io_sti();</span><br><span class="line">				<span class="built_in">sprintf</span>(s, <span class="string">&quot;%02X&quot;</span>, i);</span><br><span class="line">				boxfill8(binfo-&gt;vram, binfo-&gt;scrnx, COL8_008484, <span class="number">32</span>, <span class="number">16</span>, <span class="number">47</span>, <span class="number">31</span>);</span><br><span class="line">				putfonts8_asc(binfo-&gt;vram, binfo-&gt;scrnx, <span class="number">32</span>, <span class="number">16</span>, COL8_FFFFFF, s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对鼠标的操作也是类似的</p>
<h2 id="鼠标控制">4. 鼠标控制</h2>
<p>参考代码解释：<a
href="https://www.twblogs.net/a/5d737f19bd9eee5327ff7f64/zh-cn">粗略阅读haribote鼠标管理程序
mouse.c</a></p>
<p>要使鼠标中断可以被CPU响应，除了配置中断记录表还需要执行激活鼠标的指令，所以我们需要配置两个装置，一个是鼠标控制电路，一个是鼠标本身。鼠标控制电路包含在键盘控制电路中，只要键盘控制电路初始化完成，鼠标电路控制器也就激活完成了。</p>
<p>键盘电路初始化代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYDAT 0x0060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYSTA 0x0064</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYCMD 0x0064</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSTA_SEND_NOTREADY 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYCMD_WRITE_MODE 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KBC_MODE 0x47</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait_KBC_sendready</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    等待键盘控制电路准备完毕</span></span><br><span class="line"><span class="comment">    因为键盘控制电路的工作没有CPU快，需要循环判断是否准备好</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((io_in8(PORT_KEYSTA) &amp; KEYSTA_SEND_NOTREADY) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_keyboard</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化键盘控制电路 */</span></span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE);</span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYDAT, KBC_MODE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在之前的键盘程序上并没有对键盘进行初始化（感觉是默认初始化的），在初始化后就可以激活鼠标了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEYCMD_SENDTO_MOUSE 0xd4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOUSECMD_ENABLE 0xf4</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个函数与init_keyboard函数非常相似。 不同点仅在于写入的数据不同。 如果往键</span></span><br><span class="line"><span class="comment">盘控制电路发送指令0xd4， 下一个数据就会自动发送给鼠标。 我们根据这一特性来</span></span><br><span class="line"><span class="comment">发送激活鼠标的指令。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_mouse</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 激活鼠标 */</span></span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);</span><br><span class="line">    wait_KBC_sendready();</span><br><span class="line">    io_out8(PORT_KEYDAT, MOUSECMD_ENABLE);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* 顺利的话,键盘控制其会返送回ACK(0xfa)*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>激活过程很简单，只是对相应的端口输出数据即可，<strong>鼠标一旦激活就会返回发送一个0xfa的答复信息</strong></p>
<p>接下来就是从鼠标获取数据了，因为和键盘共用一个控制电路，所以获取数据的代码很类似，两者是通过中断号区分的。<strong>由于12号IRQ在从片上所以需要告知从片受理完成</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FIFO8</span> <span class="title">mousefifo</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inthandler2c</span><span class="params">(<span class="type">int</span> *esp)</span></span><br><span class="line"><span class="comment">/* 来自PS/2鼠标的中断 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">    io_out8(PIC1_OCW2, <span class="number">0x64</span>); <span class="comment">/* 通知PIC1 IRQ-12的受理已经完成 */</span></span><br><span class="line">    io_out8(PIC0_OCW2, <span class="number">0x62</span>); <span class="comment">/* 通知PIC0 IRQ-02的受理已经完成 */</span></span><br><span class="line">    data = io_in8(PORT_KEYDAT);</span><br><span class="line">    fifo8_put(&amp;mousefifo, data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鼠标信息由三个字节的数据构成，而且需要丢弃掉鼠标激活时发送的<code>0xfa</code>，其他便比较简单了，作者构建了一个鼠标缓冲，当接收到完整的三个字节后重新打印鼠标，实现鼠标的移动</p>
<p><strong>鼠标返回的数据主要由鼠标按键信息，垂直和水平偏移量构成，主要注意鼠标的坐标系和屏幕是上下颠倒的</strong></p>
<p>具体处理信息和鼠标三字节结构体字节分配在下面的链接中有很详细的说明</p>
<p>具体代码实现过程见：https://www.twblogs.net/a/5d737f19bd9eee5327ff7f64/zh-cn</p>
<p>但是没有处理画面叠加的问题，所以会有鼠标涂抹掉其他画面，第八天的<strong><em>通往32位模式之路</em></strong>放到下一次笔记</p>
<p>效果图如下：</p>
<p><img src="/assets/Note/30DaysOs/08_1.gif" alt="效果图" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>30天自制操作系统</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib 图像直接导出为 ndarray</title>
    <url>/2020/03/12/2020-03-12-Matplotlib-DirectlyOutput-Img/</url>
    <content><![CDATA[<h2 id="导出为ndarray格式图片">导出为ndarray格式图片</h2>
<p><em>matplotlib</em>
绘制的图线有自己的显示窗口，有时候希望在其他的<em>UI</em>设计中使用其绘制的图，比如<em>PyQt</em>，官方有一个支持QT的显示窗口类，但配置很麻烦，在这里记录一种简便的导出方式</p>
<p>主要思路为使用<em>matplotlib</em>的<code>print_png</code>函数将其图片数据导出到二进制流中，然后<em>numpy</em>从此二进制流中取出数据即可</p>
<span id="more"></span>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># matplotlib 绘制区</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">y = [<span class="number">1.2</span>, <span class="number">2.5</span>, <span class="number">4.5</span>, <span class="number">7.3</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure(<span class="string">&quot;Image&quot;</span>, frameon=<span class="literal">False</span>)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">canvas = fig.canvas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取二进制流</span></span><br><span class="line">buffer = io.BytesIO()</span><br><span class="line">canvas.print_png(buffer)</span><br><span class="line">data = buffer.getvalue()</span><br><span class="line">buffer.write(data)</span><br><span class="line">buffer.seek(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 获取数据</span></span><br><span class="line">file_bytes = np.asarray(<span class="built_in">bytearray</span>(buffer.read()), dtype=np.uint8)</span><br><span class="line"><span class="comment"># opencv 读取</span></span><br><span class="line">img = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)</span><br><span class="line"></span><br><span class="line">buffer.close()</span><br></pre></td></tr></table></figure>
<h2 id="设置matplotlib-borders便于鼠标信息处理坐标">设置matplotlib
borders便于鼠标信息处理（坐标）</h2>
<p>有时候仅导出为图片还不够，还需要实现用户的交互操作，在原生<em>matplotlib</em>中可以绑定事件以实现用户交互，但导出为图片时，就不得行了，但只需要获取坐标和图片宽高之间的关系，就可以简单的坐标转换一下就可以实现了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置显示的图像（不包括坐标轴，仅绘图区）显示在figure的位置</span></span><br><span class="line">left, bottom, right, top = <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.9</span>, <span class="number">0</span>,<span class="number">9</span></span><br><span class="line">plt.subplots_adjust(left=left, bottom=bottom, right=right, top=top)</span><br></pre></td></tr></table></figure>
<h3 id="坐标转换">坐标转换</h3>
<p>因为知道绘图区在整个图的相对位置，所以可以很好的处理</p>
<p>下面例子为<em>PyQt5</em>使用<em>widget</em>显示图片，<em>widget</em>到曲线坐标系的转换（曲线坐标系x,y均在[0,1]之间）</p>
<p><strong>即左上角为原点的屏幕坐标系到[0,1]坐标范围的图表坐标系的转换</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w, h = width(), height() <span class="comment"># 即为显示图片的容器大小</span></span><br><span class="line">plot_w, plot_h = (right - left)*w, (top - bottom)*h <span class="comment"># 绘图区大小</span></span><br><span class="line"><span class="comment"># 图标坐标到全图的像素坐标转换</span></span><br><span class="line">coord2bk = <span class="keyword">lambda</span> coord: [coord[<span class="number">0</span>]*plot_w + w*left, h*(<span class="number">1</span>-bottom) - coord[<span class="number">1</span>]*plot_h]</span><br><span class="line"><span class="comment"># 全图坐标到像素坐标的转换</span></span><br><span class="line">bk2coord = <span class="keyword">lambda</span> coord: [(coord[<span class="number">0</span>] - w*left) / plot_w ,<span class="number">1</span> - (coord[<span class="number">1</span>] - h*(<span class="number">1</span>-top)) / plot_h]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
        <tag>PyQT</tag>
      </tags>
  </entry>
  <entry>
    <title>画个简陋樱花树（简单递归）</title>
    <url>/2020/03/31/2020-03-31-Draw-CherryTree/</url>
    <content><![CDATA[<blockquote>
<p>看到网上很多代码绘制的樱花树，参见<a
href="https://blog.csdn.net/weixin_43943977/article/details/102691392">CSDN</a>，便想自己试试，但是画的有点丑</p>
</blockquote>
<span id="more"></span>
<h2 id="基本思路">基本思路</h2>
<p>其实就是一个“二叉树的遍历”的思路，使用递归不断的二叉，就可以了，这也算是分形图案了。但是简单的递归二叉，不掌握好长度、角度、粗细以及主干和枝干的变化就会很规整。所以慢慢调参吧。</p>
<p>这里采用的是给出每个参数的最大取值范围，然后设置一个缩小的函数，随着递归层数的提高，对应的参数越来越小，这个小的程度和范围就要自己把握了。</p>
<p>缩小函数可以参考：<span
class="math inline">\(\frac{1}{n},\frac{1}{\sqrt{n}}\)</span></p>
<h2 id="依赖">依赖</h2>
<p>这里的樱花树使用的是一个简单的<a href="https://easyx.cn/">C++图形库
easyx</a>，简单容易上手。</p>
<h2 id="演示">演示</h2>
<video src="/assets/ArticleVideo/2020/draw-cherrytree.mp4" preload="metadata" controlslist="nodownload" controls playsinline poster=""></video>
<h2 id="基础代码">基础代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;easyx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEE(x) cout &lt;&lt; #x &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED (RGB(240, 128, 128))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE (RGB(255, 255, 255))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BROWN (RGB(160, 82, 45))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与主干角度的偏移角度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> angle_min = <span class="number">18</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> angle_max = <span class="number">28</span>;</span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> length_min = <span class="number">60</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> length_max = <span class="number">90</span>;</span><br><span class="line"><span class="comment">// 宽度</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> thick = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制区大小</span></span><br><span class="line"><span class="type">int</span> width = <span class="number">800</span>, height = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一条线</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawline</span><span class="params">(Point st, Point ed)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">line</span>(st.first, st.second, ed.first, ed.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生范围内的随机数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand_range</span><span class="params">(<span class="type">int</span> st, <span class="type">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st + <span class="built_in">rand</span>() % (ed - st);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给点原点 相对于水平的角度 长度 返回处理后的节点</span></span><br><span class="line"><span class="function">Point <span class="title">getPointFromAngle</span><span class="params">(Point src, <span class="type">float</span> angle, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    angle = <span class="number">3.14</span>/<span class="number">180.0</span> * angle;</span><br><span class="line">    <span class="keyword">return</span> &#123; src.first+length*<span class="built_in">cos</span>(angle), src.second-length*<span class="built_in">sin</span>(angle) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归画叉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_bifurcation</span><span class="params">(Point p, <span class="type">float</span> angle, <span class="type">int</span> layer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结束层</span></span><br><span class="line">    <span class="keyword">if</span> (layer == <span class="number">13</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 偏移角</span></span><br><span class="line">    <span class="type">float</span> delta = <span class="built_in">rand_range</span>(angle_min, angle_max);</span><br><span class="line">    <span class="comment">// 收缩 使用根号</span></span><br><span class="line">    <span class="type">float</span> shrink = <span class="built_in">pow</span>(layer, <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">// 便宜的角度越来越小</span></span><br><span class="line">    <span class="type">float</span> left_angle = angle + delta/shrink;</span><br><span class="line">    <span class="comment">// 右分支的角度确定</span></span><br><span class="line">    <span class="type">float</span> right_angle = left_angle - <span class="number">2.4</span>*delta/shrink;</span><br><span class="line">    <span class="comment">// 随机长度</span></span><br><span class="line">    <span class="type">int</span> length_left = <span class="built_in">rand_range</span>(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="type">int</span> length_right = <span class="built_in">rand_range</span>(length_min / shrink, length_max / shrink);</span><br><span class="line">    <span class="comment">// 获取下一个分支点</span></span><br><span class="line">    Point left = <span class="built_in">getPointFromAngle</span>(p, left_angle, length_left);</span><br><span class="line">    Point right = <span class="built_in">getPointFromAngle</span>(p, right_angle, length_right);</span><br><span class="line">    <span class="comment">// 末端绘制红白相间的花瓣</span></span><br><span class="line">    <span class="type">int</span> type = <span class="built_in">rand</span>() % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">setlinecolor</span>(RED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">setlinecolor</span>(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">setlinecolor</span>(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置厚度</span></span><br><span class="line">    <span class="built_in">setlinestyle</span>(PS_SOLID , thick/layer);</span><br><span class="line">    <span class="built_in">drawline</span>(p, left);</span><br><span class="line">    <span class="comment">// 递归左分支</span></span><br><span class="line">    <span class="built_in">draw_bifurcation</span>(left, left_angle, layer + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setlinestyle</span>(PS_SOLID, thick / layer);</span><br><span class="line">    <span class="keyword">if</span> (layer &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">setlinecolor</span>(WHITE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">setlinecolor</span>(RED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">setlinecolor</span>(BROWN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态效果</span></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">drawline</span>(p, right);</span><br><span class="line">    <span class="comment">// 递归右分支</span></span><br><span class="line">    <span class="built_in">draw_bifurcation</span>(right, right_angle, layer + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机绘制地面的花瓣</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw_ground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = width * <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = width * <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> up = height - <span class="number">60</span>;</span><br><span class="line">    <span class="type">int</span> down = height;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">setlinecolor</span>(RED);</span><br><span class="line">    <span class="built_in">setlinestyle</span>(PS_SOLID, <span class="number">3</span>);</span><br><span class="line">    <span class="type">int</span> x, y, angle;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        x = <span class="built_in">rand_range</span>(left, right);</span><br><span class="line">        y = <span class="built_in">rand_range</span>(up, down);</span><br><span class="line">        angle = <span class="built_in">rand_range</span>(<span class="number">0</span>, <span class="number">360</span>);</span><br><span class="line">        Point ed = <span class="built_in">getPointFromAngle</span>(&#123; x, y &#125;, angle, length);</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">drawline</span>(&#123; x, y &#125;, ed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">initgraph</span>(width, height);</span><br><span class="line">    <span class="comment">// 设置背景色</span></span><br><span class="line">    <span class="built_in">setbkcolor</span>(<span class="built_in">RGB</span>(<span class="number">241</span>, <span class="number">215</span>, <span class="number">118</span>));</span><br><span class="line">    <span class="built_in">cleardevice</span>();</span><br><span class="line">    <span class="comment">// 绘制主干</span></span><br><span class="line">    <span class="built_in">setlinecolor</span>(BROWN);</span><br><span class="line">    <span class="built_in">setlinestyle</span>(PS_SOLID | PS_ENDCAP_SQUARE, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">line</span>(width/<span class="number">2</span>, height<span class="number">-110</span>, width/<span class="number">2</span>, height<span class="number">-20</span>);</span><br><span class="line">    <span class="comment">// 递归绘制</span></span><br><span class="line">    <span class="built_in">draw_bifurcation</span>(&#123; width/<span class="number">2</span>, height<span class="number">-110</span> &#125;, <span class="number">90.0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 绘制掉落花瓣的地面</span></span><br><span class="line">    <span class="built_in">draw_ground</span>();</span><br><span class="line">    _getch();</span><br><span class="line">    <span class="built_in">closegraph</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>埃氏筛 &amp; 欧拉筛</title>
    <url>/2020/03/24/2020-03-24-prime-sieve/</url>
    <content><![CDATA[<blockquote>
<p>素数的定义：指在大于1的自然数中，除了1和该数自身外，无法被其他自然数整除的数。大于1的自然数若不是素数，则称之为合数。</p>
</blockquote>
<span id="more"></span>
<h2 id="试除法">试除法</h2>
<p>直接使用定义解决的方案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= <span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从2遍历到<span class="math inline">\(\sqrt n\)</span>
因为之后的就没有必要了，一个和数拆分成两个因子必定是在<span
class="math inline">\(\sqrt
n\)</span>的两侧，是对称的，所以只需要遍历一边就可以了。</p>
<h2 id="埃氏筛">埃氏筛</h2>
<p>上面的算法是判断一个数是否是素数，但是对获取某个范围的素数开销非常大。埃氏筛（素数筛）就是求某个范围素数的算法。</p>
<p>原理很简单，合数必定可以拆分为一系列素数的积，即<strong>某个素数的任意倍数都是合数</strong>。</p>
<p>代码也很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// maxn 为范围的上届</span></span><br><span class="line"><span class="type">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i*i;j &lt; maxn;j += i) &#123;</span><br><span class="line">            is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度为：<span class="math inline">\(n\log \log n\)</span></p>
<h2 id="欧拉筛">欧拉筛</h2>
<p>埃氏筛很明显的一个缺点就是一个合数会被重复筛掉（被每一个素数因子筛一次），增加复杂度。欧拉筛就是在其上的改进，使每一个合数只被它的最小因子筛掉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> is_prime[maxn] = &#123;<span class="literal">true</span>&#125;; <span class="comment">// 初始化为全部 true</span></span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> prime_numbers[maxn];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; maxn;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(is_prime[i]) &#123;</span><br><span class="line">        prime_numbers[cnt++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环中&lt;maxn没有也没关系</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;i*prime_numbers[j] &lt; maxn;j++) &#123;</span><br><span class="line">        is_prime[i*prime_numbers[j]] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(i % prime_numbers[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧拉筛复杂度为n（将空循环不视作开销），每个合数仅被筛一次。</p>
<p>核心就在于<code>i % prime_numbers[j] == 0</code>，当这个条件成立的时候跳出循环，不继续往下筛，下面的都是已经或者未来要被筛掉的。</p>
<p>条件成立时意味着 <span class="math inline">\(i = prime\_numbers[j]
\times K\)</span>，而继续循环下去可以得到<span
class="math inline">\(i*prime\_numbers[j+1]\)</span>也就是,<span
class="math inline">\(prime\_numbers[j]\times prime\_numbers[j+1] \times
K = prime\_numbers[j] \times Q\)</span>，也就是说它会被<span
class="math inline">\(prime\_numbers[j]\)</span>乘以另外一个数给筛掉，之后的循环也就没必要进行了。也保证了，每个合数都只被它的最小因子筛掉。</p>
<p>令<span class="math inline">\(N = K \times Q \times ...\)</span> K
Q为两个素数且<span class="math inline">\(Q \gt
K\)</span>，假设N可以被Q筛掉，也就是$N = Q M， M= K...
$这里的M就是上面循环中的i，它是不可能使用QM筛掉的，因为<code>M%K == 0</code>，就跳出循环之外了。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统精髓与设计原理 第8版 阅读笔记</title>
    <url>/2020/02/28/2020-02-28-Operating-System-Internals-and-Design-Principles-8th-Note/</url>
    <content><![CDATA[<blockquote>
<p>Github地址：<a
href="https://github.com/Weijun-Lin/Notes/blob/master/Operating-System-Internals-and-Design-Principles-8th/note.md">笔记-操作系统精髓与设计原理第8版</a></p>
</blockquote>
<p>操作系统是管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。——
维基百科</p>
<blockquote>
<p>前几章为引言部分 略</p>
</blockquote>
<h2 id="第二部分-进程">第二部分 进程</h2>
<hr />
<h3 id="第三章-进程描述和控制">第三章 进程描述和控制</h3>
<hr />
<h4 id="进程的几个定义">1. 进程的几个定义</h4>
<ul>
<li>一个正在执行的<strong>程序</strong></li>
<li>一个正在<strong>计算机</strong>上执行的程序实例</li>
<li>能分配给<strong>处理器</strong>并由处理器执行的实体</li>
<li>由一组执行的<strong>指令</strong>，一个<strong>当前状态</strong>和一组相关的<strong>系统资源</strong>表征的活动单元</li>
</ul>
<h4 id="基本元素">2. 基本元素</h4>
<p>程序代码 + 数据集</p>
<h4 id="进程控制块-pcb">3. 进程控制块 （PCB）</h4>
<ul>
<li>标识符</li>
<li>状态：新建，运行，就绪，挂起，阻塞，退出</li>
<li>优先级</li>
<li>程序计数器： 保存下一条指令的地址</li>
<li>内存指针：代码 / 数据 / 其它进程的指针</li>
<li>上下文数据：处理器执行时寄存器里的值</li>
<li>I/O 状态信息：I/O 请求； I/O 设备； 文件列表</li>
<li>记账信息：处理器时间，记账号</li>
</ul>
<h4 id="进程状态">4. 进程状态</h4>
<p><strong>轨迹</strong>：进程执行的指令序列</p>
<h5 id="两状态模型">两状态模型</h5>
<p>非运行态 <span class="math inline">\(\Leftrightarrow\)</span>
运行态</p>
<h5 id="五状态模型">五状态模型</h5>
<ul>
<li>运行态：进程正在执行，假设为一个计算机，那么一次最多只有一个进程处于此状态</li>
<li>就绪态：进程做好了准备，随时可以处于运行态</li>
<li>阻塞态：在发生某些事件前不能执行，如 I/O</li>
<li>新建态：已创建 PCB 但还未加载到内存中的进程</li>
<li>退出态：操作系统从可执行进程组释放出的进程</li>
</ul>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/5_states_module.jpg" /></p>
<h4 id="进程的挂起">5. 进程的挂起</h4>
<p><strong>原因</strong>：当所有进程都处于阻塞态时，处理器处于休闲状态。此时将某个进程的一部分或者全部移入磁盘，然后从挂起队列加载一个新进程，放入内存中运行</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/suspended_state.jpg" /></p>
<h5 id="进程挂起的原因">进程挂起的原因</h5>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/suspended_reason.jpg" /></p>
<h4 id="进程创建和终止">6. 进程创建和终止</h4>
<ul>
<li><p>进程创建的原因：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/creat_process_reason.jpg" /></p></li>
<li><p>进程终止的原因：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/end_process_reason.jpg" /></p></li>
</ul>
<h4 id="操作系统控制结构">7. 操作系统控制结构</h4>
<ul>
<li>内存表：跟踪内存和外（虚）存（交换机制）
<ul>
<li>分配给进程的内存</li>
<li>分配给进程的外存</li>
<li>内存块或虚存块的任何保护属性</li>
<li>管理虚存所需要的任何信息</li>
</ul></li>
<li>I/O 表：管理 I/O 设备和通道</li>
<li>文件表：文件管理：是否存在，位置等信息</li>
<li>进程表：内存，I/O， 文件是代表进程而被管理的</li>
</ul>
<h4 id="进程控制结构">8. 进程控制结构</h4>
<p>进程映像：程序 + 数据 + 栈 + 属性</p>
<h5 id="pcb-进程控制块">PCB 进程控制块</h5>
<ul>
<li><p>进程标识信息：存储在PCB中的数字标识符,包括: 进程 ID，父进程
ID，用户 ID</p></li>
<li><p>进程状态信息（处理器状态信息）：存储所有的程序状态字（PSW）</p></li>
<li><p>进程控制信息：操作系统协调各种活动进程的额外信息</p></li>
</ul>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/PCB.jpg" /></p>
<h5 id="pcb-的作用">PCB 的作用</h5>
<blockquote>
<p>PCB 是操作系统中最重要的数据结构，包含操作系统所需进程的全部信息</p>
<p>PCB 集合定义了 OS 的状态</p>
</blockquote>
<p>如何在发生错误和变化时，保护 PCB，具体表现为两个问题：</p>
<ul>
<li>一个例程（如中断处理程序）中的错误可能会破坏进程控制块，进而破坏系统对受影响进程的管理能力</li>
<li>进程控制块结构或语义中的设计变化可能会影响到操作系统中的许多模块</li>
</ul>
<h4 id="进程控制">9. 进程控制</h4>
<h5 id="执行模式">执行模式</h5>
<p>特权模式称为系统模式，控制模式或者<strong>内核模式</strong>，非特权模式又称为用户模式</p>
<p><strong>原因</strong>：保护操作系统和重要的操作系统表
不受用户程序的干扰</p>
<p><strong>ELSE</strong>：PCB
中有指示执行模式的位，因事件变化而变化，当用户调用OS服务或中断触发系统例程时，执行模式变为内核模式，返回到用户进程时变为用户模式</p>
<h5 id="内核的典型功能">内核的典型功能</h5>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/OS_kernel_function.jpg" /></p>
<h4 id="进程创建-具体过程">10. 进程创建 具体过程</h4>
<ol type="1">
<li>为新进程分配一个唯一的进程标识符</li>
<li>为进程分配空间</li>
<li>初始化 PCB</li>
<li>设置正确的链接：放入新建/就绪挂起 链表中</li>
<li>创建或扩充其它数据结构：记账文件</li>
</ol>
<h4 id="进程切换">11. 进程切换</h4>
<p>#####　何时切换进程</p>
<blockquote>
<p>可在OS从当前正在运行的进程获得控制器的任何时刻发生</p>
</blockquote>
<ul>
<li>系统中断： 时钟中断（超过运行时间片）；I/O 中断；内存失效</li>
<li>陷阱：处理一个错误和一个异常条件</li>
<li>系统调用：显示请求，调用操作系统函数</li>
</ul>
<h5 id="模式切换">模式切换</h5>
<p>出现中断时，处理器将：</p>
<ul>
<li>将从程序计数器置为中断处理程序的开始地址</li>
<li>从用户模式切换到内核模式，以便中断处理代码包含特权指令</li>
<li>保存已中断例程的上下文</li>
</ul>
<h5 id="进程切换-1">进程切换</h5>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/process_change.jpg" /></p>
<h4 id="操作系统的执行">12. 操作系统的执行</h4>
<blockquote>
<p>第二章指出操作系统的两个特殊事实：</p>
<ul>
<li>OS 和普通软件以相同的方式运行，也是一个程序</li>
<li>OS 会频繁的释放控制权，并依赖于处理器来恢复控制权</li>
</ul>
</blockquote>
<h5 id="无进程内核">无进程内核</h5>
<p>在所有进程外部执行操作系统内核，进程概念只适用于用户程序，操作系统则是则是在特权模式下单独运行的实体</p>
<h5 id="在用户进程内运行">在用户进程内运行</h5>
<p>操作系统是用户调用的一组例程，在用户进程的环境中执行并实现各种功能。进程映像不仅包括自己的程序，数据，栈还包括<strong>内核程序</strong>的程序，数据，和栈区域。操作系统代码和数据位于共享地址空间中，并被所有用户进程所共享。只需要在同一进程中切换模式，而不需要切换进程</p>
<h5 id="基于进程的操作系统">基于进程的操作系统</h5>
<p>把操作系统作为一组系统进程来实现</p>
<p>优点：</p>
<ol type="1">
<li>鼓励模块化操作系统设计原理，使模块间接口最小且最简单</li>
<li>有些非关键系统功能可简单的用独立的进程来实现（例如监视各种资源和状态的程序）</li>
<li>在多处理器和多机环境中很有用</li>
</ol>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_3/OS_and_userprocess.jpg" /></p>
<h3 id="第四章-线程">第四章 线程</h3>
<hr />
<h4 id="进程和线程">1. 进程和线程</h4>
<h5 id="进程特点">进程特点</h5>
<ul>
<li>资源所有权：进程包括存放进程映像的虚拟地址空间</li>
<li>调度/执行：进程具有执行态和优先级，是可被 OS 调度和执行的实体</li>
</ul>
<blockquote>
<p>这两个特点是独立的，为了区分这两个特点，通常将分派的单位称为线程（轻量级进程
LWP ）</p>
<p>而将资源所有权的单位称为进程（任务）</p>
</blockquote>
<h5 id="多线程">多线程</h5>
<blockquote>
<p>指OS在单个进程内支持多个并发执行路径的能力</p>
</blockquote>
<p>在多线程环境中，进程定义为资源分配单元和一个保护单元，与进程相关联的有：</p>
<ul>
<li>容纳进程映像的虚拟地址空间</li>
<li>对处理器，其它进程，文件，I/O 的受保护访问</li>
</ul>
<p>每个线程都有：</p>
<ul>
<li>一个线程的执行状态</li>
<li>线程上下文，线程可视为进程内运行的一个独立程序计数器</li>
<li>一个执行栈</li>
<li>局部变量的静态存储空间</li>
<li>与其它线程共享的内存和资源的访问</li>
</ul>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_4/thread_module.jpg" /></p>
<p>使用线程的几个例子：</p>
<ul>
<li>前台和后台工作</li>
<li>异步处理</li>
<li>执行速度</li>
<li>模块化程序结构</li>
</ul>
<p><strong>线程的优点</strong></p>
<blockquote>
<p><strong>Why</strong> :
因为线程共享一个地址，内存，文件空间，ULT中不用切换到内核，进程切换需要内核</p>
</blockquote>
<ul>
<li>创建线程的时间少于创建进程的时间</li>
<li>终止线程的时间少于终止进程的时间</li>
<li>同一个内线程切换时间少于进程间切换的时间</li>
<li>线程提高了不同执行程序间通信的效率</li>
</ul>
<h5 id="线程的功能">线程的功能</h5>
<p>线程状态：就绪态，运行态，阻塞态</p>
<p>基本操作：派生，阻塞，解除阻塞，结束</p>
<p>线程同步：同步线程的活动是它们互不干扰且不破坏数据结构，如两个线程向一个链表加入元素，则可能会丢失</p>
<h4 id="线程分类">2. 线程分类</h4>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_4/thread_type.jpg" /></p>
<h5 id="用户级ult">用户级（ULT）</h5>
<p>管理线程的所有工作都由应用程序完成，==内核意识不到线程的存在==（线程在内核看来和进程是一致的）。任何应用程序都可以设计成多线程程序。线程库提供了所有关于线程的操作</p>
<p><strong>ULT相较于KLT的优点</strong>：</p>
<ul>
<li>所有线程都在一个进程的用户地址空间中，线程切换不需要内核模式特权，因此不需要切换到内核状态，节省了两次状态转换，用户到内核和内核到用户</li>
<li>调度因程序的不同而不同</li>
<li>ULT 可以在任何操作系统中运行</li>
</ul>
<p><strong>ULT 相较于 KLT 的缺点</strong>：</p>
<ul>
<li>ULT
执行一个系统调用的话，不仅阻塞当前线程，也会阻塞进程内的所有线程</li>
<li>==多线程应用程序不能利用多处理技术==，这里线程对操作系统是不可见的，内核一次把一个进程分配给处理器，这样一个进程内只能运行一次一个线程，相当于在一个进程内实现了多道程序设计</li>
</ul>
<h5 id="内核级线程klt">内核级线程（KLT）</h5>
<p>管理线程的所有操作由内核完成，应用级只有一个到内核线程实施的应用编程接口（API）</p>
<p><strong>KLT 的优点：</strong></p>
<ul>
<li>内核可以把进程中的多个线程调度到多个处理器中</li>
<li>进程的一个线程阻塞时，不影响其它线程的调度</li>
<li>内核例程也可以是多线程的</li>
</ul>
<p><strong>KLT 的缺点：</strong></p>
<ul>
<li>线程转换时 需要切换到内核状态</li>
</ul>
<h5 id="混合">混合</h5>
<blockquote>
<p>结合两者优点</p>
</blockquote>
<h4 id="多核和多线程">3、多核和多线程</h4>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_4/Amdahl.jpg" /></p>
<blockquote>
<p>并不是核越多越好，管理起来越麻烦，会有更多多余的开销</p>
</blockquote>
<p><strong>影响多核系统上软件性能的因素</strong></p>
<ul>
<li>核的数量</li>
<li>串行代码比例</li>
<li>多处理器任务调度和通信以及高速缓存一致性带来的额外开销</li>
</ul>
<h3 id="第五章-并发性互斥和同步">第五章 并发性：互斥和同步</h3>
<hr />
<p>操作系统的核心问题是进程和线程的管理：</p>
<ul>
<li>多道程序设计技术：管理单处理器中的多个进程</li>
<li>多处理器技术：管理多处理器中的多个进程</li>
<li>分布式处理器技术：管理多台分布式计算机中多个进程的执行（集群）</li>
</ul>
<p><strong><em>并发是所有问题的基础，也是操作系统设计的基础（设计问题：进程通信，资源共享和竞争）</em></strong></p>
<p>出现的环境：</p>
<ul>
<li>多应用程序：程序间动态共享处理器时间</li>
<li>结构化应用程序：。。。</li>
<li>操作系统结构：。。。</li>
</ul>
<h4 id="并发的原理">1、并发的原理</h4>
<h5 id="并发处理的问题难点">并发处理的问题（难点)</h5>
<ul>
<li>全局资源的共享充满了危险</li>
<li>OS很难对资源进行最优化分配</li>
<li>定位程序设计错误非常困难</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zvoid <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">    chin = getchar();</span><br><span class="line">    chout = chin;</span><br><span class="line">    <span class="built_in">putchar</span>(chout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个打印字符的程序很容易发生数据的丢失，出现这种问题的原因是中断可能在进程的任何地方发生，解决方案是控制对共享资源的访问</p>
<h5 id="竞争条件">竞争条件</h5>
<p>竞争条件发生在多个进程或线程读写数据时，其最终结果取决于进程的指令执行顺序</p>
<h5 id="进程的交互">进程的交互</h5>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/interfaceOfProcess.jpg" /></p>
<p>有几个基本概念：</p>
<p><strong><em>临界资源</em></strong>
：就是上面谈到的一个不可分享的资源</p>
<p><strong><em>临界区</em></strong>：使用这一部分资源的程序称为程序的临界区</p>
<p><strong><em>死锁</em></strong>：两个进程互相控制两个资源，但又还需要对方持有的资源才可以继续工作，这样就产生了死锁（两个进程都不能继续工作）</p>
<p><strong><em>饥饿</em></strong>：有三个进程 ABC
，每个进程都需要访问资源 R，资源被 AC 交替访问，却始终没有分配给 B 这样
B 就处于饥饿状态</p>
<h5 id="互斥的要求">互斥的要求</h5>
<blockquote>
<p>互斥：简单来说，就是两个或多个进程需要访问一个不可分享的资源的保护机制</p>
</blockquote>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/demandOfMutex.jpg" /></p>
<h4 id="互斥硬件的支持">2、互斥：硬件的支持</h4>
<h5 id="中断禁用">中断禁用</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">/* 禁用中断 */</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    <span class="comment">/* 启用中断 */</span></span><br><span class="line">    <span class="comment">/* 其余部分 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>临界区不能被中断，所以可以保证互斥，为了保证互斥只需要保证一个进程在访问资源的时候不被中断。</p>
<p>但是，这种方法的代价非常高。由于处理器被限制得只能交替执行程序，因此执行的效率会明显降低。而且它不能用于多处理器体系结构。当一个计算机系统含有多个处理器时，通常可能有多个进程同时执行。这种情况下，中断不能保证互斥。因为在多处理器配置中，<strong><em>几个处理器对内存的访问不存在主从关系，处理器之间的行为是无关的，表现出一种对等的关系，处理器之间没有支持互斥的中断机制。</em></strong></p>
<h5 id="专用机器指令">专用机器指令</h5>
<p>在硬件级别上，对存储单元的访问排斥对相同单元的其它访问，因此处理器的设计人员提出了一些机器指令，用与保证两个动作的原子性（不能被中断的指令），<strong>在这个指令执行的过程中，任何其它指令访问内存都将被总之，而且这些动作在一个指令周期中完成</strong></p>
<ul>
<li><strong>比较和交换指令：</strong></li>
</ul>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compare_and_swap</span><span class="params">(<span class="type">int</span> *word, <span class="type">int</span> testval, <span class="type">int</span> newval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> oldval;</span><br><span class="line">    oldval = *word;</span><br><span class="line">    <span class="keyword">if</span>(oldval == testval) *word = newval;</span><br><span class="line">    <span class="keyword">return</span> oldval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一个测试值检查一个内存单元，如果内存单元的当前值是
<code>testval</code> ，就使用 <code>newval</code>
取代该值，否则保持不变，并返回旧内存值。因此如果返回值和测试值相同，表示内存单元已经被更新，整个过程按原子操作执行，不接受中断。这个过程的另一个版本为返回
<code>bool</code> 值，判断是否完成交换</p>
<ul>
<li><strong>exchange指令</strong></li>
</ul>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span> *<span class="keyword">register</span>, <span class="type">int</span> *memory)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *memory;</span><br><span class="line">    *memory = *<span class="keyword">register</span>;</span><br><span class="line">    *<span class="keyword">register</span> = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/mutexInHardware.jpg" /></p>
<p><strong>忙等待（自旋等待）</strong>：进程在得到临界区访问权之前，它只能继续执行测试变量的指令来得到访问权，除此之外不能做任何事情</p>
<p>对于上图 <strong>a</strong> ,唯一可以进入临界区的进程是发现 bolt
为0的那个进程，并把bolt置为1在它访问临界区的时候，此时其它的进程都处于忙等待中，访问结束后继续将
bolt 置为 0，此时下一个可以进入临界区的进程就是在这之后最早执行
<code>compare&amp;swap</code> 指令的进程</p>
<p>对于上图<strong>b</strong> ,工作原理和 <strong>a</strong>
几乎一致。由于变量初始化的方式和交换算法的本质，下面的表达式恒成立：</p>
<p><span class="math display">\[ bolt + \sum_ikey_i = n \]</span></p>
<p>若 <code>bolt = 0</code> ，则没有任何一个进程在它的临界区中，若
<code>bolt = 1</code> ，则只有一个进程在临界区中，且为 <strong><em>key为
0</em></strong> 的那个进程</p>
<h5 id="机器指令方法的特点">机器指令方法的特点</h5>
<p>有如下的优点：</p>
<ul>
<li>适用于单处理器或共享内存的多处理器上的任意数量的进程</li>
<li>简单且易于证明</li>
<li>可以用支持多个临界区，每个临界区可以用它自己的变量定义</li>
</ul>
<p>但也有一些严重的缺点：</p>
<ul>
<li>使用了忙等待：在一个进程在等待进入临界区时，它依然在消耗处理器时间</li>
<li>可能饥饿：选择哪个等待进程时任意的，因此有些进程会被无限拒绝进入</li>
<li>可能死锁：考虑单处理器下的情况：进程P1执行专用指令（上面的两个）并进入临界区，然后P1被中断并交给更高优先级的P2执行，P2由于互斥机制讲被拒绝访问，但是由于P1优先级低，它也永远不会被调度执行</li>
</ul>
<h4 id="信号量">3、信号量</h4>
<blockquote>
<p><a href="https://www.cnblogs.com/jhcelue/p/7080146.html"
class="uri">https://www.cnblogs.com/jhcelue/p/7080146.html</a></p>
</blockquote>
<p>讨论的是提供并发性的操作系统和设计语言的机制</p>
<p>常用的并发机制：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/concurrencyWays.jpg" /></p>
<p>基本原理如下：</p>
<p>两个或多个进程可以通过简单的信号进行合作。强迫一个进程在某个位置停止，直到它接受到一个特定的信号，其中使用了一个称为<strong>信号量</strong>的特殊变量。通过信号量
s 传送信号，进程须执行原语 <code>semSignal(s)</code> 要通过信号量 s
接受信号需要执行原语 <code>semWait(s)</code>
若相应信号未发送则阻塞进程，知道发送完为止</p>
<p>为达到预期效果，可把信号量视为一个值为整数的变量，定义了三个操作：</p>
<ul>
<li>一个信号量可以初始化为非负数</li>
<li><code>semWait</code> 使信号量减 1，若值变成负数，则阻塞执行
<code>semWait</code> 的进程，否则继续执行</li>
<li><code>semSignal</code> 操作使信号量加 1 ，若值小于等于 0 ，则被
<code>semWait</code> 操作阻塞的进程解除阻塞</li>
</ul>
<p>信号量为正数时，代表发出 <code>semWait</code>
后可以继续执行的进程数量，信号量为负数时，每个 <code>semSignal</code>
操作都会将等待进程中的一个进程解除阻塞</p>
<p>对于信号量有三个重要结论：</p>
<ul>
<li>通常，在进程对信号量-1之前，无法提前知道该信号量是否会被阻塞</li>
<li>当进程对信号量+1后，会唤醒另一个进程，两个进程继续并发运行。而在一个单处理器系统中，无法知道哪一个进程会继续运行</li>
<li>向信号量发出信号后，不需要知道是否有另外一个进程在等待，被解除阻塞的进程数要么没有，要么为1</li>
</ul>
<p>信号量原语的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">semWait</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="comment">// --之后小于0 说明原来 count &lt;= 0</span></span><br><span class="line">    <span class="keyword">if</span> (s.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 把当前进程插入队列</span></span><br><span class="line">        <span class="comment">// 阻塞当前进程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">semSignal</span><span class="params">(semaphore s)</span> </span><br><span class="line">&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="comment">// ++之后小于等于0 说明原来 count &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (s.count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 把进程P从队列移除</span></span><br><span class="line">        <span class="comment">// 把进程P插入就绪队列</span></span><br><span class="line">        <span class="comment">// 这个进程P是未知的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二元信号量的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>zero, one&#125; value;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">semWaitB</span><span class="params">(binary_semaphore)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.value == one) s.value = zero;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入阻塞队列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> semSignalB(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">queue</span> is empty()) s.value = one;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将进程P解除阻塞</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理论上二元信号量更易于实现，且可以证明==与普通信号具有同样的表达能力==，非二元信号量也称作<strong>计数信号量</strong>或<strong>一般信号量</strong></p>
</blockquote>
<p>与二元信号量有关的还有<strong><em>互斥锁（Mutex）</em></strong>。互斥是一个编程标志位，用来获取和释放一个对象。可以对一个资源进行<strong>加锁</strong>和<strong>解锁</strong>操作，即为置0和置1，可以由互斥量和二元信号量实现，二者区别在于，<strong>互斥量解锁和加锁的进程必须是同一个进程，二元信号量进行加锁操作，而由另一个进程解锁</strong></p>
<ul>
<li>强信号量：进程按照FIFO策略将进程从队列溢移除的信号量</li>
<li>弱信号量：没有规定队列移除顺序的信号量</li>
</ul>
<p>可以理解==强信号量不会导致饥饿，而弱信号量可能导致饥饿==</p>
<p><strong>信号量机制示例</strong></p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/semaphoreExample.jpg" /></p>
<h5 id="互斥">互斥</h5>
<p>使用信号量的互斥：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="comment">/*进程数*/</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWait(s);</span><br><span class="line">        <span class="comment">//临界区</span></span><br><span class="line">        semSignal(s);</span><br><span class="line">        <span class="comment">//Else</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    parbegin(P(<span class="number">1</span>), P(<span class="number">2</span>), ..., P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/explainAboutMutexInSemaphore.jpg" /></p>
<h5 id="生产者消费者问题">生产者消费者问题</h5>
<p><strong><em>问题描述</em></strong>：有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；有一个消费者从缓冲区中取数据，每次取一项，任何时候只有一个主体访问缓冲区。问题是要确保：当缓冲区已满时，生产者不会继续向其中添加数据，当缓冲区为空时，消费者不会从中移走数据</p>
<p>首先假设缓冲区是无限的，且是一个线性数组，可以使用二元信号量和计数信号量实现</p>
<p><strong>二元信号量错误的方法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;	<span class="comment">// 缓冲区剩余生产量</span></span><br><span class="line"><span class="comment">// delay：用于解决空的时候消费者不移走数据</span></span><br><span class="line"><span class="comment">// s：用于互斥,控制资源访问</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(s);</span><br><span class="line">        append(); <span class="comment">// 正式将数据加入缓冲区</span></span><br><span class="line">        n++;</span><br><span class="line">        <span class="comment">// 告诉消费者缓冲区已经有数据了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) semSignal(delay);</span><br><span class="line">        semSignal(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    semWait(delay);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(s);</span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="comment">// 消费完之后阻塞当前进程 因为在此循环中delay不会为1</span></span><br><span class="line">        <span class="comment">// 如果此处发生中断n的值会被篡改 这个判断也就没有什么意义了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) semWait(delay);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer,consumer);	<span class="comment">//创建线程/进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么是错误的，可能造成消费完之后继续取</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/wrongInProducer_Consumer.jpg" /></p>
<p>也就是==在消费者消费之后已经不属于互斥资源保护区，发生中断之后不能保护原有变量的值==，正如上图第10行，本来应该阻塞消费者进程，但是由于中断使
n++，并且有重新将 delay 置1，而后恢复消费者进程消费完缓冲区之后 delay
信号仍然为1所以，此时缓冲区为空但是并不会阻塞进程，所以还会继续从已经为空的缓冲区拿东西（也就是
delay 信号并不能匹配了）</p>
<p><strong>二元信号量正确的方法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;	<span class="comment">// 缓冲区剩余生产量</span></span><br><span class="line"><span class="comment">// delay：用于解决空的时候消费者不移走数据</span></span><br><span class="line"><span class="comment">// s：用于互斥,控制资源访问</span></span><br><span class="line">binary_semaphore s = <span class="number">1</span>, delay = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWait(S);</span><br><span class="line">        append(); <span class="comment">// 正式将数据加入缓冲区</span></span><br><span class="line">        n++;</span><br><span class="line">        <span class="comment">// 告诉消费者缓冲区已经有数据了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) semSignal(delay);</span><br><span class="line">        semSignal(S);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    semWait(delay);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(s);</span><br><span class="line">        take();</span><br><span class="line">        n--;</span><br><span class="line">        <span class="comment">// 保护变量m这样就不怕之前的n被修改，m属于此进程的不会被篡改</span></span><br><span class="line">        m = n;</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">        <span class="comment">// 消费完之后阻塞当前进程 因为在此循环中delay不会为1</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) semWait(delay);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    parbegin(producer,consumer);	<span class="comment">//创建线程/进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一般信号量（计数信号量），可得到一种更好的解决方法，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接把n和信号量联系起来</span></span><br><span class="line">semephore n = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semWiat(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        consume();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>....</span><br></pre></td></tr></table></figure>
<p>如果是有限缓冲区的话，只需要对缓冲区大小也设置信号量保护即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> sizeofBuffer = <span class="comment">//缓冲区大小</span></span><br><span class="line">semephore n = <span class="number">0</span>, s = <span class="number">1</span>, e = sizeofBuffer;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        produce();</span><br><span class="line">        semwait(e);	<span class="comment">// e表示缓冲区中空的个数</span></span><br><span class="line">        semWiat(s);</span><br><span class="line">        append();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        semWiat(n);</span><br><span class="line">        semWait(s);</span><br><span class="line">        take();</span><br><span class="line">        semSignal(s);</span><br><span class="line">        semSignal(e);	<span class="comment">// 已经消耗一个 有空位了</span></span><br><span class="line">        consume();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>....</span><br></pre></td></tr></table></figure>
<h5 id="信号量的实现">信号量的实现</h5>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/implementOfSemaphore.jpg" /></p>
<p>即使用 <code>s.flag</code> 的互斥原语实现了信号量操作的原子性</p>
<h4 id="管程">4、管程</h4>
<blockquote>
<p>管程是一种程序设计语言结构（ C/C++ 语言没有 JAVA 支持）</p>
<p>它提供的功能与信号量相同但是更易于控制</p>
</blockquote>
<h5 id="管程的特点">管程的特点</h5>
<blockquote>
<p>感觉就是把信号量的一些操作给封装了</p>
</blockquote>
<ol type="1">
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问</li>
<li>一个进程通过调用管程的一个过程进入管程</li>
<li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其它进程都被阻塞以等待管程可用</li>
</ol>
<h5 id="函数">函数</h5>
<p>管程通过使用<strong>条件变量</strong>来支持同步，这些条件变量包含在管程中，并且只有在管程中才能被访问</p>
<p>有两个函数可以操作条件变量：</p>
<ul>
<li>cwait(c): 使当前进程阻塞在条件c上</li>
<li>csignal(c): 使阻塞在c条件上的一个进程就绪</li>
</ul>
<h5 id="管程的结构">管程的结构</h5>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/tubePassStruct.jpg" /></p>
<h5 id="例子重写消费者生产者问题">例子：重写消费者生产者问题</h5>
<blockquote>
<p>暂略</p>
</blockquote>
<p>这个例子表明，与信号量相比，管程担负的责任不同。对于管程，它有自己的互斥机制：两个进程不能同时访问缓冲区，但是
<strong><em>cwait csignal</em></strong>
原语的位置需要注意。管程优于信号量之处在于，所有的同步机制都被限制在管程内部，因此不但易于验证同步的正确性，而且易于检测出错误。此外若一个管程被正确的编写，则所有进程对受保护资源的访问都是正确的，而对于信号量，只有当所有资源的进程都被正确编写时，资源访问才是正确的。</p>
<h5 id="管程的通知和广播">管程的通知和广播</h5>
<p>上述方法有两个缺陷</p>
<ul>
<li>产生 <code>csignal</code>
的进程在管程内还未结束，则需要两次额外的进程切换：阻塞进程需要一次切换，管程可用时又需要一次切换</li>
<li>与信号有关的进程调度必须非常可靠</li>
</ul>
<p>在新的管程规则（Mesa）中，<code>csignal</code> 原语被
<code>cnotify</code> 代替，</p>
<p><code>cnotify</code> 可以解释如下：当一个正在管程中的进程执行
<code>cnotify(x)</code> 中，会使得x
条件队列得到通知，但发信号的进程还在继续执行。但是由于不能保证在它之前没有其它进程进入管程，因而这个等待进程必须重新检查条件。</p>
<p><code>cbroadcast</code>
原语：广播可以使所有在该条件上等待的进程置于就绪态，当一个进程不知道有多少进程被激活时，这种方法非常方便</p>
<h4 id="消息传递">5、消息传递</h4>
<blockquote>
<p>进程交互式必须满足两个基本要求：<strong>同步和通信</strong>，为实施互斥，进程间需要同步；为实现合作，进程需要交换信息，提供这一方法之一就是消息传递</p>
</blockquote>
<p><strong><em>注</em></strong>：互斥和同步的联系：——摘自<a
href="https://zhidao.baidu.com/question/414593560.html">百度知道</a>：</p>
<p>​
相交进程之间的关系主要有两种，同步与互斥。所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它
们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。所谓同步，是指散布在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。
　　显然，==同步是一种更为复杂的互斥，而互斥是一种特殊的同步==。
　　也就是说互斥是两个线程之间不可以同时运行，它们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但它是必须要安照某种次序来运行相应的线程（也是一种互斥）！
　　<strong>总结</strong>：互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
　　<strong>同步</strong>：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。</p>
<p><strong>特点（优点）</strong>：可以在分布式系统、共享内存的多处理器系统和单处理器系统中实现</p>
<p><strong><em>消息传递原语</em></strong>：</p>
<ul>
<li><code>send(destination, message)</code></li>
<li><code>receive(source, message)</code></li>
</ul>
<h5 id="同步">同步</h5>
<blockquote>
<p>两个进程之间的消息通信隐含着某种同步的信息：只有当一个进程发送消息后，接受者才能接受消息</p>
</blockquote>
<p>一个进程发出<code>send</code>或者<code>receive原语</code>后，我们需要确定会发生什么：有三种组合：</p>
<ul>
<li><p>阻塞<code>send</code>，阻塞<code>receive</code>：</p>
<p>发送者和接收者都被阻塞，直到完成信息的投递，也叫做会合，考虑进程间的紧密同步</p></li>
<li><p>无阻塞<code>send</code>，阻塞<code>receive：</code></p>
<p>发送者可以继续，但接收者会被阻塞直到请求的消息到达，适用于服务器给其它的进程提供服务和资源</p></li>
<li><p>无阻塞<code>send</code>，无阻塞<code>receive：</code></p>
<p>不要求任何一方等待</p></li>
</ul>
<h5 id="寻址">寻址</h5>
<blockquote>
<p>两个原语的中确定源进程或目标的方案有两类：<strong>直接和间接寻址</strong></p>
</blockquote>
<p><strong>直接寻址：</strong></p>
<p><code>send</code> 原语包含目标进程的标识号，而 <code>receive</code>
有两种处理方式，一种是显示的指定源进程，该进程需要事先直到希望接受来自哪一个进程的消息。另一种是不指定所期望的源进程，例如打印机接受其它进程的打印请求。</p>
<p><strong>间接寻址：</strong></p>
<p>消息不直接从发送者发送到接收者，而是发送到一个共享数据结构，由临时保存消息的队列组成，称为<strong>信箱</strong>，具有一对一，多对一，一对多，多对多三种形式。其中<strong>多对一</strong>的信箱又叫做<strong>端口</strong>。</p>
<p>进程和信箱的关联可以是静态的，也可以是动态的。</p>
<p>还有就是所有权问题。对于端口来说，信箱的所有几乎都是接受进程（多对一），由接受进程创建，对于通用信箱，可以视信箱为创建它的进程所有和该进程一起终止，或是为操作系统所有，这时销毁信箱需要一个显示命令</p>
<h5 id="消息格式">消息格式</h5>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/messageForm.jpg" /></p>
<h5 id="排队原则">排队原则</h5>
<p>最简单的排队原则是先进先出，还有优先级原则，以及允许接收者检查消息队列并选择下一次接受哪个消息</p>
<h5 id="互斥-1">互斥</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="comment">/* 进程数 */</span></span><br><span class="line"><span class="type">void</span> P(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        receive(box, msg);</span><br><span class="line">        <span class="comment">/* 临界区 */</span></span><br><span class="line">        send(box, msg);</span><br><span class="line">        <span class="comment">/* Else */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    create <span class="title function_">mailbox</span><span class="params">(box)</span>;</span><br><span class="line">    send(box, null)</span><br><span class="line">    parbegin(P(<span class="number">1</span>), P(<span class="number">2</span>)...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用无阻塞 <code>send</code> 和阻塞 <code>receive</code>
实现互斥，如果消息被一个进程收取，则另外一个执行 <code>receive</code>
操作的进程将被阻塞</p>
<p><strong>生产者消费者问题：</strong></p>
<p>利用了消息传递的能力，除了传递信号之外，它还传递数据。它使用了两个信箱。当生产者产生数据后，数据将作为
消息发送到信箱 <code>mayconsume</code>
,只要该信箱中有一条消息，消费者就可开始消费。从此之后
<code>mayconsume</code>
用做缓冲区，缓冲区中的数据被组织成消息队列，缓冲区的大小由全局变量
capacity 确定。信箱 <code>mayproduce</code>
最初填满空消息，空消息的数量等于信箱的容量，每次生产使得
<code>mayproduce</code> 中的消息数减少，每次消费使得
<code>mayproduce</code> 中的消息数增多。</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_5/pcMessage.jpg" /></p>
<h4 id="读者写者问题">6、<strong>读者写者问题</strong></h4>
<p>暂略</p>
<h3 id="第六章-并发死锁和饥饿">第六章 并发：死锁和饥饿</h3>
<hr />
<h4 id="死锁原理">6.1 死锁原理</h4>
<p>死锁定义为一组相互竞争系统资源或进行通信的进程间的<strong>“永久”</strong>阻塞，所有死锁都涉及两个或者多个进程之间对资源需求的冲突。</p>
<p>简单来说两个进程都希望获得已经掌握的资源才能继续执行，就产生了死锁。</p>
<h5 id="资源的分类">资源的分类：</h5>
<ul>
<li>可重用资源：一次仅供一个进程安全使用且不因使用而耗尽的资源。包括处理器、I/O
通道，内存和外存等</li>
<li>可消耗资源：可被创建和销毁的资源。包括中断、信号、消息和 I/O
缓冲取中的消息</li>
</ul>
<p>操作系统中死锁检测、预防和避免方法小结：</p>
<figure>
<img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/01.jpg"
alt="操作系统中死锁检测、预防和避免方法小结" />
<figcaption
aria-hidden="true">操作系统中死锁检测、预防和避免方法小结</figcaption>
</figure>
<h5 id="资源分配图">资源分配图</h5>
<p>表征进程资源分配的有效工具是 Holt
引入的<strong>资源分配图</strong>，如下：</p>
<p>其中方块中原点表示资源的一个实例，边表示请求资源和占有资源</p>
<figure>
<img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/02.jpg"
alt="操作系统中死锁检测、预防和避免方法小结" />
<figcaption
aria-hidden="true">操作系统中死锁检测、预防和避免方法小结</figcaption>
</figure>
<p>如果==资源分配图中出现环，并且环中存在资源实例个数小于环中进程的个数==，则可能导致死锁</p>
<h5 id="死锁的条件">死锁的条件</h5>
<p>死锁有三个必要条件：</p>
<ul>
<li>互斥：一次只有一个进程可以使用资源</li>
<li>占有且等待：当一个进程等待其它进程时，继续占有已分配的资源</li>
<li>不可抢占：不能强行抢占已占有的资源</li>
</ul>
<p><strong>这三个为必要条件并非充分条件</strong>，要产生死锁还需要第四个条件：</p>
<p><strong>循环等待</strong>：存在一个闭合的进程链，每个进程至少占有此链中下一个进程所需的一个资源</p>
<p>第四个条件是前三个条件的潜在结果，满足前三个条件，然后在特定顺序的进程调度下就有可能产生死锁。</p>
<h4 id="死锁预防">6.2 死锁预防</h4>
<p>死锁预防策略是设计一种系统来排除发生死锁的可能性，死锁预防分为两类</p>
<ul>
<li>间接死锁预防方法，即阻止前面必要条件中的一个即可</li>
<li>直接死锁预防方法：防止循环等待的发生</li>
</ul>
<h5 id="互斥-2">互斥</h5>
<p>此条件不可能禁止，对于多进程的并发执行调度中，互斥是必须满足的条件</p>
<h5 id="占有且等待">占有且等待</h5>
<p>预防此条件，可以==要求进程一次性地请求所有需要的资源，并阻塞这个进程直到所有请求都同时满足==，显然，这个方法是低效的</p>
<ol type="1">
<li>一个进程可能被阻塞很长时间来等待所有的请求被满足，而实际上只要有一部分资源它就可以继续执行</li>
<li>一个进程可能实现并不知道它所需要的所有资源</li>
</ol>
<h5 id="不可抢占">不可抢占</h5>
<ol type="1">
<li>占有某些资源的一个进程进一步申请资源时若被拒绝，则该进程必须释放最初占有的资源，必要时可再次申请这些资源和其它资源</li>
<li>一个进程请求被其它进程占有的资源时，可以抢占另一个进程，要求它释放资源</li>
</ol>
<h5 id="循环等待">循环等待</h5>
<p>循环等待条件可通过定义资源类型的线行顺序来预防，若一个进程分配了R类型的资源，则接下来请求的资源只能是排在R类型之后的资源</p>
<p>类似占有且等待的预防方法，循环等待的预防方法是低效的，会使进程执行速度变慢，且在没必要的情况下拒绝资源访问</p>
<h4 id="死锁避免">6.3 死锁避免</h4>
<p>死锁避免<strong>允许三个必要条件</strong>，但通过特定的选择，确保永远不会到达死锁点，死锁避免可允许更多的并发，<u>死锁避免通过当前的资源分配采取措施，所以需要直到未来进程资源请求的情况</u></p>
<p>书本给出两种死锁避免方法：</p>
<ul>
<li><strong>进程启动拒绝</strong>：若一个进程的请求会导致死锁，则不启动该进程</li>
<li><strong>进程分配拒绝</strong>：若一个进程增加的资源请求会导致死锁，则不允许这一资源分配</li>
</ul>
<h5 id="进程启动拒绝">进程启动拒绝</h5>
<p>考虑 n 个进程和 m 种不同类型资源的系统，有以下定义：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/03.jpg" /></p>
<p>从中可以得知：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/04.jpg" /></p>
<h5 id="资源分配拒绝">资源分配拒绝</h5>
<p>资源分配拒绝策略，即
<strong>银行家算法</strong>，定义了安全状态和不安全状态，进程请求一组资源时，查看同意此请求之后的状态，若还为安全状态，则分配资源，否则拒绝</p>
<ul>
<li>安全状态：至少有一个资源分配序列不会导致死锁</li>
<li>不安全状态：非安全的一个状态</li>
</ul>
<p>但在此处，不可能真的对所有资源分配序列进行探查，判断是否存在此分配序列，所以通常根据下面的关系式判断是否是安全序列：</p>
<p><span class="math inline">\(C_{ij} - A_{ij} \le V_j ,
对所有的j\)</span></p>
<p>一个安全状态的例子：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/05.jpg" /></p>
<p><strong>死锁避免的优点</strong>：无须死锁预防的抢占和回滚进程，且与死锁预防相比限制较少</p>
<p><strong>死锁避免的限制</strong>：</p>
<ul>
<li>必须实现声明每个进程请求的最大资源</li>
<li>所讨论的进程必须是无关的，即它们的执行顺序必须没有同步要求的限制</li>
<li>分配的资源数量必须是固定的</li>
<li>在占有资源时，进程不能退出</li>
</ul>
<h4 id="死锁检测">6.4 死锁检测</h4>
<h5 id="死锁检测算法">死锁检测算法</h5>
<p>死锁预防策略非常保守，它们通过限制访问资源和进程上强加约束来解决死锁问题，而
<strong>死锁检测不限制资源访问或约束进程行为，只要有可能就会给进程分配其所需要的资源，操作系统周期性的执行一个算法来检测前面的条件（4）（循环等待条件）</strong></p>
<p>书本中死锁检测的算法，在之前定义的基础上还存在一个请求矩阵 <span
class="math inline">\(Q\)</span>，其中 <span
class="math inline">\(Q_{ij}\)</span> 表示进程 <span
class="math inline">\(i\)</span> 请求资源 <span
class="math inline">\(j\)</span>
的数量，此算法主要是一个标记未死锁进程的过程，最初所有进程都是未标记的，然后执行以下步骤：</p>
<ol type="1">
<li>标记 Allocation 矩阵中一行全为零的进程</li>
<li>初始化一个临时向量 W，令 W 等于 Available 向量</li>
<li>查找下标 i，使得对所有的 <span class="math inline">\(1 \le k \le m,
Q_{ik} \le W_k\)</span>，若找不到 i，终止</li>
<li>若找到这样的行，标记进程 i，并把 Allocation 矩阵中的相应行加到 W
中，即对所有的 <span class="math inline">\(1\le k \le m, 令 W_k +=
A_{ik}\)</span>，返回步骤 3</li>
</ol>
<p>简单来说就是查找一个可以在当前可用资源条件下完成的进程，然后释放该进程占用的资源（即此进程可以正常执行，结束后回收资源），然后查找下一个，当不存在此进程的时候，剩余的所有进程都不可能在当前资源条件下执行，所以这些进程是死锁的。</p>
<h5 id="死锁恢复">死锁恢复</h5>
<p>检测到死锁后就需要某种策略来恢复死锁，下面为按复杂度递增的顺序列出可能的方法：</p>
<ol type="1">
<li>取消所有的死锁进程，操作系统最常采用的方法</li>
<li>把每个死锁进程回滚到前面定义的某些检查点，并重新启动</li>
<li>连续取消死锁进程直到不存在死锁，所选取消进程的顺序基于某种最小代价原则，每次取消后重新检测是否存在死锁</li>
<li>连续抢占资源直到不存在死锁，和 3
一样依赖某种最小代价原则，一个资源被抢占的进程必须回滚到获得这个资源之前的某一状态</li>
</ol>
<p>对于（3）（4）可参考以下原则：</p>
<ul>
<li>目前为止小号的处理器时间最小</li>
<li>目前为止产生的输出最少</li>
<li>预计剩下的时间最长</li>
<li>目前位置分配的资源总量最少</li>
<li>优先级最低</li>
</ul>
<h4 id="一种综合的死锁策略">6.5 一种综合的死锁策略</h4>
<p>以上解决死锁的策略都各有优缺点，所以操作系统可以在不同的情况下使用不同的策略</p>
<ul>
<li>把资源分成几组不同的资源类</li>
<li>为预防在资源类之间由于循环等待产生死锁，采用前面的线性排序策略</li>
<li>在一个资源类中，使用该类资源最适合的算法</li>
</ul>
<p>其中资源可分为：</p>
<ul>
<li><strong>可交换空间</strong>：进程交换所用外存中的存储块</li>
<li><strong>进程资源</strong>：可分配的设备、如磁带设备和文件</li>
<li><strong>内存</strong>：可按页或段分配给进程</li>
<li><strong>内部资源</strong>：诸如 I/O 通道</li>
</ul>
<p>在每一类资源中，可采取一下策略确定次序：</p>
<ul>
<li><strong>可交换空间</strong>：要求一次性分配所有请求资源预防死锁</li>
<li><strong>进程资源</strong>：死锁避免通常是有效的，因为进程可以实现声明所需要的资源，采用资源排序的预防策略也是可能的</li>
<li><strong>内存</strong>：对于内存。基于抢占的预防是最适合的策略，当一个进程被抢占后，它被换到外存，释放空间可以解决死锁</li>
<li><strong>内部资源</strong>：可以使用基于资源排序的预防策略</li>
</ul>
<h4 id="哲学家就餐问题">6.6 哲学家就餐问题</h4>
<p>有五位哲学家，它们的就餐在一张圆桌上，圆桌上有5个盘子，盘子之间有一把叉子，每位想吃饭的哲学家就餐时使用盘子两侧的叉子</p>
<p>为避免死锁的风险，可再买5把叉子，另一种方法是只允许四位哲学家同时进入餐厅，由于最多有4位哲学家就座，因而至少有一位哲学家可以拿到两把叉子</p>
<p>两种方案的解决代码如下：（第一种解决方案会导致死锁）</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_2/c_6/06.jpg" /></p>
<h2 id="第三部分-内存">第三部分 内存</h2>
<hr />
<h3 id="第七章-内存管理">第七章 内存管理</h3>
<hr />
<p>在单道程序设计系统中（本书主要讨论单道），内存划分为两部分</p>
<ul>
<li>操作系统专用</li>
<li>提供“用户”进程使用</li>
</ul>
<p>简单的内存管理术语：</p>
<ul>
<li>页框：<strong>内存</strong>中固定长度的块</li>
<li>页：<strong>固定长度的数据块</strong>，存储在二级存储中，可以临时复制到内存的页框中</li>
<li>段：<strong>变长数据块</strong>，存储在二级存储中，整个段临时复制到内存中（分段），或将段变为页，然后单独将每页复制到内存中（分段、分页相结合）</li>
</ul>
<h4 id="内存管理的需求">7.1 内存管理的需求</h4>
<h5 id="重定位">重定位</h5>
<p>为了使处理器利用率最大化，程序换出到磁盘后，下次换入到换出之前的内存区域很困难，相反，我们需要把进程重定位到内存的不同区域。这样就会带来寻址的问题。处理器<strong>硬件</strong>和<strong>操作系统软件</strong>必须能以某种方式把程序代码中的内存访问转换为实际的物理内存地址，并反映程序在内存中的当前位置。</p>
<h5 id="保护">保护</h5>
<p>每个进程都应受到保护，以免其它进程有意或无意地干扰。</p>
<p>通常用户进程不能访问操作系统的任何部分，无论是程序还是数据。此外，一个进程中的程序通常不能跳转到另一个进程中的指令，若无特别许可，一个进程的程序不能访问其它进程的数据区。</p>
<p>内存保护需求必须由<strong>处理器（硬件）</strong>而非操作需要（软件）来满足，因为操作系统不能预测程序可能产生的所有内存访问，即使可以预测检查也非常费时。</p>
<h5 id="共享">共享</h5>
<p>任何保护机制都必须具有一定的灵活性，以允许多个进程访问内存的同一部分。内存管理系统在不损害基本保护的前提下，必须允许对内存共享区域进行受控访问。</p>
<h5 id="逻辑组织">逻辑组织</h5>
<p>计算机系统的内存和外存总是被组织成<strong>线性的地址空间</strong>。大多数程序被组织成模块，某些模块是不可修改的，若操作系统和计算机硬件能够有效地处理以某种模块形式组织的用户程序与数据，则会带来许多好处：</p>
<ol type="1">
<li>可以独立地编写和编译模块</li>
<li>通过适度的额外开销，可以为不同的模块提供不同的保护级别</li>
<li>可以引入某种机制，使得模块被多个进程共享</li>
</ol>
<p>最易于满足这些需求的根据是<strong>分段</strong></p>
<h5 id="物理组织">物理组织</h5>
<p>计算机系统分为两级，内存和外存，内存提供快速的访问，成本高，易失性；外存较慢且便宜，非易失性。</p>
<p>在这种两级方案中，系统主要关注的是内存和外存之间信息流的组织，组织这一信息流是由系统负责的，而不能由程序员负责。</p>
<h4 id="内存分区">7.2 内存分区</h4>
<p>内存管理的主要操作是处理器把程序装入内存中执行，内存管理技术由以下几种：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/01.jpg" /></p>
<h5 id="固定分区">固定分区</h5>
<p>管理用户内存空间的最简方案就是对它分区，以形成若干边界固定的区域</p>
<p>分区大小：</p>
<ul>
<li>大小相等的分区</li>
<li>大小不等的分区</li>
</ul>
<p><strong>内部碎片</strong>：装入的数据块小于分区大小，因而导致分区内部存在空间浪费，这种现象称为内部碎片</p>
<p><strong>放置算法</strong>：</p>
<p>对于大小相等的分区，只需要把每个进程分配到能够容纳它的最小分区中，每个分区都需要维护一个调度队列，用于保存从这个分区换出的进程</p>
<p>对于大小不等的分区，也可以采取上面这种方式，对于单个分区来说是最优的，可以达到最小的内部碎片，但是从整个系统看不是最佳的，小内存的进程可能被阻塞即使有大的空闲分区，所以一种更可取的方式是为所有的进程只提供一个队列。如果所有都被占据，则必须进行交换，一般优先考虑一些诸如优先级之类的其它因素，或者优先选择换出阻塞的进程而非就绪进程</p>
<p>固定分区方案简单，但存在以下缺点：</p>
<ul>
<li>分区的数量在系统生成阶段已经确定，因而
<strong>限制了系统中活动进程的数量</strong></li>
<li>分区的大小是在系统生成阶段实现设置的，因而
<strong>小作业不能有效地利用分区空间</strong></li>
</ul>
<h5 id="动态分区">动态分区</h5>
<p>对于动态分区，分区长度和数量是可变的，进程装入内存时，系统会给它分配一块与其所需容量完全相等的内存空间，动态分区方法会在内存中形成许多小空洞（外部碎片），内存利用率随之下降</p>
<p>克服外部碎片的一种方法是<strong>压缩</strong>，操作系统不时地移动进程，使得进程占用的空间连续，使得所有空闲空间连成一片。</p>
<p>压缩是一个非常耗时的过程，另外，压缩需要动态重定位的能力，能够把程序从内存的一块区域移动到另一块区域，且不会使程序中的内存访问无效</p>
<p><strong>放置算法</strong>：</p>
<p>可供考虑的放置算法有三种：</p>
<ul>
<li><strong>最佳适配：</strong>选择大小最接近的块，性能较差</li>
<li><strong>首次适配：</strong>从头开始扫描，选择大小足够的第一个可用块，通常是最简单有效的</li>
<li><strong>下次适配：</strong>从上一次放置的位置开始，选择下一个可用块，较首次适配差，常常会在内存的末尾分配空间，导致末尾的
最大空闲存储块很快分裂为小碎片，因此可能会需要更多的压缩</li>
</ul>
<h5 id="伙伴系统">伙伴系统</h5>
<p>伙伴系统中内存块大小为 <span class="math inline">\(2^K\)</span>
个字，<span class="math inline">\(L \le K \le U\)</span>，<span
class="math inline">\(2^L\)</span> 表示分配的最小块尺寸，<span
class="math inline">\(2^U\)</span>
表示分配的整个内存的大小，伙伴系统简单来说就是，给定大小为 <span
class="math inline">\(2^i\)</span>
（i为不小于此进程大小的最小整数），然后寻找一个大小为 <span
class="math inline">\(2^i\)</span> 的空闲块，每个大小为 <span
class="math inline">\(2^i\)</span>
的块都有维护列表，空闲块可以由对半分裂从大小为 <span
class="math inline">\(2^{i+1}\)</span> 的列表移出，并在 <span
class="math inline">\(2^i\)</span> 列表中产生两个伙伴，当 <span
class="math inline">\(2^i\)</span> 列表一对伙伴都未分配时，则合并移入到
<span class="math inline">\(2^{i+1}\)</span> 中，可以由下面算法找到一个
<span class="math inline">\(2^i\)</span> 大小的空闲块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_hole</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == U+<span class="number">1</span>) &lt;failure&gt;;</span><br><span class="line">    <span class="keyword">if</span>(&lt;i_list empty&gt;) &#123;</span><br><span class="line">        get_hole(i+<span class="number">1</span>);</span><br><span class="line">        &lt;split hole into buddies&gt;;</span><br><span class="line">        &lt;put buddies on i_list&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;take first hole on i_list&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/02.jpg" /></p>
<p>释放B后的二叉树：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/03.jpg" /></p>
<h5 id="重定位-1">重定位</h5>
<p>在内存中放置进程需要的一种技术。进程在重新换入到内存后其地址是不确定的，所以需要<strong>逻辑地址</strong>和<strong>物理地址</strong>的转换</p>
<ul>
<li>逻辑地址：与物理分配地址无关的地址</li>
<li>相对地址：逻辑地址的特例，相对已知点的存储单元</li>
<li>物理地址：在内存中的实际位置</li>
</ul>
<p>重定位的硬件支持如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/04.jpg" /></p>
<p>基址寄存器为程序在内存中的地址，通过与相对地址相加转换为绝对地址，然后与界限寄存器（即程序的终止位置）比较，如超过界限寄存器则发送错误，产生中断</p>
<h4 id="分页">7.3 分页</h4>
<p>将
<strong>内存和进程都划分为大小固定，相等且比较小的块，在进程中的称为页，在内存中的称为页框</strong>。使用分页技术，每个进程在内存中浪费的空间，仅是进程最后一页一小部分形成的内部碎片，没有外部碎片。</p>
<p>它和固定分区不同的是：<strong>采用分页技术的分区相当小，一个程序可以占据多个分区，并且这些分区<u>不需要是连续的</u></strong>。</p>
<p>实现上述的方法之一是，每个进程维护一个<strong>页表</strong>，<u>页表给出了该进程每页对应页框的位置</u>。在程序中，每个逻辑地址包括一个页号和该页中的偏移量。</p>
<p>为了使分页方案更加方便，<strong>规定页和页框的大小必须是2的幂，以便容易地表示出相对地址</strong>，有以下两个好处：</p>
<ol type="1">
<li>逻辑地址方案对编程者、汇编器和链接是透明的（透明的意思是不可见），程序每个逻辑地址与其相对地址是一致的</li>
<li>用硬件实现允许时动态地址转换比较容易。考虑一个 n+m 位地址，最左边的
n 位是页号，最右边的 m 位是偏移量（偏移量的位数和页的大小存在关系 <span
class="math inline">\(2^m = 页大小\)</span>，地址转换经过以下步骤：
<ul>
<li>提取页号，即逻辑地址左侧 n 位</li>
<li>以这个页号为索引，查找进程页表中对应的页框号 k</li>
<li>页框的起始物理地址为 <span class="math inline">\(k\times
2^m\)</span>，被访问字节的物理地址是这个数加上偏移量。可以简单地把偏移量附加到页框号后面来构建物理地址。</li>
</ul></li>
</ol>
<p>简单分页的图形表示如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/05.jpg" /></p>
<h4 id="分段">7.4 分段</h4>
<p>采用分段技术，可以把程序和与其相关的数据划分到几个段，尽管段的最大长度有限制的，但不要求长度都相等，和分页一样，其逻辑地址由段号和偏移量组成。</p>
<p>同样会产生外部碎片，但是由于块可以设置的很小所以外部碎片也很小，分段也不要求分区是连续的。</p>
<p>分页对程序员是透明的，<strong>分段则是可见的</strong>。为实现模块化设计，程序或数据分段或进一步分段。</p>
<p>采用大小不等的段的另一个结果是，逻辑地址和物理地址不再是简单的对应关系，在简单的分段方案中，每一个进程都有一个<strong>段表</strong>，系统也会维护一个内存中的空闲块列表，<u>段表项必须给出相应段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效地址</u>。</p>
<p>考虑一个 n+m 位的地址，左侧 n 位是段号，右侧 m
位是偏移量，进行地址转换有以下步骤：</p>
<ol type="1">
<li>提取段号，即左侧n位</li>
<li>以这个段号为索引，查找进程段表中该段的起始物理地址</li>
<li>最右侧m位，表示偏移量，若偏移量大于段长度则该地址无效</li>
<li>物理地址为该段起始物理地址与偏移量之和</li>
</ol>
<p>简单分段的图形表示：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_7/06.jpg" /></p>
<p>这里讨论的还是<strong>简单分页和简单分段，进程必须把所有全部加载到内存中</strong>，如果采用了覆盖或者虚存技术，则可以部分加载内存中，这部分在下一章讨论。</p>
<p><a
href="https://blog.csdn.net/dongyanxia1000/article/details/51425141"><strong>覆盖：</strong></a>所谓<strong><em>覆盖</em></strong>，就是把一个大的程序划分为<strong>一系列覆盖</strong>，每个覆盖就是一个相对独立的程序单位，<strong>把程序执行时并不要求同时装入内存的覆盖组成一组，称为覆盖段</strong>。<strong><em>一个覆盖段内的覆盖共享同一存储区域</em>，</strong>该区域成为覆盖区，它与覆盖段一一对应。显然，为了使一个覆盖区能为相应覆盖段中的每个覆盖在不同时刻共享，其大小应<strong><em>由覆盖段中的最大覆盖</em></strong>来确定。</p>
<blockquote>
<p>分段的段表给出了基地址和页号本质上是一致的，分页中页号乘以页大小即为基地址所以直接和偏移量拼接即可，段地址长度不一，所以需要给出长度过滤无效地址</p>
</blockquote>
<h3 id="第八章-虚拟内存">第八章 虚拟内存</h3>
<hr />
<p>简单的虚拟内存相关定义：</p>
<ul>
<li><p><strong>虚拟内存</strong>：</p>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如
Windows 家族的“虚拟内存”；Linux 的“交换空间”等。</p></li>
<li><p><strong>虚拟地址</strong>：</p>
<p>在虚拟内存中分配给某一位置的地址，使得该位置可被访问，如同内存</p></li>
<li><p><strong>虚拟地址空间</strong>：分配某进程的虚拟存储</p></li>
<li><p><strong>地址空间</strong>：用户某进程的内存地址范围</p></li>
<li><p><strong>实地址</strong>：内存中存储位置的地址</p></li>
</ul>
<hr />
<h4 id="硬件和控制结构">8.1 硬件和控制结构</h4>
<p>分页和分段存在着这样的特点：</p>
<ul>
<li><strong>进程中所有的内存访问都是逻辑地址。</strong>意味着一个进程可被换入或换出内存（只需要更新页表或段表即可），因此进程可在执行过程中的不同的时刻占据不同区域</li>
<li><strong>一个进程可划分为许多块，执行中不需要连续的位于内存中。</strong>页表和段表的使用保证这一特点</li>
</ul>
<p>这样的特点可以使得一个进程在执行的过程中，<strong>该进程不需要所有页或段都在内存中</strong>，只需要在内存保存下一条指令所在块，以及将访问的数据块即可。（这里的块都代表页或段）</p>
<p>进程执行过程中任何时刻都在内存中的部分称为进程的
<strong>常驻集（resident
set）</strong>，只要所有的内存访问都是常驻集中的单元，执行就可以顺利进行，并且处理器可以判断是否如此。当访问一个不再内存中（驻留集）的逻辑地址，会产生一个中断，操作系统会将此进程置于
<strong>阻塞态</strong> ，为此操作系统产生一个
<strong>磁盘I/O读请求</strong>，在执行此 I/O
期间，操作系统可以调度另一个进程运行，在读入内存后（按某种置换策略），产生一个
I/O 中断，操作系统则将原来被阻塞的进程置为 <strong>就绪态</strong>。</p>
<p>内存又称为
<strong>实存储器</strong>，简称实存，但程序员或用户感觉到的是一个更大的内存，且通常分配在磁盘上，称为
<strong>虚拟内存（virtual
memory）</strong>，简称虚存。虚存支持更有效的系统并发度，解除用户与内存之间没有必要的紧密联系。</p>
<p>分页和分段的特点：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/01.jpg" /></p>
<h5 id="局部性和虚拟内存">局部性和虚拟内存</h5>
<hr />
<p>虚拟内存的开销收到
<strong>系统抖动（thrashing）</strong>的影响。在虚存的机制下操作系统读取一块到内存，通常要将另一块换出，如果这块正好在将要用到之前换出，操作系统不得不很快的将它收回，会
<strong>导致处理器大部分的时间都用于交换块而非执行指令</strong>。</p>
<p>避免系统抖动的算法都根据最近的历史来猜测将来最可能用到的块。这类推断基于<strong>局部性原理</strong>（一个进程中程序和数据引用的集簇倾向）</p>
<p>局部性原理表明虚存方案是可行的，要使虚存比较实用且有效，需要两方面因素：</p>
<ol type="1">
<li>必须有对分页或分段方案的硬件支持</li>
<li>操作系统必须有管理页或段在内存和辅存之间移动的软件</li>
</ol>
<h5 id="分页-1">分页</h5>
<hr />
<blockquote>
<p>主要有二级页表、倒排页表、转换检测缓冲区等结构</p>
</blockquote>
<p>虚存分页和简单分页一样都有页表，其中 <strong>页表项（Page Table
Entry，PTE）</strong> 相比简单分页也多了一些内容，如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/02.jpg" /></p>
<p>其中的 <strong>P</strong>
表示它所对应的页当前是否在内存中，如果在内存中，则还包括页框号，另一位是<strong>修改位（M）</strong>表示相应的内容装入内存后是否发生变化，若没有改变则无需重新写入辅存，否则需要用该页更新原来的页。</p>
<p>同简单分页类似，逻辑地址依然由页号和偏移量组成，而物理地址由页框号和偏移量组成，页表的长度基于进程长度的变化而变化，以下给出了一种硬件实现：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/03.jpg" /></p>
<p>上述页表的简单处理在虚存空间大的时候会导致页表项的也十分大，一种解决方案是在虚存中保存页表，这意味着
<strong>页表和其它页一样服从分页管理</strong>，一个进程在运行时，它的页表至少有一部分在内存中，这一部分包括正在运行的页的页表项，有一种
<strong>两级层次页表结构</strong> 来组织大型页表，典型情况如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/04.jpg" /></p>
<p>以上是 32 位地址两级方案的例子，假设采用字节级寻址，页尺寸为 <span
class="math inline">\(4KB (2^{12})\)</span> ,则 <span
class="math inline">\(4GB (2^{32})\)</span> 虚拟地址空间由 <span
class="math inline">\(2^{20}\)</span>
页组成，若这些页的每一页都由一个4字节的页表项映射，则可创建由 <span
class="math inline">\(2^{20}\)</span> 页表项组成的页表，这时需要 <span
class="math inline">\(4MB(2^{22})\)</span> 的内存空间。这个由 <span
class="math inline">\(2^{10}\)</span>
页组成的巨大用户页表可以保留在虚存中，并由一个包括 <span
class="math inline">\(2^{10}\)</span>
个页表项的根页表映射，根页表占据的内存为 <span
class="math inline">\(4KB(2^{12})\)</span>，二级页表的地址转换如下图：（根页表的页表项存4KB页表每一页的基地址）</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/05.jpg" /></p>
<hr />
<p>即使是二级页表，页表大小与虚拟地址空间的大小成正比，可以使用<strong>倒排页表</strong>替代这种结构，==称为“倒排”的原因是，它使用页框号而非虚拟页号来索引页表项，它的大小是固定的==，在虚存空间特别大的时候开销比多级页表少。</p>
<p>在这种方法中，虚拟地址的页号部分使用一个散列函数映射到散列表中。散列表包含指向倒排表的指针，而倒排表中含有页表项，页表项包含以下内容：</p>
<ul>
<li><strong>页号</strong>：虚拟地址的页号部分</li>
<li><strong>进程标识符</strong>：使用该页的进程，页号和标识符确定一个特定进程的一页</li>
<li><strong>控制位</strong>：包含一些标记，如有效，访问，修改和锁定信息</li>
<li><strong>链指针</strong>：以为散列函数可能会将多个值散列到一个区域，所以存在链（下一项的索引值）</li>
</ul>
<p>下图是一个n位页号m位数索引倒排表的页表结构图：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/06.jpg" /></p>
<hr />
<p>每次虚存访问都可能会引起两次物理内存访问：</p>
<ul>
<li>取相应的页表项</li>
<li>取需要的数据</li>
</ul>
<p>因此简单的虚拟内存方案会导致内存访问时间加倍，为克服这个问题，可以采用
<strong>转换检测缓冲区（Translation Lookaside
Buffer，TLB）</strong>（一个特殊的高速缓存，包含最近用过的页表项）。给定一个虚拟地址，处理器首先检查TLB，若需要的页表项在其中，则检索页框号形成实地址，若未找到则使用页号检索检查页表。然后查看其”存在位“状态，若不在内存中，则会产生一次内存访问故障，称为<strong>缺页（page
fault）</strong>中断，此时由操作系统负责装入所需要的页，并更新页表。基本机理如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/07.jpg" /></p>
<p>TLB使用流程如下，图中未显示磁盘I/O过程中可以调度另外进程执行。根据局部性原理大多数虚存访问都位于最近使用过的页中，所以此方案可以提高性能。</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/08.jpg" /></p>
<p>TLB 的实际组织还有许多额外细节，由于 TLB
仅包含整个页表中的部分表项，因此不能简单地把页号编入 TLB 的索引，所以
TLB
的项必须包含页号和完整的页表项（和倒排表一样），这两种技术对应直接映射（索引）和关联映射，如下所示：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/09.jpg" /></p>
<p>虚存机制须与高速缓冲系统（内存高缓）进行交互。首先，内存系统查看 TLB
是否存在匹配的页表项，若不存在则从页表中读取页表项。产生一个 TAG
标记和其余部分组成的实地址后，查看高速缓存中是否存在，若有则返回给
CPU，若没有，则从内存中检索这个字。若被访问的字在磁盘中，则包含该字的页必须装入内存，且所在的块须装入高速缓存，且其页表项必须更新。</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/10.jpg" /></p>
<hr />
<p>页尺寸是一个重要的硬件设计决策，页越小，内部碎片总量越少；另一方面，页越小，每个进程需要的页数量越多，页表也会变得更大。大页表不容易存储(二级页表)会导致产生两次缺页中断（读取页表，读取页），但大页表又利于数据块传送。大体来说，<strong>缺页率</strong>和<strong>页尺寸</strong>和分配的<strong>页框数</strong>有关系。</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/11.jpg" /></p>
<p>页尺寸的设计问题还与物理内存大小和程序大小有关。</p>
<h5 id="分段-1">分段</h5>
<hr />
<p>分段组织与非段式有许多优点：</p>
<ol type="1">
<li>简化了对不断增长的数据结构的处理</li>
<li>允许程序独立地改变或重新编译</li>
<li>有助于进程间的共享</li>
<li>有助于保护</li>
</ol>
<p>类似的虚存分段和简单分段一样也为每个进程维护一个段表，段表项包含存在位和修改位，以及该段的起始地址和长度。分段的地址转换如下图：（这里虚拟地址是段号，图片有误）</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/12.jpg" /></p>
<hr />
<h5 id="段页式">段页式</h5>
<p>分段和分页各有所长，在段页式系统中，用户地址空间被程序员划分为许多段，每段划分为和内存页框大小相同的页。逻辑地址仍然由段号和偏移量组成，段偏移量可视为指定段中的页号和页偏移量。其地址转换如下图：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/13.jpg" /></p>
<h4 id="操作系统软件">8.2 操作系统软件</h4>
<p>操作系统内存管理设计取决于三个基本的选择：</p>
<ul>
<li>是否使用虚存技术</li>
<li>是使用分页还是分段，或同时使用两者</li>
<li>为各种存储管理特征采用的算法</li>
</ul>
<p>前两者取决于所用的硬件平台（当前计算机主流提供了虚存的支持，且纯分段的系统也越来越少，<strong>结合分段分页后操作系统内存管理问题都是面向分页的</strong>）第三个就是操作系统软件领域的问题，也是本节所述。</p>
<p>虚拟内存的操作系统策略：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/14.jpg" /></p>
<p>上表不存在一种绝对的最佳策略，<strong>在所有的策略中都要做到通过适当的安排，使得一个进程在执行时，访问一个未命中的页中的字的概率最小</strong>。</p>
<h5 id="读取策略">读取策略</h5>
<hr />
<p>读取策略决定某页何时取入内存，常用的两种方法是请求分页和预先分页</p>
<ul>
<li><strong>请求分页（demand
paging）</strong>：只有当访问到某页中的一个单元时才将该页取入内存，开始缺页率高由于局部性原理之后缺页率会逐渐减少</li>
<li><strong>预先分页（prepaging）</strong>：利用大多数辅存设备的寻道时间和合理的延迟，一次读取多个连续的页，如果额外读取的页没有使用到，则低效</li>
</ul>
<h5 id="放置策略">放置策略</h5>
<hr />
<p>在纯分段系统中，放置策略并不是重要的设计问题（最佳适配、首次适配等均可）<strong>对于分页和段页式系统，如何放置通常无关紧要，因为地址转换硬件和内存访问硬件能以相同的效率为任何页框组合执行相应的功能</strong></p>
<h5 id="置换策略">置换策略</h5>
<hr />
<p>置换策略涉及到的问题有：</p>
<ul>
<li>给每个活动进程分配多少页框</li>
<li>计划置换的页集是局限于那些产生缺页中断的进程还是所有页框都在内存中的进程</li>
<li>在计划置换的页集中，选择换出哪一页</li>
</ul>
<p>前两个为驻留集管理，之后讨论，置换策略专指第三个概念</p>
<p><strong>页框锁定</strong>：注意的是对于被锁定的页框，则不能被用于置换，锁定是给每个页框关联一个锁定位实现的，可以包含在页框表和当前的页表中</p>
<p>基本算法有：</p>
<ul>
<li><p><strong>最佳（Optimal，OPT）</strong>：</p>
<p>选择置换下次访问距当前时间最长的那些页，这种方法是最优的，但是操作系统必须直到将来的事件，因此不可能实现，仅作为一种衡量标准</p></li>
<li><p><strong>最近最少使用（Least Recently Used，LRU）</strong>：</p>
<p>置换内存中最长时间未被引用的页，根据局部性原理，这也是最近最不可能访问到的页，其性能接近OPT策略，但较难实现，开销大</p></li>
<li><p><strong>先进先出（First In First Out，FIFO）</strong>：</p>
<p>将分配给进程的页框视为一个循环缓冲区，并按循环方式移动页，需要一个指针在页框中循环，这种策略实际是置换驻留在内存时间最长的页，但通常导致频繁的换入换出页</p></li>
<li><p><strong>时钟（CLock）</strong>：</p>
<p>最简单的时钟策略给每个页框附加一个使用位，每当该页
<strong>装入内存，或被访问时使用位置为
1</strong>，并有一个指针与之相关联，当
<strong>一页被置换时，该指针指向位下一个页框</strong>。需要置换一页时，操作系统扫描缓冲区，<strong>查找一个使用位为
0 的页框，扫描过程中遇到使用位为 1 时，将其置为 0</strong>。</p>
<p>这个时钟策略类似 FIFO，不过它跳过了 1 的项，1
说明它最近访问过，时钟策略都是尽可能用少的开销达到 LRU 的效率</p></li>
</ul>
<p>四种方法的比较：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/15.jpg" /></p>
<p>对固定页框数量且为局部页面置换，有如下关系：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/16.jpg" /></p>
<p>一种更有效的时钟算法采取了<strong>使用位和修改位</strong>，此时每个页框状态有：</p>
<ul>
<li>最近未被访问，也未被修改 (u = 0; m = 0)</li>
<li>最近被访问，但未被修改 (u = 1; m = 0)</li>
<li>最近未被访问，但被修改 (u = 0; m = 1)</li>
<li>最近被访问，且被修改 (u = 1; m = 1)</li>
</ul>
<p>此时的时钟算法执行过程如下：</p>
<ol type="1">
<li>从指针的当前位置开始扫描缓冲区，选择遇到的第一个 (u = 0; m = 0)
用户置换</li>
<li>若第一步失败，则重新扫描，查找 (u = 0; m = 1)
的页框，选择第一次遇到的用于置换，在这一扫描过程中将每个跳过的页框的使用位置为0</li>
<li>若第2步失败，则指针回到最初的位置，且集合中所有页框的使用位均为0，重复第1步，并在必要时重复第二步，直到寻找到可用于置换的页框</li>
</ol>
<p>==此策略查找自被取入至今未被修改且未访问的页==（如果有的话），由于未被修改，则不需要写回辅存。</p>
<p>还有一种称为 <span id="page-buffer"><strong>页缓冲</strong></span>
的方法允许使用较简单的页面置换策略（FIFO）。这种算法不丢弃置换出的页而是分配到两个表中（不移动页移动对应的页表项）：</p>
<ol type="1">
<li>若未被修改，分配到空闲链表中</li>
<li>若已被修改则分配到修改页链表中</li>
</ol>
<p>这种方法的特定是，<strong>被置换的页仍然留在内存中</strong>，若进程访问该页，则可迅速返回该进程的驻留集且代价很小，实际上就是充当了高速缓存的角色</p>
<h5 id="驻留集管理">驻留集管理</h5>
<hr />
<p>对于驻留集（操作系统给进程分配的内存空间）大小，需要考虑以下几个因素：</p>
<ul>
<li>分配给一个进程的内存越少，则驻留在内存中的进程数就越多。增加了操作系统至少找到一个就绪进程的可能性，减少了由于交换而消耗的处理器时间</li>
<li>若一个进程在内存的页数较少，尽管有局部性原理，缺页率仍相对较高</li>
<li>给特定进程分配的内存空间超过一定大小后，由于局部性原理，改进程的缺页率没有明显的变化</li>
</ul>
<p>当代操作系统通常采取两种策略：</p>
<ul>
<li><strong>固定分配策略</strong>：为一个进程在内存中分配固定数量的页框</li>
<li><strong>可变分配策略</strong>：允许分配给一个进程的页框在该进程的生命周期中不断的发生变化</li>
</ul>
<p>可变分配策略的
<u>难点在于要求操作系统评估活动进程的行为</u>，会增加操作系统的软件开销</p>
<p>对于 <strong>置换范围</strong> 有局部和全局两类</p>
<ul>
<li><strong>局部置换策略</strong>：仅在产生这次缺页的进程的驻留页中选择</li>
<li><strong>全局置换策略</strong>：内存中所有未锁定的页都是置换目标</li>
</ul>
<p>置换范围和驻留集大小之间的关系：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/17.jpg" /></p>
<p>注意固定分配没有全局置换策略，因为如果替换其它进程的页框，因为需要保持页框数固定，则它也需要重新置换一个，则是无意义的</p>
<p><strong>工作集策略</strong>：略</p>
<h5 id="清除策略">清除策略</h5>
<hr />
<p>清除策略用于确定何时将已修改的一页写回辅存，通常有两种选择：</p>
<ul>
<li><strong>请求式清除</strong>：只有当一页被选择用于置换时写回</li>
<li><strong>预约式清除</strong>：将已修改的多页在需要使用它们占据的页框之前成批写回</li>
</ul>
<p>完全使用一种策略都存在危险，预约式请求可能在写回后又发生更改，这样就没太大的意义，请求式则意味着写回修改页和读入新页，且读入在写回前，会降低处理器的利用率</p>
<p>一种较好的方法是结合 <a
href="#page-buffer"><strong>页缓冲技术</strong></a>：只清除可用于置换的页，去除了清除和置换操作之间的成对关系，被置换页可放于修改表和未修改表。修改表中的页可以周期性的成批写出，并移到未修改表中。未修改表的一页要么被访问到而回收，要么在其页框分配给另一页时被淘汰。</p>
<h5 id="加载控制">加载控制</h5>
<hr />
<p>加载控制会影响到驻留在内存中的进程数量，着称之为系统并发度。如果驻留进程过少，那么所有进程都处于阻塞态概率就较大，因而许多时间花费在交换上。另一方面，进程过多，那么驻留集大小可能会不够用，会发生频繁的缺页中断，导致系统抖动</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_3/c_8/18.jpg" /></p>
<p>解决上述冲突，可以使用工作集策略或 PFF 算法。还有人提出了 L=S
准则，通过调整系统并发度，来使缺页中断之间的平均时间等于处理一次缺页中断所需的平均时间。这样处理器的利用率达到最大。</p>
<p>也可以采用时钟页面置换算法，监视该算法中扫描页框的指针循环缓冲区的速度。速度低于某个给定的最小阈值时，表明出现了如下的一种或两种情况：</p>
<ol type="1">
<li>很少发生缺页中断，因此很少需要请求指针前进</li>
<li>对每个请求，指针扫描的平均页框数很小，表明有许多驻留页未被访问到，且均易于被置换</li>
</ol>
<p>在上述情况下，系统并发度可以安全的增加，另一方面，指针扫描速度超过某个阈值，表明缺页率很高，要么难以找到可置换页，说明系统并发度过高</p>
<p>系统并发度减小时，一个或多个当前驻留进程须被挂起（换出），可根据以下标准换出进程：</p>
<ul>
<li><strong>最低优先级进程</strong>：实现调度策略决策，与性能无关</li>
<li><strong>缺页中断进程</strong>：原因在于很有可能是中断任务的工作集还未驻留，因而挂起它对性能的影响最小。此外，由于它阻塞了一个一定会被阻塞的进程，并且消除了页面置换和I/On操作的开销，可以立即收到成效</li>
<li><strong>最后一个被激活的进程</strong>：这个进程的工作集最有可能还未驻留</li>
<li><strong>驻留集最小的进程</strong>：在将来再次装入时的代价最小，不利于局部性较小的程序</li>
<li><strong>最大空间的进程</strong>：可在过来使用的内存中得到最多的空闲页框，使它不会很快又处于去活状态</li>
<li><strong>具有最大剩余执行窗口的进程</strong>：类似最短处理时间优先的调度原则</li>
</ul>
<h2 id="第四部分-调度">第四部分 调度</h2>
<h3 id="第九章-单处理器调度">第九章 单处理器调度</h3>
<hr />
<p>多道程序设计系统中，需要提高处理器处理效率，所以需要合理的调度策略以达到效率的最大化。多道程序涉及的关键就是调度，典型的调度类型有四种，处
I/O 调度外其它三种调度类型都属于处理器调度</p>
<ul>
<li><strong>长程调度</strong>：决定加入待执行进程池</li>
<li><strong>中程调度</strong>：决定加入部分或全部位于内存中的进程集合</li>
<li><strong>短程调度</strong>：决定处理器执行哪个可运行进程</li>
<li><strong>I/O调度</strong>：决定I/O设备处理哪个进程挂起的I/O请求</li>
</ul>
<p>长程调度和中程调度主要由于系统并发度相关的性能驱动，这些在前面的章节就讨论过</p>
<h4 id="处理器调度的类型">9.1 处理器调度的类型</h4>
<p>处理器调度的目的是，<strong>以满足系统目标（响应时间、吞吐率、处理器效率）的方式，把进程分配到一个或多个处理器上执行</strong>。</p>
<p>调度的层次结构以及进程状态和其所属调度种类如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/01.jpg" /></p>
<p>调度决定哪个进程须等待、哪个进程能继续运行，因此会影响系统的性能。本质上说调度属于队列管理，用于在排队环境中减少延迟并优化性能。</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/02.jpg" /></p>
<h5 id="长程调度">长程调度</h5>
<hr />
<p>长程调度决定哪个程序可以进入系统中处理，因此它控制了系统的并发度。调度程序必须决定操作系统
<strong>何时</strong>
才能接纳一个进程或多个进程；同时，调度程序必须决定接受哪个作业或哪些作业，并将其转变为进程。</p>
<p>何时创建一个新进程，通常由要求的系统并发度驱动，下次允许哪个作业进入决策可基于简单的先来先服务（FCFS）原则，或者其它基于管理系统性能的根据。</p>
<h5 id="中程调度">中程调度</h5>
<hr />
<p>中程调度是交换功能的一部分。典型情况下，换入决定取决于管理系统并发度的需求，在不使用虚存的系统中，存储管理也是个问题。因此换入决策将考虑换出进程的存储需求。</p>
<h5 id="短程调度">短程调度</h5>
<hr />
<p>长程调度程序执行的频率相对较低。短程调度程序，也称为分派程序（dispatcher）执行最为频繁，精确的决定下次执行哪个进程。</p>
<p>导致当前进程阻塞或抢占当前运行进程的事件发生时，调用短程调度程序，包括：</p>
<ul>
<li>时钟中断</li>
<li>I/O 中断</li>
<li>操作系统调用</li>
<li>信号（如信号量）</li>
</ul>
<h4 id="调度算法">9.2 调度算法</h4>
<h5 id="短程调度规则">短程调度规则</h5>
<hr />
<p>短程调度的主要目标是按照优化系统一个或多个方面行为的方式，来分配处理器时间。</p>
<p>常用的规则可按两个维度来分类</p>
<ol type="1">
<li>面向用户的规则和面向系统的规则
<ul>
<li>面向用户的规则与单个用户或进程感知到的系统行为相关，例如交互式系统中的响应时间</li>
<li>面向系统则注重处理器使用的效果和效率，如吞吐量</li>
</ul></li>
<li>是否与性能直接相关维度
<ul>
<li>与性能直接相关，如响应时间和吞吐量</li>
<li>与性能无关，不易测量或者定性规则</li>
</ul></li>
</ol>
<p>下表总结了几种重要的调度规则，相互依赖，不可能同时达到最优，比如提供较好的响应时间可能需要调度算法在进程间频繁切换，但也会增加系统开销，降低吞吐量。</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/03.jpg" /></p>
<h5 id="优先级的使用">优先级的使用</h5>
<hr />
<p>可以为每个进程指定一个优先级，调度程序总是优先选择具有较高优先级的进程，纯优先级调度方案可能导致低优先级进程可能会长期处于饥饿状态。可以让一个进程的优先级随时间或执行历史而变化，例如调度算法中的
<strong>反馈</strong> 法</p>
<h5 id="选择调度策略">选择调度策略</h5>
<hr />
<p>有以下三个参数：</p>
<ul>
<li><em>w</em>：目前为止在系统中的停留时间</li>
<li><em>e</em>：目前位置花费的执行时间</li>
<li><em>s</em>：进程所需的服务总时间</li>
</ul>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/04.jpg" /></p>
<ul>
<li><strong>非抢占</strong>：一旦进程处于运行状态，就会不断执行直到终止。进程要么因为等待I/O，要么因为请求某些操作系统服务而阻塞自己</li>
<li><strong>抢占</strong>：当前正运行进程可能被操作系统中断，并转换为就绪态</li>
</ul>
<p>与非抢占策略相比，抢占策略虽然会导致较大的开销，但能为所有进程提供较好的服务，因为它们避免了任何一个进程长时间独占处理器的情形。</p>
<p><strong>周转时间（turnaround time）</strong>：就是驻留时间 <span
class="math inline">\(T_r\)</span>
，或这一项在系统中花费的总时间（等待时间+服务时间），另外有用的是归一化周转时间，为周转时间与服务时间的比值，<strong>表示一个进程的相对延迟情况</strong>。</p>
<p>下面是一个例子：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/05.jpg" /></p>
<p>调度策略的比较如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/06.jpg" /></p>
<p>各个策略的效率的简单度量：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/07.jpg" /></p>
<h5 id="先来先服务-fcfs">先来先服务 FCFS</h5>
<hr />
<p>FCFS
是长进程友好的，而且相对于I/O密集进程，更有利于处理器密集型进程，其它进程，FCFS可能导致处理器和I/O设备都未得到充分利用。</p>
<p>FCFS
自身对于单处理器系统而言并不是很有吸引力的选择，但它与优先级策略结合后通常能提供一种更有效的调度方法，如反馈。</p>
<h5 id="轮转-round-robin">轮转 Round Robin</h5>
<hr />
<p>根据<strong>时间片（time
slicing）</strong>周期性的产生时钟中断，出现中断后将进程放置到就绪队列中，然后基于FCFS策略选择下一个就绪作业运行。</p>
<p>轮转法对处理器密集型进程和I/O密集进程的处理不同。处理器密集型进程在执行过程中通常会使用大部分处理器时间，导致I/O密集型进程性能降低，使用I/O设备低效，响应时间变化较大。</p>
<p>虚拟轮转法，这种方法可以避免上述不公平性，此方法的不同之处在于，接触了I/O阻塞的进程都会转移到一个FCFS辅助队列中。进行调度决策时，辅助队列中的决策优先于就绪队列中的进程，这种方法在公平性方面确实优于轮转法</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/08.jpg" /></p>
<h5 id="最短进程优先-shortest-process-next-spn">最短进程优先 （Shortest
Process Next， SPN）</h5>
<hr />
<p>SPN是非抢占的，短进程友好的，SPN的难点在于需要直到或至少需要估计每个进程所需的处理时间。对于批处理作业，系统要求程序员给出估计值，若执行时间远高于实际运行时间，系统可能终止该作业。实际中操作系统可为每个进程保留一个运行平均值，计算方法如下：
<span class="math display">\[
S_{n+1} = \frac{1}{n}T_n+\frac{n-1}{n}S_n \\
T_i:第i个实例的处理器执行时间 \\
S_i:第i个实例的预测值
\]</span>
这属于<strong>指数平均法</strong>的一种，SPN的风险在于，长进程可能饥饿。</p>
<h5 id="最短剩余时间shortest-remaining-timesrt">最短剩余时间（Shortest
Remaining Time，SRT）</h5>
<hr />
<p>相当于是在SPN中增加了抢占机制的策略，和SPN一样，调度程序在执行选择函数的时候，必须具备关于处理时间的估计，并且具有长进程饥饿的风险。</p>
<p>SRT不像FCFS那样偏向长进程，也不像轮转法那样产生额外的中断，所以降低了开销。但是它必须记录过去的服务时间，又增加了开销，对于SPN，从周转时间上看，SRT性能更好，因为相当于一个正在运行的长作业而言，短作业可以立即选择执行。</p>
<h5 id="最高响应比优先-highest-response-ratio-nexthrrn">最高响应比优先
（Highest Response Ratio Next，HRRN）</h5>
<hr />
<p>调度规则见之前的对比图。HRRN偏向短作业（小分母产生大比值），长进程由于得不到服务等待的时间会不断增加，因此比值变大。所以是比较公平的。</p>
<h5 id="反馈法">反馈法</h5>
<hr />
<p>调度基于抢占原则（按时间片）并使用动态优先级机制。一个进程首次进入系统时，会放在<em>RQ0</em>中当它首次被抢占并返回就绪态时，会放在<em>RQ1</em>中，在随后的时间内，每当它被抢占就降级一次直到最低级。因此，新到的进程和短进程会优于老进程和长进程。这种方法称为<strong>多级反馈（Multilevel
Feedback）</strong>。</p>
<p>但存在一个问题，可能会造成长进程的饥饿。可以按以下办法解决：</p>
<ol type="1">
<li>给低优先级的进程更多的时间片，一般而言，从<em>RQi</em>中调度的进程允许执行
<span class="math inline">\(q=2^i\)</span> 时间后被抢占</li>
<li>当一个进程在其队列等待服务的时间超过一定时间后，就把它提升到优先级高的队列中</li>
</ol>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/09.jpg" /></p>
<h5 id="性能比较">性能比较</h5>
<hr />
<p>略</p>
<h5 id="公平共享调度-fair-share-scheduling">公平共享调度 （Fair-Share
Scheduling ）</h5>
<hr />
<p>公平共享调度考虑了<strong>进程组</strong>调度的基本原则。每个用户（进程组）被指定了某种类型的权值，此<strong>权值定义了用户对系统资源的共享，而且是作为在所有使用资源中所占的比例来体现的，如处理器资源</strong>。</p>
<p>调度是根据优先级进行的，它会考虑三方面因素：</p>
<ol type="1">
<li>进程的基本优先级</li>
<li>近期使用处理器的情况</li>
<li>进程所在组近期使用处理器的情况</li>
</ol>
<p>优先级数值越大，所表示的优先级越低，适用于组<em>k</em>中进程<em>j</em>的公式如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_4/c_9/10.jpg" /></p>
<h2 id="第五部分-输入输出和文件">第五部分 输入/输出和文件</h2>
<h4 id="第十一章-io-管理和磁盘调度">第十一章 I/O 管理和磁盘调度</h4>
<hr />
<h4 id="io-设备">11.1 I/O 设备</h4>
<hr />
<p>计算机系统中参与I/O的外设可以分为以下三类：</p>
<ul>
<li><strong>人可读</strong>：适用于计算机用户间的交互，如打印机和终端</li>
<li><strong>机器可读</strong>：适用于电子设备通信，如磁盘驱动器</li>
<li><strong>通信</strong>：适用于远程设备通信，如调制解调器</li>
</ul>
<p>其中主要差别包括：</p>
<ul>
<li><strong>数据传送速率</strong></li>
<li><strong>应用</strong></li>
<li><strong>控制的复杂性</strong></li>
<li><strong>传送单位</strong>：字节流或者字符流的形式传送，也可按块</li>
<li><strong>数据表示</strong>：不同的数据编码方式</li>
<li><strong>错误条件</strong></li>
</ul>
<h4 id="io-功能的组织">11.2 I/O 功能的组织</h4>
<hr />
<p>执行I/O的三种技术：</p>
<ul>
<li><strong>程序控制I/O</strong>：无中断</li>
<li><strong>中断驱动I/O</strong>：中断</li>
<li><strong>直接存储器访问</strong>：中断，一个DMA模块控制内存和I/O模块之间的数据交换。传送一块数据，处理器给DMA模块发送请求，当整个模块传送结束后，它才被中断，<strong>只有传送的开始和结束才会使用处理器</strong></li>
</ul>
<p>可选的DMA配置如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/01.jpg" /></p>
<h4 id="操作系统设计问题">11.3 操作系统设计问题</h4>
<hr />
<p>两个最重要的目标：</p>
<ul>
<li><strong>效率</strong>：大多数I/O设备的速度非常低，进程交换本身就是I/O操作</li>
<li><strong>通用性</strong>：需要从两个方面统一：一是处理器看待I/O设备的方式，二是操作系统管理I/O设备和I/O操作的方式</li>
</ul>
<h5 id="io-功能的逻辑结构">I/O 功能的逻辑结构</h5>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/02.jpg" /></p>
<h4 id="io-缓冲">11.4 I/O 缓冲</h4>
<p>为避免多余的开销和低效操作，在输入请求发出前就开始执行输入传送，并且在输出请求发出一段时间后才开始执输出传送，这样的技术称为<strong>缓冲</strong>。</p>
<p>两类I/O设备：</p>
<ul>
<li><strong>面向块</strong>：将信息保存在块中，块的大小通常是固定的</li>
<li><strong>面向流</strong>：设备以字节流的方式输入输出数据</li>
</ul>
<p>I/O缓冲方案：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/03.jpg" /></p>
<p>缓冲的作用：</p>
<p><strong>缓冲是用来平滑I/O需求的峰值的一种技术</strong>，但在进程的平均需求大于I/O设备的服务能力时，再多的缓冲也无法让I/O设备与进程一直并驾齐驱。</p>
<p>在多道程序设计中，当存在多种I/O活动和多种进程活动时，<strong>缓冲是提高操作系统效率和单个进程性能的一种方法</strong></p>
<h4 id="磁盘调度">11.5 磁盘调度</h4>
<h5 id="磁盘性能参数">磁盘性能参数</h5>
<hr />
<p>磁盘驱动器工作时，磁盘以某个恒定的速度旋转，为了读或写，磁头必须定位于指定磁道和该磁道中指定扇区的开始处。磁头定位到磁道所需要的时间称为<strong>寻道时间</strong>，之后，磁盘控制器开始等待直到适当的扇区旋转到磁头处，这段时间称为<strong>旋转延迟</strong>，<strong>寻道时间和旋转延迟的总和为存取时间</strong>，这是达到读或写位置所需要的时间，之后便开始执行读操作或写操作，这段时间就是<strong>传输时间</strong>。</p>
<p>总平均存取时间包括上面的三个，可用公式表示 <span
class="math display">\[
T_a = T_s + \frac{1}{2r}+\frac{b}{rN} \\
T_s
为平均寻道时间，b表示传输的字节数，N表示一个磁道的字节数，r表示旋转速度（转/秒）
\]</span> 时序比较的经典例子：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/04.jpg" /></p>
<h5 id="磁盘调度策略">磁盘调度策略</h5>
<hr />
<p>磁盘调度算法及其比较：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/07.jpg" /></p>
<p>访问的磁道序列为：55、58、39、18、90、160、150、38、184</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/05.jpg" /></p>
<p>除此之外，还有<strong>基于优先级（PRI）</strong>和<strong>后进先出</strong>的算法</p>
<p><strong>基于优先级</strong>并不会优化磁盘的利用率，但能满足操作系统的其它目标。通常较短的批作业和交互作业的优先级较高，而较长计算时间的长作业优先级较低。对于数据库系统这类策略往往使得性能较差。</p>
<p><strong>后进先出</strong>在事务处理系统中，由于顺序读取文件，可减少磁壁的运动，可以提高吞吐量并缩短队列长度，但可能会导致饥饿。</p>
<h4 id="raid">11.6 RAID</h4>
<p>略</p>
<h4 id="磁盘高速缓存">11.7 磁盘高速缓存</h4>
<p>磁盘高速缓存是内存中为磁盘扇区设置的一个缓冲区，包含磁盘中某些扇区的副本</p>
<p>进程从磁盘高速缓存中获取数据可以采取两种方式</p>
<ol type="1">
<li>在内存中把这一块数据缓存传送到用户进程的存储空间中</li>
<li>简单使用一个共享内存，传送指向磁盘告诉缓冲中响应的指针</li>
</ol>
<p>后一种方法节省了内存到内存的传输时间</p>
<p>对于<strong>置换策略</strong>可以以下两种：</p>
<ul>
<li><strong>最近最少使用（LRU）</strong>：置换在高速缓存中未被访问时间最长的块，可用一个栈完成</li>
<li><strong>最不常使用（LFU）</strong>：置换集合中访问次数最少的块</li>
</ul>
<p>简单的LFU不能判断那些整体很少访问但是近期访问频繁的块，可以使用LFU的改进版</p>
<p>使用分区，新区老区（中间区），对不同区的对应措施不同</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_11/06.jpg" /></p>
<h3 id="第十二章-文件管理">第十二章 文件管理</h3>
<p>典型情况下，文件管理系统由系统实用程序组成，它们可以作为具有特权的应用程序来运行。一般来说，整个文件管理系统都被当做操作系统的一部分</p>
<h4 id="概述">12.1 概述</h4>
<h5 id="文件和文件系统">文件和文件系统</h5>
<hr />
<p>文件有以下理想的属性：</p>
<ul>
<li>长期存在</li>
<li>可在进程间共享</li>
<li>结构</li>
</ul>
<p>文件的操作如下：</p>
<ul>
<li>创建</li>
<li>删除</li>
<li>打开</li>
<li>关闭</li>
<li>读</li>
<li>写</li>
</ul>
<h5 id="文件结构">文件结构</h5>
<hr />
<ul>
<li><strong>域</strong>：基本的数据单元，一个域包含一个值，域的长度是定长或者变长的，取决于文件的设计</li>
<li><strong>记录</strong>：是一组相关域的集合，可视为应用程序的一个单元</li>
<li><strong>文件</strong>：一组相似记录的集合，被用户和应用程序视为一个实体，并通过文件名访问</li>
<li><strong>数据库</strong>：一组相关数据的集合，数据元素间存在着明确的关系，且可供不同应用程序使用，数据库管理系统独立于操作系统</li>
</ul>
<p>文件系统架构：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/01.jpg" /></p>
<p>文件管理的要素：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/02.jpg" /></p>
<p>文件管理系统作为一个单独的系统实用程序和操作系统关注的是不同两方面的内容，之间的共同点是记录的处理。</p>
<h4 id="文件组织和访问">12.2 文件组织和访问</h4>
<p>在选择文件组织，有以下重要原则：</p>
<ul>
<li>快速修改</li>
<li>易于修改</li>
<li>节约存储空间</li>
<li>维护简单</li>
<li>可靠性</li>
</ul>
<p>这些原则的优先级取决于将要使用这些文件的应用程序</p>
<p>基本文件组织：</p>
<ul>
<li><strong>堆</strong>：<strong>是简单的文件组织形式</strong>，数据按它们到达的顺序被收集，每条记录由一串数据组成。堆的目的仅是积累大量的数据并保存，对文件没有结构，使用穷举查找的方式进行，当数据难以组织或在初期前采集数据时会用到。</li>
<li><strong>顺序文件</strong>：<strong>是最常用的文件组织形式</strong>，每条记录都使用固定的格式，所有记录具有相同的长度，并由相同数量、长度固定的域按特定顺序组成。每条记录的第一个域通常是<strong>关键域</strong>，唯一的标识这条记录，性能很差，也可组织成链表的方式。</li>
<li><strong>索引顺序文件</strong>：用于克服顺序文件的缺点，增加了两个特征：用于支持随机访问的文件索引和溢出文件。索引顺序文件极大的减少了访问单条记录的时间，同时保留了文件的顺序特性，多级索引可以提供更有效的访问</li>
<li><strong>索引文件</strong>：索引顺序文件保留了顺序文件的一个限制：基于文件的一个域进行处理。当需要基于其它属性而非关键域查找一条记录时，这两种形式的顺序文件都无法胜任。索引文件采取多索引的结构，摒弃了顺序性和关键字的概念，只能通过索引来访问记录。对记录的位置不再有限制，还可使用长度可变的记录。</li>
<li><strong>直接或散列文件</strong>：直接访问磁盘中任何一个地址已知块的能力。直接文件使用基于关键字的散列，直接文件常在要求快速访问时使用，且记录的长度是固定的，通常一次访问一条记录。</li>
</ul>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/03.jpg" /></p>
<h4 id="文件目录">12.4 文件目录</h4>
<p>目录包含关于文件的信息，如属性、位置、所有权，都由操作系统管理。</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/04.jpg" /></p>
<p>目录的结构通常是树状结构：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/05.jpg" /></p>
<h4 id="文件共享">12.5 文件共享</h4>
<p>文件共享会产生两个问题：<strong>访问权限</strong>和<strong>同时访问的管理</strong>。</p>
<p>访问权限有如下：</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/06.jpg" /></p>
<p>话可以按面向用户分组：特定用户，用户组，全部</p>
<p>对于同时访问，必须解决互斥和死锁问题</p>
<h4 id="记录组块">12.6 记录组块</h4>
<p>记录是访问结构化文件的逻辑单元，而块是与辅存进行I/O操作的基本单位，为执行I/O，记录必须组织成块。</p>
<p>对于给定的块大小，有三种组块方法：</p>
<ul>
<li><strong>定长组块</strong>：使用定长的记录，且若干完整的记录保存在一个块中，块末尾可能会有未使用空间，称为内部碎片</li>
<li><strong>变长跨越式组块</strong>：使用变长的记录，并紧缩到块中，块中不存在未使用的空间，某些记录会跨越两个块，使用指针连接</li>
<li><strong>变长非跨越式组块</strong>：使用变长的记录，但不采用跨越方式，在大多数块中都会有未使用的空间</li>
</ul>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/07.jpg" /></p>
<p>定长组块是记录定产顺序文件最常用的方式，变长跨越式存储效率高，但难以实现。跨越两个块需要两次I/O操作，文件很难修改。变长非跨越式浪费空间，且存在记录大小不能超过块大小的限制。</p>
<h4 id="辅存管理">12.7 辅存管理</h4>
<p>在辅存中，文件是由许多块组成。操作系统负责为文件分配块。</p>
<h5 id="文件分配">文件分配</h5>
<hr />
<ul>
<li><strong>预分配</strong>：在发出创建文件的请求时，声明该文件的最大尺寸</li>
<li><strong>动态分配</strong>：只有在需要的时候才给文件分配空间</li>
</ul>
<p>对于分配给文件的<strong>分区大小</strong>，我们需要考虑下面四项内容：</p>
<ol type="1">
<li>邻近空间可以提高性能</li>
<li>数量较多的小分区会增加</li>
<li>使用固定大小的分区可以简化空间的再分配</li>
<li>使用可变大小的分区或固定大小的小分区，可减少超额分配导致未使用存储空间的浪费</li>
</ol>
<p>有以下两个选择：</p>
<ul>
<li><strong>大小可变的大规模连续分区</strong>：大小可变避免了浪费，且会使文件分配表较小，但着会导致空间很难再次利用</li>
<li><strong>块</strong>：小的固定分区能提供更大的灵活性，但为了分配，它们可能需要较大的表或更复杂的结构</li>
</ul>
<p>选择策略有：</p>
<ul>
<li>首次适配</li>
<li>最佳适配</li>
<li>最近适配</li>
</ul>
<h5 id="文件分配方法">文件分配方法</h5>
<hr />
<p><strong>连续分配</strong>：创建文件时，给文件分配一组连续的块。需要在创建文件时声明文件的大小，会出现外部碎片，所以需要紧缩算法</p>
<p><strong>链式分配</strong>：链式分配基于单个块，使用指针建立联系，不必担心外部碎片的出现，但是局部性原理不再适用，为了克服这个问题，有些系统会周期性的合并文件</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/08.jpg" /></p>
<p><strong>索引分配</strong>：解决了连续分配和链式分配中的许多问题。每个问价在文件分配表中都有一个一级的索引，分配给该文件的每个分区在索引中都有一个表项。</p>
<p><img
src="/assets/Note/Operating-System-Internals-and-Design-Principles-8th/part_5/c_12/09.jpg" /></p>
<h5 id="空闲空间管理">空闲空间管理</h5>
<p>除了文件分配表外，还需要<strong>磁盘分配表（Disk Allocation
Table，DAT）</strong></p>
<ul>
<li><strong>位表</strong>：使用一个向量值00111000标识空闲块，通过它能相对容易的找到一个或一组连续的空闲块，而且很小，但其长度仍然很长。</li>
<li><strong>链接空闲区</strong>：使用指向每个空闲区的指针和它们的长度值，链接在一起，开销很小。使用一段时间后，会出现许多碎片。删除一个由许多碎片组成的文件也非常耗时</li>
<li><strong>索引</strong>：索引方法把空闲空间视为一个文件，并使用一个索引表，索引基于可变大小的分区而非块</li>
<li><strong>空闲块列表</strong>：每块都指定一个序号，所有空闲块序号保存在磁盘的一个保留区中。</li>
</ul>
<p><strong>卷</strong>：一组分配在可寻址的扇区的集合，操作系统或应用程序用卷来存储数据。卷中的扇区在物理存储设备上不需要连续，只需要对操作系统或应用程序来说连续即可。卷可能由更小的卷合并或组合而成。最简单的情况下，一个单独的磁盘就是一个卷，通常一个磁盘会分为几个分区，每个分区都作为一个单独的卷来工作。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径</title>
    <url>/2020/04/02/2020-04-02-tree-diameter/</url>
    <content><![CDATA[<p>树的直径，即<strong>树中距离最远的两个节点的距离</strong>。</p>
<h2 id="求解方法">求解方法</h2>
<p>选取树中的任意一个节点，计算距离它最远的节点（使用DFS或者BFS），然后以这个最远的节点为根计算距离它最远的节点。这段距离即为树的直径，根和此最远的点便是两个端点。</p>
<span id="more"></span>
<h2 id="简单证明">简单证明</h2>
<p>其实只要证明：<strong>以任意点为根节点，距离此根节点最远的节点必定是树的直径中的一个端点。</strong></p>
<p>证明了这个，那么上面提到的算法就很容易证明了，获取第一个端点，然后以此端点为根的最远端点就是另外一个端点。</p>
<p>首先规定从<em>r</em>开始的最远距离节点为<em>u</em>，证明<em>u</em>为树的直径的一个端点，可以使用反证法证明，假设存在另外两个节点<em>s,t</em>，构成了树的直径。</p>
<ol type="1">
<li><p><strong><em>st</em>的路径和<em>ru</em>不相交</strong>：</p>
<p>在这种情况下，存在<span class="math inline">\(dis(u,s)+dis(s,t) &gt;
dis(s,t)\)</span>，所以<em>st</em>并不是最长的，和假设相矛盾，<em>st</em>这种情况下不存在</p></li>
<li><p><strong><em>st</em>的路径和<em>ru</em>相交于点<em>v</em>：</strong></p>
<p>此时<em>s,u</em>都是以<em>a</em>为根的子树上的节点，因为u为距离a最远的结点所以可得：
<span class="math display">\[
dis(a,y)+dis(y,u) &gt; dis(a,y)+dis(y,s) \\
即：dis(u,y) &lt; dis(s,y)
\]</span> 同样表示<em>s,t</em>并不是最长的，而是<em>u,t</em></p></li>
</ol>
<p>综上，<em>u</em>必定为树的直径的一个端点。</p>
<p>关于树的直径的更多性质可参考：<a
href="https://www.cnblogs.com/Khada-Jhin/p/10195287.html">博客园
树的直径及其性质与证明</a></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>飞行模拟机的自动视景融合校正系统，省级大学生创新创业项目，效果展示</title>
    <url>/2020/04/01/2020-04-01-big-innovation/</url>
    <content><![CDATA[<blockquote>
<p>项目环境：Python 3.7</p>
<p>开发环境：Visual Studio Code</p>
<p>库依赖：</p>
<ul>
<li>matplotlib</li>
<li>numpy</li>
<li>opencv (cv2)</li>
</ul>
</blockquote>
<span id="more"></span>
<h2 id="cubic-spline-interpolation-三次样条插值">Cubic Spline
Interpolation 三次样条插值</h2>
<blockquote>
<p>输入N个控制点，通过样条插值模拟出通过这N个点的光滑曲线</p>
</blockquote>
<h3 id="原理参考">原理参考</h3>
<p>主要原理可参考：<em>https://www.cnblogs.com/liuyunfeifei/articles/3110140.html</em></p>
<h3 id="作用">作用</h3>
<p>可作为几何校正曲线模拟函数（暂时几何校正还使用贝塞尔曲线模拟）</p>
<p>还可作为边缘融合重合地带的亮度调整函数</p>
<h3 id="代码简介">代码简介</h3>
<h4 id="三次曲线类">三次曲线类</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CubicLine</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    三次曲线类 </span></span><br><span class="line"><span class="string">    形如：y = a + b(x-xi) + c(x-xi)^2 + d(x-xi)^3</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c, d, xi</span>):</span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line">        self.c = c</span><br><span class="line">        self.d = d</span><br><span class="line">        self.xi = xi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getResult</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.a + self.b*(x - self.xi) + self.c*((x - self.xi)**<span class="number">2</span>) + self.d*((x - self.xi)**<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h4 id="三次样条">三次样条</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CubicSpline</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    三次样条类，通过给定的控制点形成曲线</span></span><br><span class="line"><span class="string">    @Attrs:</span></span><br><span class="line"><span class="string">        points: 控制点数组</span></span><br><span class="line"><span class="string">        H: 步长数组</span></span><br><span class="line"><span class="string">        m: 求解数组</span></span><br><span class="line"><span class="string">        cubicLines: 最后的三次样条分段函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, points: np.ndarray</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; 接受一个节点数组 &#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setPoints</span>(<span class="params">self, points: np.ndarray</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; 重新更新控制点(节点数组) &#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">pass</span>      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; 求解  M * m = b&#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getS</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; 获取曲线段分段表达式 &#x27;&#x27;&#x27;</span></span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="演示效果">演示效果</h3>
<blockquote>
<p>通过matplotlib展示构建的样条函数
并通过设置相应的回调函数实现交互输入</p>
</blockquote>
<p><img src="/assets/ArticleImg/2020/cubicSplineInterpolation.png" style="zoom:50%;" /></p>
<h2 id="edge-fusion-边缘融合">Edge Fusion 边缘融合</h2>
<blockquote>
<p>想要两个投影机的投影图像没有边缘界线，必然需要重叠中间一部分，这是<strong>生成无缝拼接的需要</strong></p>
<p>需要构建合适的边缘融合函数以此抵消重合带的亮度改变</p>
</blockquote>
<h3 id="原理介绍">原理介绍</h3>
<p><img src="/assets/ArticleImg/2020/edgeFusion1.png" style="zoom:50%;" /></p>
<p>中间的融合带不加处理的化必定会造成亮度叠加，会造成亮度突变</p>
<p>如图：在融合带边缘尤为明显</p>
<ul>
<li><p>原图：从左到右亮度逐渐增加的灰度图</p>
<p><img src="/assets/ArticleImg/2020/edgeFusion3.png" style="zoom:50%;" /></p></li>
<li><p>直接叠加：中间亮度突变</p>
<p><img src="/assets/ArticleImg/2020/edgeFusion4.png" style="zoom:50%;" /></p></li>
</ul>
<p>所以我们需要将左通道和右通道的融合区域进行预处理之后然后叠加</p>
<p>刚刚开始我的思路是左边融合带和右边融合带亮度都衰减为原来的50%那么叠加起来就和原图一样了，这里有个错误的判断，这个前提是两个投影机的亮度输出必须完全一致，但在实际里，两个投影机的输出亮度都是不同的，所以融合函数是简简单单的常数函数是不行的，必须是要满足渐变这个前提条件</p>
<h4 id="不同的投影机亮度输出的效果图">不同的投影机亮度输出的效果图</h4>
<blockquote>
<p>这里采用左通道亮度为原图的0.7倍，而右通道为原图的1.3倍</p>
</blockquote>
<p>可以看出效果特别不好甚至是没有任何改善</p>
<p><img src="/assets/ArticleImg/2020/edgeFusion5.png" style="zoom:50%;" /></p>
<p>当使用比较常见的融合分段函数时，效果如下，这样就不存在亮度跳变了</p>
<p><img src="/assets/ArticleImg/2020/edgeFusion6.png" style="zoom:50%;" /></p>
<p>融合函数具体为：</p>
<p><img src="/assets/ArticleImg/2020/edgeFusion7.png" style="zoom:100%;" /></p>
<p>改变参数的效果：可以看出<strong>a控制的是分段函数连接点，p控制的幂函数的次数</strong></p>
<p>右侧函数值就是<strong>1-左侧函数值</strong></p>
<p><img src="/assets/ArticleImg/2020/edgeFusion8.png" style="zoom:100%;" /></p>
<h3 id="代码概览">代码概览</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">edgeFusion</span>(<span class="params">img: np.ndarray, brightL, brightR, f</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    @Args</span></span><br><span class="line"><span class="string">        img: 输入图像 此示例为将输入图像分割为左2/3和右2/3中间融合带1/3来演示不同融合函数效果</span></span><br><span class="line"><span class="string">        brightL: 左侧亮度调整参数</span></span><br><span class="line"><span class="string">        brightR: 右侧亮度调整参数</span></span><br><span class="line"><span class="string">        f：融合函数</span></span><br><span class="line"><span class="string">    @Return</span></span><br><span class="line"><span class="string">        newimg: 融合完成的图像</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rows, cols = img.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    bk = np.zeros(img.shape)</span><br><span class="line">    img = img.astype(bk.dtype)</span><br><span class="line">    tape = <span class="number">1</span>/<span class="number">3</span>  <span class="comment"># 融合带占图片的1/3</span></span><br><span class="line"></span><br><span class="line">    xL = <span class="built_in">int</span>(cols * (<span class="number">1</span>/<span class="number">2</span> + tape/<span class="number">2</span>)) <span class="comment"># 左投影的边界</span></span><br><span class="line">    xR = <span class="built_in">int</span>(cols * (<span class="number">1</span>/<span class="number">2</span> - tape/<span class="number">2</span>)) <span class="comment"># 右投影的边界</span></span><br><span class="line">    tapeL, tapeR = xR, xL</span><br><span class="line">    </span><br><span class="line">    imgL, imgR = img[:, :xL].copy(), img[:, xR:].copy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 左侧图像处理</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(tapeL, xL):</span><br><span class="line">        value = f((i - tapeL)/(tapeR - tapeL))</span><br><span class="line">        value = <span class="number">1</span> - value</span><br><span class="line">        imgL[:, i] = imgL[:, i]*value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 右侧图像处理</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, tapeR - tapeL):</span><br><span class="line">        value = f(i/(tapeR - tapeL))</span><br><span class="line">        imgR[:, i] = imgR[:, i]*value</span><br><span class="line"></span><br><span class="line">    bk = bk.astype(np.uint8)</span><br><span class="line">    imgL = imgL.astype(np.uint8)</span><br><span class="line">    imgR = imgR.astype(np.uint8)</span><br><span class="line">    <span class="comment"># 叠加图像</span></span><br><span class="line">    bk[:, :xL] = cv2.addWeighted(bk[:, :xL], <span class="number">1</span>, imgL, brightL, <span class="number">0</span>)</span><br><span class="line">    bk[:, xR:] = cv2.addWeighted(bk[:, xR:], <span class="number">1</span>, imgR, brightR, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bk.astype(np.uint8)</span><br></pre></td></tr></table></figure>
<h3 id="彩色图像演示">彩色图像演示</h3>
<ul>
<li><p>原图以及常数融合函数 左通道亮度0.7;右通道亮度1.3</p>
<p><img src="/assets/ArticleImg/2020/edgeFusion9.png" style="zoom:100%;" /></p></li>
<li><p>分段融合函数：a = 0.7 p = 2</p>
<p><img src="/assets/ArticleImg/2020/edgeFusion10.png" style="zoom:50%;" /></p></li>
</ul>
<p>演示中窗口设置了滑条可以实时调整融合函数参数以便交互</p>
<h2 id="geometric-correction-几何校正">Geometric correction
几何校正</h2>
<blockquote>
<p>从原图到投影机到幕布会发生变换，所以我们需要对原图进行反变换来使最终图像显示正常</p>
</blockquote>
<h3 id="原理介绍-1">原理介绍</h3>
<p>图像的连续的，我们只要确定四条边界就可以确定最终的图像，这就需要我们可以对边界进行任意改变，这就需要通过控制点改变边界以生成曲线</p>
<p>生成四条边界曲线后，然后将原图像映射到新的图像区域中即可</p>
<h4 id="边界曲线">边界曲线</h4>
<p>这里采用的是三阶贝塞尔曲线，通过四个控制点就可以生成任意的三阶函数曲线如下图（是一个动图PDF查看不了）</p>
<p><img src="/assets/ArticleImg/2020/transform1.gif" /></p>
<h4 id="划分网格">划分网格</h4>
<p>需要将原图划分为N个矩形区域，如图：</p>
<p><img src="/assets/ArticleImg/2020/transform2.png" style="zoom:80%;" /></p>
<h4 id="网格点重映射">网格点重映射</h4>
<p>然后通过调整控制点生成新的边界点，然后通过以下公式更新网格点</p>
<p><img src="/assets/ArticleImg/2020/transform3.png" style="zoom:100%;" /></p>
<p>新的网格点如下：<strong>蓝色点为控制点</strong></p>
<p><img src="/assets/ArticleImg/2020/transform4.png" style="zoom:80%;" /></p>
<h4 id="纹理映射">纹理映射</h4>
<p>然后只需要对每一个区域做一个纹理映射即可，这里用的是opencv带的仿射变换，但会出现最后拼接是出现锯齿或者是亮条的缺点，后期可以直接使用openGL或者direct3D直接进行纹理变换</p>
<h3 id="代码概览-1">代码概览</h3>
<blockquote>
<ul>
<li>bezier.py：贝塞尔曲线</li>
<li>copyToQuadrangle.py：纹理映射函数</li>
<li>transform.py：旧的几何变换demo</li>
<li>test.py：新的几何变换demo</li>
</ul>
</blockquote>
<h4 id="三阶贝塞尔">三阶贝塞尔</h4>
<blockquote>
<p>类定义在文件bezier.py中</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bezier</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 提供四个控制点和一个分段数 返回三阶贝塞尔曲线点集 &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, P0, P1, P2, P3</span>):</span><br><span class="line">        self.P0 = np.array(P0).reshape(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">        self.P1 = np.array(P1).reshape(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">        self.P2 = np.array(P2).reshape(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">        self.P3 = np.array(P3).reshape(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPoints</span>(<span class="params">self, numbers</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> np.linspace(<span class="number">0</span>, <span class="number">1</span>, numbers):</span><br><span class="line">            res.append(self.getDetailPos(i))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> np.array(res).reshape(-<span class="number">1</span>, <span class="number">2</span>).astype(np.int32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getDetailPos</span>(<span class="params">self, t</span>):</span><br><span class="line">        <span class="keyword">return</span> ((<span class="number">1</span> - t)**<span class="number">3</span>)*self.P0 + <span class="number">3</span>*t*(<span class="number">1</span> - t)*(<span class="number">1</span> - t)*self.P1 + <span class="number">3</span>*t*t*(<span class="number">1</span> - t)*self.P2 + (t**<span class="number">3</span>)*self.P3</span><br></pre></td></tr></table></figure>
<h4 id="纹理映射-1">纹理映射</h4>
<blockquote>
<p>有两个纹理映射</p>
<ol type="1">
<li>原图是任意四边形映射到目标图的任意四边形:copyToQuadrangle</li>
<li>原图是规则矩形映射到目标图的任意位置:copyToQuadrangleWithRegular</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyToQuadrangle</span>(<span class="params">srcImg: np.ndarray, tarRect1, desImg: np.ndarray, tarRect2</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将 srcImg 的指定四边形区域 复制到desImg的指定区域</span></span><br><span class="line"><span class="string">    出现边缘锯齿</span></span><br><span class="line"><span class="string">    但内部整合效果好</span></span><br><span class="line"><span class="string">    @Param:</span></span><br><span class="line"><span class="string">        desImg: 目标图像</span></span><br><span class="line"><span class="string">        srcImg: 源图像</span></span><br><span class="line"><span class="string">        tarRect1: 目标四边形区域，左上角顺时针</span></span><br><span class="line"><span class="string">        tarRect2: 源四边形区域</span></span><br><span class="line"><span class="string">    @Return:</span></span><br><span class="line"><span class="string">        新的图像        </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    srcRows, srcCols = srcImg.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    desRows, desCols = desImg.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    tarRect1 = np.float32(tarRect1)</span><br><span class="line">    tarRect2 = np.float32(tarRect2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 首先创建目标掩码</span></span><br><span class="line">    <span class="comment"># 将整个图像变换到目标区域来创建掩码</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 获取变换后的 ROI 图像</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 处理目标图像 将需要重新贴图的地方置 0</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> cv2.add(midDesImg, tarImg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copyToQuadrangleWithRegular</span>(<span class="params">srcImg: np.ndarray, tarRect1: np.ndarray, desImg: np.ndarray, tarRect2</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将 srcImg 的指定四边形区域 复制到desImg的指定区域</span></span><br><span class="line"><span class="string">    对目前项目 只需要从规则矩形（可以直接提取ROI）仿射至任意四边形即可</span></span><br><span class="line"><span class="string">    可采用此函数避免锯齿</span></span><br><span class="line"><span class="string">    但存在边缘高亮</span></span><br><span class="line"><span class="string">    @Param:</span></span><br><span class="line"><span class="string">        desImg: 目标图像</span></span><br><span class="line"><span class="string">        srcImg: 源图像</span></span><br><span class="line"><span class="string">        tarRect1: 目标四边形区域，左上角顺时针</span></span><br><span class="line"><span class="string">        tarRect2: 源四边形区域</span></span><br><span class="line"><span class="string">    @Return:</span></span><br><span class="line"><span class="string">        新的图像       </span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    srcRows, srcCols = srcImg.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    desRows, desCols = desImg.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 获取原矩形宽度和高度</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 获取ROI图像</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 仿射变换</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="效果展示">效果展示</h3>
<ul>
<li><p>变换前</p>
<p><img src="/assets/ArticleImg/2020/transform5.jpg" style="zoom:100%;" /></p></li>
<li><p>变换后 <code>copyToQuadrangle</code> 纹理映射
这里边缘出现了锯齿</p>
<p><img src="/assets/ArticleImg/2020/transform7.png" style="zoom:100%;" /></p></li>
<li><p>变换后 <code>copyToQuadrangleWithRegular</code>纹理映射
可以看到有亮条</p>
<p><img src="/assets/ArticleImg/2020/transform6.png" style="zoom:100%;" /></p></li>
</ul>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>DIP</category>
      </categories>
      <tags>
        <tag>几何校正</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Index Tree 树状数组</title>
    <url>/2020/05/13/2020-05-13-Binary-Index-Tree/</url>
    <content><![CDATA[<h2 id="树状数组">树状数组</h2>
<p>树状数组是能够完成下述操作的数据结构：</p>
<p>给定一个初始值全为0的数列，<span
class="math inline">\(a_1,a_2,\dots,a_n\)</span></p>
<ul>
<li>给定i，计算<span
class="math inline">\(a_1+a_2+\dots+a_n\)</span></li>
<li>给定i和x，执行<span class="math inline">\(a_i+=x\)</span></li>
</ul>
<p>即单点修改和区间和计算</p>
<span id="more"></span>
<h2 id="原理介绍">原理介绍</h2>
<h3 id="树状数组结构">树状数组结构</h3>
<p><img src="\assets\ArticleImg\2020\bit.png" /></p>
<p>使用大节点保存了多个子节点的信息（区间和信息），如图，<span
class="math inline">\(a_8\)</span>为<span class="math inline">\(a_1 \sim
a8\)</span>的和，<span class="math inline">\(a_6\)</span>则为<span
class="math inline">\(a_5,a_6\)</span>，十分巧妙</p>
<p>其中每个节点的相关节点和其下标对应的二进制有关，与其二进制末尾0的个数有关。其中求<span
class="math inline">\(a_1+a_2+\dots+a_n\)</span>，有以下规律：</p>
<ol type="1">
<li><span class="math inline">\(SUM(2) = a[1]+a[2]\)</span></li>
<li><span class="math inline">\(SUM(3) = a[2] + a[3]\)</span></li>
<li><span class="math inline">\(SUM(4) = a[4]\)</span></li>
<li><span class="math inline">\(SUM(5) = a[4]+a[5]\)</span></li>
<li><span class="math inline">\(SUM(6) = a[4]+a[6]\)</span></li>
</ol>
<p>要获取<span class="math inline">\(SUM[n]\)</span>则必须知道<span
class="math inline">\(SUM(n-(2^{0的个数}))\)</span>，这个 <span
class="math inline">\(2^{0的个数}\)</span> 的个数通过以下函数获取:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用宏实现，x和-x按位相与便可以获得<span
class="math inline">\(2^{num(0)}\)</span></p>
<p>所以获取<span
class="math inline">\(SUM(n)\)</span>，可以由以下代码获取：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        res += nums[n];</span><br><span class="line">        n -= <span class="built_in">lowbit</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于单点更新，从以下结论可以得出方法：</p>
<p>更新点x，则所有包含点x结果的点均要更新，而包含点x的点即为x+lowbit(x)，所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v当然可以是负数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt; maxn) &#123;</span><br><span class="line">        nums[x] += v;   </span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>求解图的连通分量</title>
    <url>/2020/04/06/2020-04-06-connected-components/</url>
    <content><![CDATA[<h2 id="简单定义">简单定义</h2>
<p>有向图中称为，强连通分量。连通图和连通分量都是针对无向图。</p>
<p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(strongly
connected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong>(strongly
connected components)。</p>
<span id="more"></span>
<h2 id="无向图">无向图</h2>
<p>对于无向图而言，只要从一个点开始使用DFS或者BFS遍历所有可以遍历的边，这些遍历到的点集就构成了一个连通分量。然后寻找下一个之前没有遍历的点作为下一个连通分量的根结点，继续进行遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; G[maxn];    <span class="comment">// 邻接表</span></span><br><span class="line"><span class="type">bool</span> visited[maxn];     <span class="comment">// 检查是否遍历完</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历连接图 获得连通分量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    visited[root] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; G[root].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[G[root][i]]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(G[root][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;	<span class="comment">// 连通分量的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= num_nodes;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有向图">有向图</h2>
<p>下面两个算法都是<span
class="math inline">\(O(N+E)\)</span>的复杂度</p>
<h3 id="tarjan算法">Tarjan算法</h3>
<p>可参考：<a
href="https://www.byvoid.com/zhs/blog/scc-tarjan">有向图强连通分量的Tarjan算法</a></p>
<p>算法的基本思想如下：任选一节点开始进行深度优先搜索（<strong>若深度优先搜索结束后仍有未访问的节点，则再从中任选一点再次进行</strong>）。搜索过程中已访问的节点不再访问。搜索树的若干子树构成了图的强连通分量。</p>
<p>节点按照被访问的顺序存入堆栈中。从搜索树的子树返回至一个节点时，检查该节点是否是某一强连通分量的根节点（见下）并将其从堆栈中删除。如果某节点是强连通分量的根，则在它之前出堆栈且还不属于其他强连通分量的节点构成了该节点所在的强连通分量。</p>
<p>算法代码为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tarjan</span>(u)</span><br><span class="line">&#123;</span><br><span class="line">    DFN[u]=Low[u]=++Index                      <span class="comment">// 为节点u设定次序编号和Low初值</span></span><br><span class="line">    Stack.<span class="built_in">push</span>(u)                              <span class="comment">// 将节点u压入栈中 其实就是保存拓扑序</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">each</span> (u, v) in E                       <span class="comment">// 枚举每一条边</span></span><br><span class="line">        <span class="keyword">if</span> (v is <span class="keyword">not</span> visted)                   <span class="comment">// 如果节点v未被访问过</span></span><br><span class="line">            <span class="built_in">tarjan</span>(v)                          <span class="comment">// 继续向下找</span></span><br><span class="line">            Low[u] = <span class="built_in">min</span>(Low[u], Low[v])</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v in S)                       <span class="comment">// 如果节点v还在栈内</span></span><br><span class="line">            Low[u] = <span class="built_in">min</span>(Low[u], DFN[v])</span><br><span class="line">    <span class="keyword">if</span> (DFN[u] == Low[u])                      <span class="comment">// 如果节点u是强连通分量的根</span></span><br><span class="line">        repeat</span><br><span class="line">            v = S.pop                          <span class="comment">// 将v退栈，为该强连通分量中一个顶点</span></span><br><span class="line">            print v</span><br><span class="line">        <span class="built_in">until</span> (u== v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>DFN[u]：为结点u的搜索编号（时间次序）</li>
<li>Low[u]：为结点u和与结点u相连的子树的最小搜索序（最早出现时间）</li>
</ul>
<p>此算法其中判断强连通分量的思路就是，在以u为根节点进行DFS的过程中如果出现一个结点v指向了之前遍历过的点t，即<span
class="math inline">\(u \rightarrow t \rightarrow v \rightarrow
t\)</span>也就表明出现了一个环，其中<span
class="math inline">\(t,v,t\)</span>就构成了环，即连通分量。</p>
<p>其中的DFN就保存每个结点的访问顺序，Low保存相关子树的最早访问时间，在算法回溯的时候更新，可保证一个强连通分量的Low都是一致的，栈保存的是拓扑序，即遍历的次序，不断出栈获取连通分量。</p>
<h3 id="kosaraju算法">Kosaraju算法</h3>
<p>可参考：<a
href="https://www.cnblogs.com/nullzx/p/6437926.html">Kosaraju算法解析:
求解图的强连通分量</a></p>
<p>Kosaraju算法比Tarjan算法看似要简单一些，但效率没有Tarjan算法高，Kosaraju算法依靠DFS遍历获取极大连通子图。但存在一点问题。</p>
<p><img src="\assets\ArticleImg\2020\connected-components-1.png" /></p>
<p>对于上图，从A0开始遍历和B4开始遍历是不一样的结果。如果从B开始遍历，需要2次DFS便可以遍历完整个图，而A0只需要一次。<strong>所以Kosaraju算法的第一个DFS需要获取正确的遍历顺序，</strong>然后第二次DFS的次数便是连通分量的个数了。</p>
<p>上图的反图为：</p>
<p><img src="\assets\ArticleImg\2020\connected-components-2.jpg" /></p>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g 是原图，g2 是反图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : g[u])</span><br><span class="line">    <span class="keyword">if</span> (!vis[v]) <span class="built_in">dfs1</span>(v);</span><br><span class="line">  s.<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  color[u] = sccCnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v : g2[u])</span><br><span class="line">    <span class="keyword">if</span> (!color[v]) <span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kosaraju</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sccCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) <span class="built_in">dfs1</span>(i);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (!color[s[i]]) &#123;</span><br><span class="line">      ++sccCnt;</span><br><span class="line">      <span class="built_in">dfs2</span>(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是两点：</p>
<ol type="1">
<li>后序遍历获取拓扑序，保证BA的相对顺序不会改变</li>
<li>反向原图根据上面获取的遍历顺序，重新DFS</li>
</ol>
<h4 id="反图的作用">反图的作用</h4>
<p>其中的反图很有意思，对于强连通子图，反图和原图并无区别。但对于非强连通的则会有很大的影响。例如<span
class="math inline">\(A \rightarrow B \rightarrow C\)</span>反图为<span
class="math inline">\(A \leftarrow B \leftarrow C\)</span>
从A开始遍历一次便遍历完，但反图后从A开始便需要3次，也就是强连通分量的个数（单个结点也是强连通）。而且反图保证了图的收缩，可参考：<a
href="https://www.zhihu.com/question/265266923/answer/912239192">Kosaraju算法为什么是用图G的反向图的逆后序，而不能是图G的后序？</a></p>
<p><strong>所以通过后续遍历获取遍历结点的顺序，然后通过反图获取强连通分量的个数。</strong></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Graph Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>【STL】next_permutation 算法原理</title>
    <url>/2020/09/24/2020-09-24-next-permutation/</url>
    <content><![CDATA[<blockquote>
<p>参考：</p>
<ul>
<li><a
href="https://www.cnblogs.com/luruiyuan/p/5914909.html">【博客园】 STL
next_permutation 算法原理和自行实现</a></li>
<li><a
href="https://blog.csdn.net/Czyaun/article/details/104420329">【CSDN】next_permutation和pre_permutation源码解析</a></li>
</ul>
</blockquote>
<h2 id="基本思路">基本思路</h2>
<p>【STL】 <code>next_permutation</code>
函数就是返回当前序列的下一个字典序，已经为最大字典序则返回
False，否则为返回 True</p>
<p>基本思想如下：</p>
<ol type="1">
<li>从尾端开始依次比较两个相邻元素直到存在 <span
class="math inline">\(a_i,a_{i+1}\)</span> 满足 <span
class="math inline">\(a_i &lt; a_{i+1}\)</span>，如果未找到返回
False</li>
<li>从尾端开始向前检验，找出第一个大于 <span
class="math inline">\(a_i\)</span> 的元素 <span
class="math inline">\(a_j\)</span>，交换 <span
class="math inline">\(a_i,a_j\)</span></li>
<li>将 <span class="math inline">\(a_i\)</span> 之后（不包括 <span
class="math inline">\(a_i\)</span>）的序列做反序处理</li>
</ol>
<span id="more"></span>
<p>可能的代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> BidirIt&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirIt first, BidirIt last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    BidirIt i = last;</span><br><span class="line">    <span class="keyword">if</span> (first == --i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        BidirIt i1, i2;</span><br><span class="line"> </span><br><span class="line">        i1 = i;</span><br><span class="line">        <span class="keyword">if</span> (*--i &lt; *i1) &#123;</span><br><span class="line">            i2 = last;</span><br><span class="line">            <span class="keyword">while</span> (!(*i &lt; *--i2))</span><br><span class="line">                ;</span><br><span class="line">            std::<span class="built_in">iter_swap</span>(i, i2);</span><br><span class="line">            std::<span class="built_in">reverse</span>(i1, last);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == first) &#123;</span><br><span class="line">            std::<span class="built_in">reverse</span>(first, last);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单证明">简单证明</h2>
<p>上面给出了思路，这里做一个简单证明</p>
<p>对一个序列 <span
class="math inline">\(a_0,a_1,\cdots,a_i,a_{i+1},\cdots,a_{n-1}\)</span>，必定存在
<span class="math inline">\(i\)</span>，使得 <span
class="math inline">\(a_i \sim a_{i+1}\)</span>，为正序，<span
class="math inline">\(a_{i+1}\sim a_{n-1}\)</span>
为逆序（这里正序指的是从小到大的顺序，逆序为从大到小），这里对应了上面的步骤
1</p>
<p>现在需要求此序列的下一个字典序，容易得到，<span
class="math inline">\(a_{i+1}\sim a_{n-1}\)</span>
已经为逆序（也为递减数列），不存在更大的字典序，但 <span
class="math inline">\(a_{i}\sim
a_{n-1}\)</span>，并不是逆序，即存在更大的字典序</p>
<p>显然以 <span class="math inline">\(a_i\)</span> 作为 <span
class="math inline">\(a_{i}\sim a_{n-1}\)</span>
的首元素已经达到最大，所以需要在 <span class="math inline">\(a_{i+1}\sim
a_{n-1}\)</span> 中找到一个元素替换 <span
class="math inline">\(a_i\)</span>，显然此元素为大于 <span
class="math inline">\(a_i\)</span> 的最小元素，因为数列 <span
class="math inline">\(a_{i+1}\sim a_{n-1}\)</span>
为递减数列，所以只需要从末端开始向前寻找第一个大于 <span
class="math inline">\(a_i\)</span> 的元素即可，记此元素为 <span
class="math inline">\(a_j\)</span>，即步骤 2</p>
<p>因为 <span class="math inline">\(a_j &gt; a_i\)</span>，所以 <span
class="math inline">\(a_j\)</span> 作为首元素的最小排列为 <span
class="math inline">\(a_{i+1} \sim a_{n-1}\)</span>
的顺序表示即可。交换后的序列仍然为逆序的，所以只需要反序处理即可，对应步骤
3</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>DSAA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 正则替换 Markdown 图像路径前缀</title>
    <url>/2020/05/22/2020-05-22-blog-image-replace/</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>在博客网站下直接写文章时，会涉及到图像的路径，一般采用的相对路径。但是这样子在最后部署的时候的路径一般都会出现问题（或者自己另外写好的文章放到网站上就不可避免的重新编辑图像地址）。</p>
<p>一种解决方法是把所有图片放在图床上，就不存在上面的问题了。但本人一般喜欢本地写，图片资源直接放在GitHub上，或者博客网站的相应位置，所以将本地路径转换为
GitHub /网站 路径就显的很重要。</p>
<p>这里采用的是 Python 正则替换实现此功能</p>
<span id="more"></span>
<h2 id="解决方案">解决方案</h2>
<p>这里采用的是Python的正则匹配方案。</p>
<p>Markdown 中的图像都是以
<code>![text](./img_directory/sub_path)</code> 或者
<code>![text](img_directory/sub_path)</code>
这样的形式，而目标则色把他们的公共前缀路径替换为超链接前缀，如
<code>![text](https://site/sub_path)</code>，所以简单的思路就是把图像中的路径
<code>****prefix/img.jpg</code> 替换为 <code>site_path/img.jpg</code>
即把 prefix 及其前面的部分替换为网址前缀，防止图像路径有的使用
<code>./</code> 有的不适用的格式。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author : Weijun Lin</span></span><br><span class="line"><span class="comment"># @File : change-img-path.py</span></span><br><span class="line"><span class="comment"># @Software: VS Code</span></span><br><span class="line"><span class="comment"># @Version: python 3.7.3</span></span><br><span class="line"><span class="comment"># @Desc: 使用方式 python change-img-path.py tar-markdown-file prefix newprefix</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;amount of parameters must be 4&quot;</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">all_prefix = sys.argv[<span class="number">2</span>]</span><br><span class="line">patter1 = <span class="string">&#x27;\!\[.*?\]\((?P&lt;tar&gt;.*&#123;&#125;).*?.*?\)&#x27;</span>.<span class="built_in">format</span>(all_prefix)</span><br><span class="line">patter1 = re.<span class="built_in">compile</span>(patter1)</span><br><span class="line">patter2 = <span class="string">&#x27;\&lt;img src=&quot;(?P&lt;tar&gt;.*&#123;&#125;).*?\..*?\&gt;&#x27;</span>.<span class="built_in">format</span>(all_prefix)</span><br><span class="line">patter2 = re.<span class="built_in">compile</span>(patter2)</span><br><span class="line">file_path, prefix =sys.argv[<span class="number">1</span>], sys.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> file_in, <span class="built_in">open</span>(<span class="string">&quot;out-&quot;</span>+file_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> file_out:</span><br><span class="line">    line = file_in.readline()</span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        <span class="comment"># 获取所有匹配的Match对象</span></span><br><span class="line">        matched1 = patter1.finditer(line)</span><br><span class="line">        matched2 = patter2.finditer(line)</span><br><span class="line">        pos_list = []</span><br><span class="line">        <span class="keyword">if</span> matched1 != <span class="literal">None</span>:</span><br><span class="line">            pos_list += [(x.start(<span class="string">&quot;tar&quot;</span>), x.end(<span class="string">&quot;tar&quot;</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(matched1)]</span><br><span class="line">        <span class="keyword">if</span> matched2 != <span class="literal">None</span>:</span><br><span class="line">            pos_list += [(x.start(<span class="string">&quot;tar&quot;</span>), x.end(<span class="string">&quot;tar&quot;</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>(matched2)]</span><br><span class="line">        pos_list.sort() <span class="comment"># 按开始位置从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> pos_list[::-<span class="number">1</span>]: <span class="comment"># 逆序遍历</span></span><br><span class="line">            st, ed = v</span><br><span class="line">            <span class="comment"># 替换掉原来的</span></span><br><span class="line">            <span class="keyword">if</span> st == ed:</span><br><span class="line">                line = line[:st] + prefix + line[st:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                line = line[:st] + prefix + line[ed:]</span><br><span class="line">        file_out.write(line);</span><br><span class="line">        line = file_in.readline()</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>使用方式为
<code>python change-img-path.py tar-markdown-file prefix newprefix</code></p>
<p>使用 <code>newprefix</code> 替换图像路径中的 <code>prefix</code></p>
<p>其中一些函数的解释可以参考：<a
href="https://docs.python.org/zh-cn/3/library/re.html">正则表达式操作</a></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络自顶向下 第6版 阅读笔记</title>
    <url>/2020/03/02/2020-03-02-Compute-Networking-A-Top-Down-Approach-6th/</url>
    <content><![CDATA[<p><a
href="https://github.com/Troy922/Computer-Network/blob/master/计算机网络自顶向下方法答案(英文第六版).pdf">书本配套答案</a></p>
<blockquote>
<p>Github：<a
href="https://github.com/Weijun-Lin/Notes/tree/master/Compute-Networking-A-Top-Down-Approach-6th">笔记-计算机网络自顶向下
第6版</a></p>
</blockquote>
<span id="more"></span>
<h2 id="chapter-1-计算机网络和因特网">Chapter 1 计算机网络和因特网</h2>
<h3 id="网络边缘">1. 网络边缘</h3>
<h4 id="物理媒介">物理媒介</h4>
<p>分为两类：导引型（guided media），非导引型（unguided media）</p>
<ul>
<li>双绞铜线（Twisted-Pair Copper Wire）</li>
<li>同轴电缆（Coaxial Cable）</li>
<li>光纤（Fiber Optics）</li>
<li>陆地无线电信道（Terrestrial Radio Channels）</li>
<li>卫星无线电信道（Satellite Radio Channel）</li>
</ul>
<h3 id="网络核心">*2. 网络核心</h3>
<blockquote>
<p>the mesh of packet switches and links that interconnects the
Internet’s end systems</p>
</blockquote>
<h4 id="i.-packet-switching-分组交换">i. Packet Switching 分组交换</h4>
<blockquote>
<p>breaks <strong>long messages</strong> into smaller chunks of data
known as <strong>packets</strong>. Between source and destination, each
packet travels through <strong>communication links</strong> and
<strong>packet switches</strong> (for which there are two predominant
types, routers and linklayer switches)</p>
<p>Packets are transmitted over each communication link at a rate equal
to the <strong>full transmission rate of the link.</strong></p>
</blockquote>
<h5 id="a.-store-and-forward-transmission-存储转发传输">a.
Store-and-Forward Transmission 存储转发传输</h5>
<p>Store-and-forward transmission means that the packet switch
<strong>must receive the entire packet before it can begin to transmit
the first bit of the packet</strong> onto the outbound link.</p>
<p>P个分组经过N条链路，每一个分组大小是L，速率为R</p>
<p>端到端的时延是：<span
class="math inline">\((N+P-1)\frac{L}{R}\)</span></p>
<h5 id="b.-queuing-delays-and-packet-loss">b. Queuing Delays and Packet
Loss</h5>
<p>Packet Swith have a <strong>output buffer(output queue),</strong>
which stores packets that the router is about to send into that link. In
addition to the <strong>store-and-forward delays</strong>, packets
suffer output buffer <strong>queuing delays</strong>. When the output
buffer is full, <strong>packet loss</strong> will occur.</p>
<h5 id="c.-forwarding-tables-and-routing-protocols">c. Forwarding Tables
and Routing Protocols</h5>
<p>each router has a <strong>forwarding table</strong> （转发表）that
maps destination addresses (or portions of the destination addresses) to
that router’s outbound links.</p>
<h4 id="ii.-circuit-switching-电路交换">ii. Circuit Switching
电路交换</h4>
<blockquote>
<p>the resources needed along <strong>a path (buffers, link transmission
rate) to provide for communication between the end systems are
reserved</strong> for the duration of the communication session between
the end systems</p>
<p><strong>end-to-end</strong> connection</p>
</blockquote>
<h5 id="multiplexing-in-circuit-switched-networks">Multiplexing in
Circuit-Switched Networks</h5>
<ul>
<li><p>frequency-division multiplexing (FDM) 频分复用 ：</p>
<p>The width of the range of frequency is called, not surprisingly, the
<strong>bandwidth</strong>.</p></li>
<li><p>time-division multiplexing (TDM) 时分复用:</p>
<p>circuit switching is <strong>wasteful</strong> because the dedicated
circuits are idle during <strong>silent
periods</strong>(静默期)</p></li>
</ul>
<h4 id="iii.-packet-switching-versus-circuit-switching">iii. Packet
Switching Versus Circuit Switching</h4>
<h5 id="packet-switching">Packet Switching</h5>
<ul>
<li>it offers better sharing of transmission capacity</li>
<li>it is simpler, more efficient, and less costly to implement</li>
<li>great for bursty data</li>
<li>but excessive congestion possible</li>
</ul>
<h5 id="circuit-switching">Circuit Switching</h5>
<ul>
<li>good for real-time serives</li>
<li>silent periods would cause time waste</li>
</ul>
<h4 id="iv.-a-network-of-networks">IV. A Network of Networks</h4>
<ul>
<li>ISP: 互联网服务提供商</li>
<li>IXP： Internet Exchange Point 因特网交换点
保证同级ISP对等（peering）</li>
<li>content provider networks：内容提供商网络</li>
</ul>
<h3 id="delay-loss-and-throughput">3. *Delay, Loss, and Throughput</h3>
<blockquote>
<p>in Packet-Switched Networks</p>
</blockquote>
<h4 id="types-of-delay">Types Of Delay</h4>
<ul>
<li><p><strong>nodal processing delay</strong>（节点处理时延）:</p>
<p>The time required to <strong>examine the packet’s header</strong> and
<strong>determine where to direct the packet</strong> is part of the
processing delay.</p></li>
<li><p><strong>Queuing Delay</strong>（排队时延）：</p>
<p>At the queue, the packet experiences a queuing delay as it waits to
be transmitted onto the link.</p></li>
<li><p><strong>Transmission Delay</strong>（传输时延）：</p>
<p>Denote the length of the packet by L bits, and denote the
transmission rate of the link from router A to router B by R bits/sec.
The transmission delay is L/R</p></li>
<li><p><strong>Propagation Delay</strong>（传播时延）：</p>
<p>Once a bit is pushed into the link, it needs to propagate to router
B. The time required to propagate from the beginning of the link to
router B is the propagation delay</p></li>
</ul>
<h4 id="queuing-delay-and-packet-loss">Queuing Delay and Packet
Loss</h4>
<ul>
<li><strong>traffic intensity</strong>（流量强度）： let <em>a</em>
denote the <strong>average rate at which packets</strong> arrive at the
queue (<em>a</em> is in units of packets/sec)（包到达平均速度）Recall
that R is the transmission rate（传输速度）; Also suppose, for
simplicity, that all packets consist of L bits. Then the average rate at
which bits arrive at the queue is <em>La</em>
bits/sec（包到达路由平均速度） The ratio <em>La/R</em>, called the
traffic intensity. 保证流量强度&lt;=1才能正常工作</li>
<li><strong>Packet Loss</strong>（丢包）：With no place to store such a
packet, a router will drop that packet; that is, the packet will be
lost.</li>
</ul>
<h4 id="end-to-end-delay">End-to-End Delay</h4>
<p>suppose there are <strong>N - 1</strong> routers between the source
host and the destination host</p>
<p>$ d_{end-end} = N(d_{proc}+d_{trans}+d_{prop})$</p>
<h4 id="throughput-in-computer-networks">Throughput in Computer
Networks</h4>
<ul>
<li><strong>instantaneous throughput</strong>:at any instant of time is
the rate (in bits/sec) at which Host B is receiving the file</li>
<li><strong>average throughput</strong>: For all file</li>
<li>the <strong>throughput</strong> depends not only on the transmission
rates of the links along the path, but also on the intervening
traffic</li>
</ul>
<h3 id="protocol-layers-and-their-service-models">4. Protocol Layers and
Their Service Models</h3>
<h4 id="layered-architecture">Layered Architecture</h4>
<blockquote>
<p>Protocol layering has conceptual and structural advantages</p>
<p>the protocols of the various layers are called the <strong>protocol
stack</strong></p>
</blockquote>
<p>Five-layer Internet protocol stack:</p>
<ol type="1">
<li><p><strong>Application Layer</strong>: HTTP</p>
<p>The application layer is where <strong>network applications and their
application-layer protocols</strong> reside. this packet of information
at the application layer as a <strong>message</strong>（报文）.</p></li>
<li><p><strong>Transport Layer</strong>：TCP UDP</p>
<p>The Internet’s transport layer transports application-layer messages
between application endpoints. Transport-layer packet as a
<strong>segment</strong>(报文段).</p>
<p>TCP guaranteed delivery of application-layer messages to the
destination and flow control (that is, sender/receiver speed matching)
But UDP not.</p></li>
<li><p><strong>Network Layer</strong>：IP</p>
<p>The Internet’s network layer is responsible for moving network-layer
packets known as <strong>datagrams</strong> (数据报)from one host to
another.</p></li>
<li><p><strong>Link Layer</strong>:</p>
<p>To move a packet from one node (host or router) to the next node in
the route, the network layer relies on the services of the link layer.
The services provided by the link layer depend on the <strong>specific
link-layer protocol</strong>(特定链路层协议) that is employed over the
link. refer to the linklayer packets as
<strong>frames.</strong>（帧）</p></li>
<li><p><strong>Physical Layer</strong>：</p>
<p>the job of the physical layer is to <strong>move the individual
bits</strong> within the frame from one node to the next.</p></li>
</ol>
<p><strong>OSI Model</strong>：</p>
<blockquote>
<p>There are application layer, presentation layer, session layer,
transport layer, network layer, data link layer, and physical layer from
up to down.</p>
</blockquote>
<ul>
<li><strong>presentation layer</strong> is to provide services that
allow communicating applications to interpret the meaning of data
exchanged. These services include <strong>data compression</strong> and
<strong>data encryption</strong> as well as <strong>data
description</strong>.</li>
<li><strong>The session layer</strong> provides for <strong>delimiting
and synchronization of data exchange</strong>(数据交换和定界), including
the means to build a checkpointing and recovery scheme.</li>
</ul>
<h4 id="encapsulation">Encapsulation</h4>
<p>we see that at each layer, a packet has two types of fields:
<strong>header fields</strong>（首部字段） and a <strong>payload
field</strong>（有效载荷字段）. The payload is typically a packet from
the layer above.</p>
<p>In every layer, the layer encapsulates the data from last layer as
payload field, then add its own header information, to build whole
information.</p>
<h2 id="chapter-2-application-layer">Chapter 2 Application Layer</h2>
<blockquote>
<p>2.2 2.5 2.6 are important</p>
<p>DNS protocol not important</p>
<p>2.3 2.4-</p>
</blockquote>
<h3 id="principles-of-network-applications">1. Principles of Network
Applications</h3>
<h4 id="i.-network-application-architectures">i. Network Application
Architectures</h4>
<blockquote>
<p>two predominant（主要的） architectural paradigms used in modern
network applications: the client-server architecture or the peer-to-peer
(P2P) architecture</p>
</blockquote>
<ul>
<li><p><strong>the client-server architecture：</strong></p>
<p>client and server are separate and fixed, and they perform they own
functions</p></li>
<li><p><strong>P2P architecture:</strong></p>
<p>Because the peers（对等方） communicate without passing through a
dedicated（专用的） server, the architecture is called peer-to-peer.
These peers can be server also can be clientz.</p>
<p>P2P is <strong>self-scalability and cost effective</strong>. And have
three <strong>challenges</strong>: ISP Friendly, Security,
Incentives（激励）.</p></li>
</ul>
<h4 id="ii.-processes-communicating">ii. Processes Communicating</h4>
<blockquote>
<p>In truth, server and client are just two process</p>
</blockquote>
<p>A process sends messages into, and receives messages from, the
network through a software interface called a socket（套接字）. It is
also referred to as the Application Programming Interface (API) between
the application and the network</p>
<p>We use <strong>IP address and port number</strong> to do addressing
process.</p>
<h4 id="iii.-transport-services-available-to-applications">iii.
Transport Services Available to Applications</h4>
<ul>
<li>Reliable Data Transfer</li>
<li>Throughput</li>
<li>Timing</li>
<li>Security</li>
</ul>
<h4 id="iv.-transport-services-provided-by-the-internet">IV. Transport
Services Provided by the Internet</h4>
<ul>
<li><p>TCP Servies</p>
<p>Connection-oriented service and Reliable data transfer
service</p></li>
<li><p>UDP</p>
<p>UDP is a no-frills, lightweight transport protocol, providing minimal
services. UDP is <strong>connectionless, unreliable</strong>. UDP
provides <strong>no guarantee</strong> that the message will ever reach
the receiving process. Furthermore, messages that do arrive at the
receiving process may arrive <strong>out of order</strong>. And no
congestion-control mechanism（拥塞机制）.</p></li>
</ul>
<h4 id="v.-services-not-provided-by-internet-transport-protocols">V.
Services Not Provided by Internet Transport Protocols</h4>
<p>But in our brief description of TCP and UDP, conspicuously（明显的）
missing was any mention of throughput or timing guarantees—services not
provided by today’s Internet transport protocols.</p>
<h3 id="the-web-and-http">*2. The Web and HTTP</h3>
<h4 id="i.-overview-of-http">i. Overview of HTTP</h4>
<p>The <strong>HyperText Transfer Protocol (HTTP)</strong>, the Web’s
application-layer protocol, is at the heart of the Web. . Because an
HTTP server maintains no information about the clients, HTTP is said to
be a <strong>stateless protocol</strong>（无状态协议）. We also remark
that the <strong>Web uses the client-server application
architecture,</strong></p>
<h4 id="ii.-non-persistent-and-persistent-connections">ii.
Non-Persistent and Persistent Connections</h4>
<blockquote>
<p>Attention:
对多并发的例子中，线程之间对其他线程的连接一般是不可见的</p>
<p>流水线式不一定是绝对好的，本质是提高链路的利用率（充分利用带宽时延积）</p>
<p>先获取HTML然后在获取其它对象</p>
<ol type="1">
<li>可能会因为头包过大造成链路阻塞</li>
<li>返回必须按照接收顺序，已处理好的必须等前一个发送后才可以发送</li>
</ol>
</blockquote>
<ul>
<li><strong>non-persistent connections</strong>: each request/response
pair be sent over a separate TCP connection</li>
<li><strong>persistent connections</strong>: all of the requests and
their corresponding responses be sent over the same TCP
connection，注意持久化一般是流水线</li>
</ul>
<p><strong>round-trip time (RTT 往返时延)</strong>：the time it takes
for a small packet to travel from client to server and then back to the
client</p>
<p><strong>the total response time:(总响应时间)</strong> two RTTs plus
the transmission time at the server of the HTML file.</p>
<p>Non-persistent connections have some
<strong>shortcomings</strong>.</p>
<ul>
<li>a brand-new connection must be established and maintained for each
requested object.</li>
<li>each object suffers a delivery delay of two RTTs</li>
</ul>
<h4 id="iii.-http-message-format">iii. HTTP Message Format</h4>
<ol type="1">
<li><p>HTTP Request Message</p>
<ul>
<li>request line（请求行）: first line
<ul>
<li>method field: <strong>GET, POST</strong>, HEAD, PUT, and DELETE</li>
<li>URL field</li>
<li>HTTP Version field</li>
</ul></li>
<li>header line（首部行）: subsequent line
<ul>
<li>Host : specifies the host on which the object resides</li>
<li>Connection : whether use persistent connections</li>
<li>User-agent : specifies the user agent , that is, the browser type.
This header line is useful because the server can actually send
different versions of the same object to different types of user
agents.</li>
<li>Accept-language: indicates that the user prefers language
version</li>
<li>POST method: has an entity body for post data, but get also can do
use work with saving data in URLs.</li>
</ul></li>
</ul></li>
<li><p>HTTP Request Message</p>
<ul>
<li><p>status line : first line</p>
<p>version + status code + phrase</p>
<ul>
<li>200 OK : succeeded</li>
<li>301 Moved Permanently : Requested object has been permanently moved
and new URL will be returned</li>
<li>400 Bad Request : the request could not be understood by the
server.</li>
<li>404 Not Found : The requested document does not exist on this
server</li>
<li>505 HTTP Version Not Supported : ~~~</li>
</ul></li>
<li><p>header line: subsequent line :</p>
<ul>
<li>Connection : tell the client that whether close the TCP connection
after sending the message</li>
<li>Date : <strong>indicates the time and date when the HTTP response
was created and sent by the server</strong>. Note that this is not the
time when the object was created or last modified; it is the time when
the server retrieves the object from its file system, inserts the object
into the response message, and sends the response message.</li>
<li>Server : analogous to the User-agent</li>
<li>Last-Modified : the time and date when the object was created or
last modified</li>
<li>Content-Length : data size</li>
<li>Content-Type : data type such as HTML</li>
</ul></li>
<li><p>entity body : save data</p></li>
</ul></li>
</ol>
<h4 id="iv.-user-server-interaction-cookies">iv. User-Server
Interaction: Cookies</h4>
<blockquote>
<p>cookies allow sites to keep track of users</p>
</blockquote>
<p>Cookie has four components:</p>
<ol type="1">
<li>a cookie header line in the HTTP <strong>response</strong>
message</li>
<li>a cookie header line in the HTTP <strong>request</strong>
message</li>
<li>a cookie file kept on the user’s end system and managed by the
user’s <strong>browser</strong></li>
<li>a back-end database at <strong>the Web site</strong></li>
</ol>
<p>Although cookies often simplify the Internet shopping experience for
the user, they are controversial because they can also be considered as
an invasion of privacy</p>
<h4 id="v.-web-caching">V. Web Caching</h4>
<blockquote>
<p>A Web cache—also called a proxy server（代理服务器）—is a network
entity that satisfies HTTP requests on the behalf of an origin Web
server</p>
</blockquote>
<p>It works like this:</p>
<p><img
src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/web_cache_1.png" /></p>
<p>Note that a cache is <strong><em>both a server and a
client</em></strong> at the same time.</p>
<p>Advantages:</p>
<ul>
<li><strong><em>A Web cache can substantially reduce the response time
for a client request</em></strong>, particularly if the bottleneck
bandwidth between the client and the origin server is much less than the
bottleneck bandwidth between the client and the cache （加速）</li>
<li>Web caches can substantially reduce traffic on an institution’s
access link to the Internet. So they does not have to upgrade bandwidth
as quickly, thereby reducing costs. （减少通信量降低带宽不耗钱）</li>
<li>Web caches can substantially reduce Web traffic in the Internet as a
whole, thereby improving performance for all applications.
（降低网络流量，提高性能）</li>
</ul>
<p><strong>Content Distribution Networks (CDNs)</strong>
（内容分发网络）: A CDN company installs many geographically distributed
caches throughout the Internet, thereby localizing much of the
traffic.</p>
<h4 id="vi.-the-conditional-get">VI. The Conditional GET</h4>
<blockquote>
<ul>
<li>the request message uses the GET method</li>
<li>the request message includes an <strong>If-ModifiedSince</strong>:
header line</li>
</ul>
</blockquote>
<p>Use the conditional get to guarantee the file in proxy server is up
to date.</p>
<h3 id="dnsthe-internets-directory-service">5. DNS—The Internet’s
Directory Service</h3>
<blockquote>
<p>domain name system: a directory service that translates hostnames to
IP addresses 53端口</p>
</blockquote>
<p>Definition:</p>
<ol type="1">
<li>a distributed database implemented in a hierarchy of DNS
servers</li>
<li>an application-layer protocol that allows hosts to query the
distributed database</li>
</ol>
<h4 id="i.-services-provided-by-dns">i. Services Provided by DNS</h4>
<ul>
<li>Host aliasing</li>
<li>Mail server aliasing</li>
<li>Load distribution（负载分配）（一个域名对应多个服务器IP）</li>
</ul>
<h4 id="ii.-overview-of-how-dns-works">ii. Overview of How DNS
Works</h4>
<ul>
<li>centralized design: A simple design for DNS would have one DNS
server that contains all the mappings
<ul>
<li>A single point of failure</li>
<li>Traffic volume</li>
<li>Distant centralized database</li>
<li>Maintenance</li>
</ul></li>
<li>distributed hierarchical design: uses a large number of servers,
organized in a hierarchical fashion and distributed around the world
<ul>
<li>root DNS servers : In the Internet there are 13 root DNS
servers</li>
<li>top-level domain (TLD) servers</li>
<li>authoritative DNS servers（权威域名服务器）: Every organization with
publicly accessible hosts (such as Web servers and mail servers) on the
Internet must provide publicly accessible DNS records that map the names
of those hosts to IP addresses</li>
<li>local DNS server : A local DNS server does not strictly belong to
the hierarchy of servers but is nevertheless central to the DNS
architecture; When a host makes a DNS query, the query is sent to the
local DNS server, which acts a proxy.
<ul>
<li>recursive：如果全部采用这种方式会给更服务器极大的压力</li>
<li>iterative</li>
</ul></li>
</ul></li>
</ul>
<h4 id="iv.-dns-records-and-messages">iv. DNS Records and Messages</h4>
<p>resource records (RRs): provide hostname-to-IP address mappings</p>
<p><strong>format : (Name, Value, Type, TTL)</strong></p>
<ul>
<li>Type = A : Name is a hostname and Value is the IP address for the
hostname.</li>
<li>Type = NS : Name is a domain (such as foo.com) and Value is the
hostname of an authoritative DNS server that knows how to obtain the IP
addresses for hosts in the domain</li>
<li>Type = CNAME : Value is a canonical hostname for the alias hostname
Name</li>
<li>Type = MX : Value is the canonical name of a mail server that has an
alias hostname Name</li>
</ul>
<h3 id="电子邮件">电子邮件</h3>
<p>3个组成部分：用户代理，邮件服务器，SMTP</p>
<h4 id="smtp保存状态">SMTP(保存状态)</h4>
<p>25
号端口，简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP
协议属于 TCP/IP
协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP
服务器就是遵循 SMTP 协议的发送邮件服务器。</p>
<h4 id="pop3">POP3</h4>
<p>Post Office Protocol
3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议</p>
<h4 id="imap保存状态">IMAP（保存状态）</h4>
<p>Internet Mail Access Protocol，即交互式邮件存取协议</p>
<p>开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上</p>
<h3 id="ftp保存状态">FTP（保存状态）</h3>
<p>两个TCP连接，一个控制连接，一个控制数据连接（20，21端口）</p>
<h2 id="chapter-3-transport-layer">Chapter 3 Transport Layer</h2>
<blockquote>
<p>A transport-layer protocol provides for <strong>logical
communication</strong> between application
<strong><em>processes</em></strong> running on different hosts.</p>
<p>3.6 不做要求</p>
</blockquote>
<p>###　3.1 Introduction and Transport-Layer Services</p>
<h4 id="relationship-between-transport-and-network-layers">Relationship
Between Transport and Network Layers</h4>
<p>transport layer lies just above the network layer in the protocol
stack. Whereas a transport-layer protocol provides logical communication
between <strong><em>processes</em></strong> running on different hosts,
a network-layer protocol provides logical communication between
<em>hosts</em>.</p>
<h4 id="overview-of-the-transport-layer-in-the-internet">Overview of the
Transport Layer in the Internet</h4>
<ul>
<li><p>IP service model —— <strong>best-effort delivery
service</strong></p>
<p>IP makes its “best effort” to deliver segments between communicating
hosts, but it makes no guarantees. So IP is unreliable service.</p></li>
<li><p>multiplexing &amp; demultiplexing</p>
<p>Extending <strong>host-to-host</strong> delivery to
<strong>process-to-process</strong> delivery</p></li>
<li><p>TCP</p>
<p><strong>reliable data transfer and provides congestion
control</strong>. TCP congestion control prevents any one TCP connection
from swamping the links and routers between communicating hosts with an
excessive amount of traffic.</p></li>
</ul>
<h3 id="multiplexing-and-demultiplexing">3.2 Multiplexing and
Demultiplexing</h3>
<p>a process can have one or more <strong><em>sockets</em></strong>,
doors through which data passes from <strong>the network to the
process</strong> and through which data passes from the process to the
network.</p>
<ul>
<li><p>demultiplexing: delivering the data in a transport-layer segment
to the correct socket</p></li>
<li><p>multiplexing:</p>
<p>gathering data chunks at the source host from <strong>different
sockets</strong>, encapsulating each data chunk with header information
(that will later be used in demultiplexing) to create segments, and
passing the segments to the network layer</p></li>
</ul>
<p>Socket:</p>
<ol type="1">
<li>unique identifiers to identify UDP, TCP sockets</li>
<li>the <strong>source port number field</strong> and the
<strong>destination port number field</strong></li>
</ol>
<p>the port number ranges from 0 to 65535 (16 bits to express), [0,
1024) is well-known port numbers</p>
<h4 id="connectionless-multiplexing-and-demultiplexing">Connectionless
Multiplexing and Demultiplexing</h4>
<p>可能是因为UDP是无连接，而TCP是有连接的协议的区分</p>
<p>UDP socket is fully identified by a <strong>two-tuple</strong>
consisting of a <strong>destination IP address and a destination port
number</strong>.</p>
<h4
id="connection-oriented-multiplexing-and-demultiplexing">Connection-Oriented
Multiplexing and Demultiplexing</h4>
<p>identified by four values:</p>
<ol type="1">
<li>the source port number in the segment</li>
<li>the IP address of the source host</li>
<li>the destination port number in the segment</li>
<li>its own IP address</li>
</ol>
<p>当一个UDP服务器接收到一个UDP报文段时，它会根据收到的UDP报文段的源IP和源端口号，把数据发送回客户端，它并不需要创建一个新的套接字来处理该报文段；</p>
<p>而对于一个TCP服务器，当它接受一个连接时，它会产生一个新的套接字，然后通过新的套接字来与客户端通信，也就是通过新的套接字来把数据发送回给客户端。由于每一个连接都会产生一个新的套接字，所以具有不同的源IP或源端口号的连接就是一个不同的连接，对应着产生的新的不同的套接字
原文链接：https://blog.csdn.net/ljianhui/article/details/21660629</p>
<h3 id="connectionless-transport-udp">3.3 Connectionless Transport:
UDP</h3>
<ul>
<li><p><em>No connection state.</em> TCP maintains connection state in
the end systems.</p></li>
<li><p><em>Small packet header overhead.</em> The TCP segment has 20
bytes of header over head in every segment, whereas UDP has only 8 bytes
of overhead.</p></li>
<li><p>we mention that it is possible for an application to have
reliable data transfer when using UDP. This can be done if reliability
is built into the application itself</p></li>
</ul>
<h4 id="udp-segment-structure">UDP Segment Structure</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_7.png" style="zoom:50%;" /></p>
<h4 id="udp-checksum">UDP Checksum</h4>
<p>UDP at the sender side performs the 1s complement of the sum of all
the 16-bit words in the segment, with any overflow encountered during
the sum being wrapped around(<strong>add the overflow bits with the
sum</strong>)</p>
<h3 id="principles-of-reliable-data-transfer">3.4 Principles of Reliable
Data Transfer</h3>
<h4 id="building-a-reliable-data-transfer-protocol">Building a Reliable
Data Transfer Protocol</h4>
<ol type="1">
<li><p><strong>rdt1.0</strong></p>
<p>the underlying channel is completely reliable</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_9.png" style="zoom:50%;" /></p></li>
<li><p><strong>rdt2.0</strong>: Reliable Data Transfer over a Channel
with Bit Errors</p></li>
</ol>
<p>an ARQ (Automatic Repeat reQuest) protocols</p>
<p>include RDT2.0-3, gbn, sr, tcp</p>
<ul>
<li><p>checksum</p></li>
<li><p>feedback (ACK,NAK)</p></li>
<li><p>resend</p></li>
</ul>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_10.png" style="zoom:50%;" /></p>
<ol start="3" type="1">
<li><p><strong>rdt2.1</strong>: can detect ACK or NAK errors based on
2.0</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_11.png" style="zoom:50%;" />
<img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_12.png" style="zoom:50%;" /></p></li>
<li><p><strong>rdt2.2</strong>: implement without NAK based on 2.1</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_13.png" style="zoom:50%;" />
<img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_14.png" style="zoom:50%;" /></p></li>
<li><p><strong>rdt3.0</strong>: Reliable Data Transfer over a Lossy
Channel with Bit Errors</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_15.png" style="zoom:50%;" /></p></li>
</ol>
<h4 id="pipelined-reliable-data-transfer-protocols">Pipelined Reliable
Data Transfer Protocols</h4>
<ol type="1">
<li><p>Stop&amp;Wait: rdt</p></li>
<li><p>PipeLine: gbn, sr, tcp in order.</p></li>
</ol>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_19.png" style="zoom:50%;" /></p>
<p>Example:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_22.png" style="zoom:50%;" /></p>
<p>The window size will move as long as getting the ACK.</p>
<p><strong>only a single timer</strong>, which can be thought of as a
timer for the oldest transmitted but not yet acknowledged packet. If an
ACK is received but there are still additional transmitted but not yet
acknowledged packets, the timer is restarted. If there are no
outstanding, unacknowledged packets, the timer is stopped.</p>
<ul>
<li><p><strong>Selective Repeat (SR)</strong></p>
<p>sequence-number space format:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_23.png" style="zoom:50%;" /></p>
<p>Actions in sender:</p>
<ol type="1">
<li>Data received from above</li>
<li>Timeout: <strong>each packet must now have its own logical
timer</strong>, since only a single packet will be transmitted on
timeout</li>
<li>ACK received: <strong>the windows will move right to the
unacknowledged packet with the smallest sequence number</strong> when
received the most left ACK</li>
</ol>
<p>The SR receiver will acknowledge a correctly received packet whether
or not it is in order. Out-of-order packets are buffered until any
missing packets (that is, packets with lower sequence numbers) are
received, at which point a batch of packets can be delivered in order to
the upper layer.</p>
<p>Actions in receiver:</p>
<ol type="1">
<li>Packet with sequence number in [rcv_base, rcv_base+N-1] is correctly
received. In this case, the received packet falls within the receiver’s
window and a selective ACK packet is returned to the sender. If the
packet was not previously received, it is buffered. If this packet has a
sequence number <strong>equal to the base of the receive window
(rcv_base in Figure 3.22), then this packet, and any previously buffered
and consecutively numbered (beginning with rcv_base)</strong> packets
are delivered to the upper layer. The receive window is then moved
forward by the number of packets delivered to the upper layer.</li>
<li>Packet with sequence number in [rcv_base-N, rcv_base-1] is correctly
received. return an ACK</li>
</ol>
<p><strong>SR’s problem</strong>: can’t know <strong><em>a new packet or
a retransmission?</em></strong></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_27.png" style="zoom:70%;" /></p>
<p>The solution of this problem: <strong><em>the window size must be
less than or equal to half the</em></strong> <strong><em>size of the
sequence number space for SR protocols.</em></strong></p></li>
</ul>
<p><strong>Summary:</strong></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/T3_1.png" style="zoom:70%;" /></p>
<h3 id="connection-oriented-transport-tcp">3.5 Connection-Oriented
Transport: TCP</h3>
<p>GBN-SR 窗口不变, TCP 窗口可以变</p>
<h4 id="the-tcp-connection">The TCP Connection</h4>
<ul>
<li>connection-oriented</li>
<li>full-duplex service（全双工）</li>
<li>point-to-point</li>
<li>three-way handshake</li>
<li><strong>maximum segment size (MSS):</strong> The maximum amount of
data that can be grabbed and placed in a segment</li>
<li><strong>maximum transmission unit (MTU):</strong> the length of the
largest link-layer frame that can be sent by the local sending host</li>
</ul>
<h4 id="tcp-segment-structure">TCP Segment Structure</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_29.png" style="zoom:50%;" /></p>
<ul>
<li><strong>Sequence Numbers(SEQ)</strong>: the byte-stream number of
the first byte in the segment</li>
<li><strong>Acknowledgment Numbers(ACK)</strong>: Host A puts in its
segment is the sequence number of the next byte Host A is expecting from
Host B（想要的下一个序号）TCP is said to provide <strong>cumulative
acknowledgments</strong></li>
</ul>
<p>Example：</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_31.png" style="zoom:50%;" /></p>
<h4 id="round-trip-time-estimation-and-timeout">Round-Trip Time
Estimation and Timeout</h4>
<p>The sample RTT, denoted SampleRTT, for a segment is the amount of
time between when the segment is sent (that is, passed to IP) and when
an acknowledgment for the segment is received.</p>
<p>TCP never computes a SampleRTT for a segment that has been
retransmitted; it only measures SampleRTT for segments that have been
transmitted once.</p>
<ul>
<li>use <strong>exponential weighted moving average (EWMA)</strong> to
estimate RTT</li>
</ul>
<p><span class="math inline">\(EstimatedRTT = (1 – \alpha) •
EstimatedRTT + \alpha • SampleRTT\)</span></p>
<ul>
<li>In addition to having an estimate of the RTT, it is also valuable to
have a measure of the variability of the RTT.</li>
</ul>
<p>$ DevRTT = (1 – ) • DevRTT + •┃ SampleRTT – EstimatedRTT ┃$</p>
<ul>
<li>use this formula the get RTT time</li>
</ul>
<p>$ TimeoutInterval = EstimatedRTT + 4 • DevRTT$</p>
<h4 id="reliable-data-transfer">Reliable Data Transfer</h4>
<ul>
<li><strong>Doubling the Timeout Interval</strong></li>
<li><strong>Fast Retransmit</strong>:In the case that three duplicate
ACKs are received (except the first ACK)</li>
</ul>
<h4 id="flow-control">Flow Control</h4>
<p>TCP流控是因为应用层处理速度太慢了,
发送者和接收者的协调,拥塞是路由器和发送者</p>
<p>eliminate the possibility of the sender overflowing the receiver’s
buffer. Flow control is thus a speed-matching service—matching the rate
at which the sender is sending against the rate at which the receiving
application is reading</p>
<p>TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制</p>
<p>A通过TCP连接向B发送一个大文件</p>
<ul>
<li>LastByteRead:
主机B上的应用程序进程从缓存独出的数据流的最后一个字节的编号</li>
<li>LastByteRevd: 网络到达已放入接收缓存的最后一个字节编号</li>
</ul>
<p>保持下式成立</p>
<p>$ LastByteRcvd-LastByteRead RevBuffer $</p>
<p>接收窗口用rwnd表示，可得 <span
class="math inline">\(rwnd=RcvBuffer-[LastByteRcvd-LastByteRead]\)</span></p>
<p>在发送方有 <span class="math inline">\(LastByteSent-LastByteAcked \le
rwnd\)</span></p>
<p><strong>当主机B接收窗口为空时，主机A继续发送只有一个字节数据的报文段，避免A被阻塞的情况</strong></p>
<h4 id="tcp-connection-management">TCP Connection Management</h4>
<p>MSS在传输SYN时传输确定, TCP可以将包合并发就合并发, SYN
包要独占一个序列号 SYN：1.同步网络参数 2.同步序列号
FIN：表示不发了，但可以接收</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_39.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_40.png" style="zoom:50%;" /></p>
<h3 id="tcp-congestion-control">3.7 TCP Congestion Control</h3>
<p><strong>each side of a TCP connection</strong> consists of a
<strong>receive buffer, a send buffer, and several variables</strong>
(LastByteRead, rwnd, and so on). The TCP congestion-control mechanism
operating at the sender keeps track of an additional variable, the
congestion window. <strong>The congestion window</strong>, denoted cwnd,
imposes a constraint on the rate at which a TCP sender can send traffic
into the network.</p>
<p>TCP uses acknowledgments to trigger (or clock) its increase in
congestion window size, TCP is said to be
<strong>self-clocking</strong>.</p>
<p><strong>书本中的TCP标准遵循单一重传定时器的推荐</strong></p>
<p><strong>FSM</strong>：</p>
<p>对快速重传的快速恢复的cwnd有减半加三（考虑重传时没有拥塞）和不加三两种操作，这里采用不加三</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_52.png" style="zoom:70%;" /></p>
<p><strong>TCP congestion-control algorithm</strong>:</p>
<ol type="1">
<li><p>Slow Start</p>
<p><strong>begin with 1 MSS</strong> then <strong>doubling</strong> of
the last sending rate every RTT until meets ssthresh or a loss, then
enter congestion avoidance</p></li>
<li><p>congestion avoidance</p>
<p><strong>linear increase</strong> (of 1 MSS per RTT) until meet a
loss, then <strong>set the ssthresh to half</strong> and enter fast
recovery</p></li>
<li><p>fast recovery</p>
<p>两个版本在超时后都置为1, 丢包（快速重传）处理不一样</p>
<ul>
<li>Tahoe: set cwnd to 1 MSS</li>
<li>Reno: set the rate to the half of the last rate (real fast
recovery)</li>
</ul></li>
</ol>
<p>Example:</p>
<p><img
src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_53.png" /></p>
<p>TCP is <strong>fair</strong></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/3_56.png" style="zoom:50%;" /></p>
<p>these two connection will infinitely approach <em>the equal bandwidth
share line</em>.</p>
<h2 id="chapter-4-the-network-layer">Chapter 4 The Network Layer</h2>
<h3 id="introduction">4.1 Introduction</h3>
<ul>
<li><strong>Forwarding（转发）</strong>: When a packet arrives at a
router’s input link, the router must move the packet to the appropriate
output link</li>
<li><strong>Routing</strong>: The network layer must determine the route
or path taken by packets as they flow from a sender to a receiver. The
algorithms that calculate these paths are referred to as routing
algorithms</li>
</ul>
<p>Every router has a <strong>forwarding table</strong>.</p>
<p>ATM services models:</p>
<ul>
<li>CBR: <strong>Constant bit rate (CBR) ATM network
service.</strong></li>
<li>ABR: <strong>Available bit rate (ABR) ATM network
service</strong></li>
</ul>
<h3 id="virtual-circuit-and-datagram-networks">4.2 Virtual Circuit and
Datagram Networks</h3>
<h4 id="virtual-circuit-networks">Virtual-Circuit Networks</h4>
<p>consists of:</p>
<ul>
<li>a <strong>path</strong> (that is, a series of links and routers)
between the source and destination hosts</li>
<li><strong>VC numbers</strong>, one number for each link along the
path</li>
<li>entries in the <strong>forwarding table</strong> in each router
along the path</li>
</ul>
<p>Whenever a new VC is established across a router, an entry is added
to the forwarding table. Similarly, whenever a VC terminates, the
appropriate entries in each table along its path are removed.</p>
<p><strong>three identifiable phases in a virtual circuit</strong>:</p>
<ol type="1">
<li>VC setup</li>
<li>Data transfer</li>
<li>VC teardown</li>
</ol>
<h4 id="datagram-networks">Datagram Networks</h4>
<p>the router uses <strong><em>the longest prefix matching
rule</em></strong> in datagram networks.</p>
<p>Because forwarding tables in datagram networks <strong>can be
modified at any time</strong>, a series of packets sent from one end
system to another may follow different paths through the network and may
arrive <strong>out of order</strong>.</p>
<h3 id="whats-inside-a-router">4.3 What’s Inside a Router?</h3>
<h4 id="architecture">Architecture</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_6.png" style="zoom:50%;" /></p>
<h4 id="switching">Switching</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_8.png" style="zoom:50%;" /></p>
<h4 id="where-does-queueing-occur">Where Does Queueing Occur?</h4>
<p>the router’s memory can eventually be exhausted and packet loss will
occur when no memory is available to store arriving packets.</p>
<p><strong>packet scheduler（分组调度）</strong>:</p>
<p><strong>active queue management（AQM 主动队列管理）</strong></p>
<ul>
<li>drop-tail（弃尾）</li>
<li>Random Early Detection (RED随机早期检测)</li>
</ul>
<p><strong>head-of-the-line (HOL) blocking（线路前部阻塞）</strong>:
前一个分组和其他的输入端口竞争，阻塞了后面没有冲突的分组的发送</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_11.png" style="zoom:50%;" /></p>
<h4 id="the-routing-control-plane">The Routing Control Plane</h4>
<p>software pass....</p>
<h3 id="ip">4.4 IP</h3>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_12.png" style="zoom:60%;" /></p>
<h4 id="datagram-format">Datagram Format</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_13.png" style="zoom:50%;" /></p>
<p>此处校验和计算方法和UDP处出现的校验和计算方法一致</p>
<p><strong>IP Datagram Fragmentation</strong></p>
<p>datagram: 4000 bytes</p>
<p>MTU: 1500 bytes</p>
<p>IP header: 20 bytes</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/T4_2.png" style="zoom:50%;" /></p>
<h4 id="ipv4-addressing">IPv4 Addressing</h4>
<p>The boundary between the host and the physical link is called an
<strong>interface</strong>.</p>
<p>To determine the subnets, detach each interface from its host or
router, creating islands of isolated networks, with interfaces
terminating the end points of the isolated networks. Each of these
isolated networks is called a subnet. 没有穿越路由器属于一个子网</p>
<p>子网可用IP地址需要减2，一个是主机位全0的子网地址和主机位全1的子网广播地址</p>
<p>子网本身IP地址：前缀+全零</p>
<p>子网本身IP地址：前缀+全1(直接广播地址)（对目标子网广播）</p>
<p>255.255.255.255 子网广播地址（受限广播地址）（广播本子网）</p>
<p>0.0.0.0 网卡本身地址</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_17.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>Classless Interdomain Routing (CIDR
无类别区域间路由选择)</strong></p>
<p>a.b.c.d/x ; use prefix can reduce the size of the forwarding
table</p></li>
<li><p><strong>classful addressing 分类编址</strong></p>
<p>A：8 bits ；B：16 bits；C：24bits</p></li>
</ul>
<h4 id="dhcp-the-dynamic-host-configuration-protocol">DHCP: the Dynamic
Host Configuration Protocol</h4>
<p>a <strong>plug-and-play protocol</strong>(即插即用协议)</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_21.png" style="zoom:50%;" /></p>
<p>因为可能存在多个DHCP服务器所以需要二次确认，客户端选择一个IP并告知（一般都是第一个）</p>
<h4 id="network-address-translation-nat">Network Address Translation
(NAT)</h4>
<p>use a <strong>NAT translation table</strong> at the NAT router, and
to include port numbers as well as IP addresses in the table entries</p>
<p>NAT interferes with P2P applications.</p>
<p>可以采用第三方来通信 （Skype）</p>
<p><strong>NAT
traversal</strong>（NAT穿越）克服两台主机同属于不同NAT之后的通信，使用UPnP(Universal
Plug and Play)协议</p>
<h4 id="internet-control-message-protocol-icmp">Internet Control Message
Protocol (ICMP)</h4>
<p>The most typical use of ICMP is for error reporting</p>
<p>使用IP协议的网络层协议</p>
<h4 id="ipv6">IPv6</h4>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_24.png" style="zoom:50%;" /></p>
<ul>
<li>Next hdr:交付到哪一个协议（TCP/UDP）和v4的协议字段相同</li>
<li>IPv6不允许在路由器上分片和组装</li>
<li>IPv6没有选项字段，使得其为定长40字节</li>
<li>首部校验和消失，完全交付给上层协议处理</li>
<li>payload length: 数据长度</li>
</ul>
<p><strong>Transitioning from IPv4 to IPv6</strong></p>
<ul>
<li><p><strong>dual-stack</strong>：使用既可以处理v4也可以处理v6的路由器，但可能丢失流标签（或者其他v6特有标签）</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_25.png" style="zoom:50%;" /></p></li>
<li><p><strong>tunneling</strong>（建隧道）：将v6整体作为v4的数据段传递</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_26.png" style="zoom:50%;" /></p></li>
</ul>
<h3 id="routing-algorithms">4.5 Routing Algorithms</h3>
<p>classification</p>
<ol type="1">
<li><strong>global routing algorithm(LS)</strong> &amp;
<strong>decentralized routing algorithm(DV)</strong></li>
<li><strong>static routing algorithms</strong> &amp; <strong>Dynamic
routing algorithms</strong></li>
<li><strong>load-sensitive algorithm</strong> &amp;
<strong>load-insensitive(RIP, OSPF, BGP)</strong></li>
</ol>
<h4 id="link-state-algorithm-ls">Link-State Algorithm (LS)</h4>
<ul>
<li>D(v): cost of the least-cost path from the source node to
destination v as of this iteration of the algorithm.</li>
<li>p(v): previous node (neighbor of v) along the current least-cost
path from the source to v.</li>
<li>N' : subset of nodes; v is in N’ if the least-cost path from the
source to v is definitively known.</li>
</ul>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/LS.png" style="zoom:50%;" /></p>
<p>Example:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/T4_3.png" style="zoom:50%;" /></p>
<p>Then we can get the forward table of u:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_28.png" style="zoom:50%;" /></p>
<p>oscillations occur in any algorithm, not just an LS algorithm, that
uses a congestion or delay-based link metric</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_29.png" style="zoom:60%;" /></p>
<p>One way to avoid such self synchronization is for each router to
randomize the time it sends out a link advertisement.</p>
<h4 id="the-distance-vector-dv-routing-algorithm">The Distance-Vector
(DV) Routing Algorithm</h4>
<ul>
<li>For each neighbor v, the cost <strong><em>c(x,v)</em></strong> from
x to directly attached neighbor,</li>
<li>Node x’s distance vector, that is, <strong>Dx</strong> = [Dx (y): y
in N], containing x’s estimate of its cost to all destinations, y, in
N</li>
<li>The distance vectors of each of its neighbors, that is,
<strong>Dv</strong> = [Dv (y): y in N] for each neighbor v of x</li>
</ul>
<p>use this formula to update forwarding table:</p>
<p>$D_x(y)=min_v{c(x,v)+D_v(y) } $</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/DV.png" style="zoom:50%;" /></p>
<p>Examlpe:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_30.png" style="zoom:65%;" /></p>
<h4
id="distance-vector-algorithm-adding-poisoned-reverse">Distance-Vector
Algorithm: Adding Poisoned Reverse</h4>
<p>好消息: 链路开销减小, 迭代次数少便收敛</p>
<p>坏消息 链路开销增加,
可能陷入无穷迭代（原因在于消息的虚假，增加的这条链路被其他节点引用但无法更新）</p>
<p>https://blog.csdn.net/tianlongtc/article/details/80261581</p>
<p>毒性逆转：The idea is simple—if z routes through y to get to
destination x, then z will advertise to y that its distance to x is
infinity</p>
<h4 id="a-comparison-of-ls-and-dv-routing-algorithms">A Comparison of LS
and DV Routing Algorithms</h4>
<ul>
<li>Message complexity：</li>
<li>Speed of
convergence（收敛速度）：DV收敛慢，可能遇到环路和无穷计数，LS较快</li>
<li>Robustness（健壮性）：LS更健壮，路由器故障时，DV会无穷欺骗</li>
</ul>
<h4 id="hierarchical-routing">Hierarchical Routing</h4>
<ul>
<li><p><strong>autonomous systems (ASs)</strong>: consisting of a group
of routers that are typically under the same administrative
control</p></li>
<li><p><strong>intra autonomous system routing protocol</strong>: The
routing algorithm running within an autonomous system</p></li>
<li><p><strong>gateway routers</strong>: forwarding packets to
destinations outside the AS</p></li>
<li><p><strong>inter-AS routing protocol</strong>: obtaining
reachability information from neighboring ASs and propagating the
reachability information to all routers internal to the AS</p></li>
<li><p><strong>hot-potato routing</strong>:
如果有两个网关都可以通向到另外一个AS那么简单的选择最近的那一个就可以</p></li>
</ul>
<h3 id="routing-in-the-internet">4.6 Routing in the Internet</h3>
<p><strong>intra autonomous system routing protocol</strong> also named
<strong>interior gateway protocols</strong></p>
<ol type="1">
<li>Routing Information Protocol (RIP) DV(下层ISP或企业)</li>
<li>Open Shortest Path First (OSPF) LS (上层ISP)</li>
</ol>
<h4 id="intra-as-routing-in-the-internet-rip">Intra-AS Routing in the
Internet: RIP</h4>
<p><strong>hop</strong>: the number of subnets traversed along the
shortest path from source router to destination subnet, including the
destination subnet</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_34.png" style="zoom:50%;" /></p>
<p>The maximum cost of a path is limited to 15 in RIP.</p>
<p>In RIP, routing updates are exchanged between neighbors approximately
every 30 seconds using a <strong>RIP response message</strong>(RIP
advertisements)</p>
<p>Example:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_35.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_36.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_37.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/4_38.png" style="zoom:50%;" /></p>
<h4 id="intra-as-routing-in-the-internet-ospf">Intra-AS Routing in the
Internet: OSPF</h4>
<p>OSPF broadcasts routing information to <strong>all</strong> other
routers in the autonomous system</p>
<p>Some of the advances embodied in OSPF：</p>
<ol type="1">
<li><em>Security</em></li>
<li><em>Multiple same-cost paths</em>（允许使用多条路径发送）</li>
<li><em>Integrated support for unicast and multicast routing</em></li>
<li><em>Support for hierarchy within a single routing domain</em></li>
</ol>
<p>OSPF可以配置为多个区域，每个区域都有区域边界路由器（<strong>area
border
routers</strong>）负责向流域以外的分组提供路由选择。AS内只有一个主干区域（backbone），主干的主要作用是为AS内其他区域之间的流量提供路由选择，包括了所有区域边界路由器和一些非边界路由器。在AS内区域间的路由选择要求分组首先路由到一个区域边界路由去，然后听过主干路由到位于母的区域的边界路由器</p>
<h4 id="inter-as-routing-bgpborder-gateway-protocol">Inter-AS Routing:
BGP（Border Gateway Protocol）</h4>
<p>*<strong>BGP转发的对象是前缀（子网）</strong></p>
<p>BGP provides each AS a means to</p>
<ol type="1">
<li>Obtain subnet reachability information from neighboring ASs.</li>
<li>Propagate the reachability information to all routers internal to
the AS</li>
<li>Determine “good” routes to subnets based on the reachability
information and on AS policy</li>
</ol>
<p>Most importantly, BGP allows each subnet to advertise its existence
to the rest of the Internet.</p>
<ul>
<li><strong>BGP peers</strong>：TCP连接的两个端点</li>
<li><strong>BGP session</strong>：发送BGP报文的TCP连接</li>
<li><strong>external BGP</strong> (<strong>eBGP</strong>)
<strong>session</strong>：跨越AS</li>
<li><strong>internal BGP</strong> (<strong>iBGP</strong>)
<strong>session</strong>：内部</li>
</ul>
<p>每一个AS都有一个ASN（autonomous system
number），但是桩（stub）AS没有，这种AS只承担目的地址为本AS的流量。AS号是ICANN
分配的</p>
<p>When a router advertises a prefix across a BGP session, it includes
with the prefix a number of BGP attributes. In BGP jargon, a prefix
along with its attributes is called a route</p>
<ul>
<li><em>AS-PATH</em>:包含了前缀的通告已经听过的那些AS</li>
<li>Providing the critical link between the inter-AS and intra-AS
routing protocols, the NEXT-HOP attribute has a subtle but important
use. <strong>The NEXT-HOP is the router interface that begins the
AS-PATH.</strong></li>
</ul>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/BGP_routing.png" style="zoom:50%;" /></p>
<h2 id="chapter-5-the-link-layer-links-access-networks-and-lans">Chapter
5 The Link Layer: Links, Access Networks, and LANs</h2>
<h3 id="introduction-to-the-link-layer">5.1 Introduction to the Link
Layer</h3>
<ul>
<li><strong>node</strong>: any device that runs a link-layer
protocol</li>
<li><strong>links:</strong>the communication channels that connect
adjacent nodes along the communication path</li>
<li><strong>link-layer frame</strong>: link-layer data transmission
format</li>
</ul>
<h4 id="the-services-provided-by-the-link-layer">The Services Provided
by the Link Layer</h4>
<ol type="1">
<li><em>Framing</em>(成帧)</li>
<li><em>Link access</em>(链路接入)</li>
<li><em>Reliable delivery.</em></li>
<li><em>Error detection and correction</em></li>
</ol>
<h4 id="where-is-the-link-layer-implemented">Where Is the Link Layer
Implemented?</h4>
<p><strong>network adapter</strong> also named <strong>network interface
card (NIC)</strong></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_2.png" style="zoom:50%;" /></p>
<h3 id="error-detection-and--correction-techniques">5.2 Error-Detection
and -Correction Techniques</h3>
<p>use <strong>error-detection and -correction bits(EDC)</strong> to
detect and correct error bits</p>
<p>Even with the use of error-detection bits there still may be
<strong>undetected bit errors</strong></p>
<h4 id="parity-checks">Parity Checks</h4>
<p>奇偶校验只需要查看加上检验比特(奇偶校验位)的1 是奇数还是偶数</p>
<p>二维奇偶校验:</p>
<p>对每一行每一列都进行奇偶校验,然后对列行奇偶校验位进行奇偶校验,
就校验可以检测和纠正单个比特错误,可以检测但是不能纠正两个比特的任意错误组合</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_5.png" style="zoom:50%;" /></p>
<p>The ability of the receiver to both detect and correct errors is
known as <strong>forward error correction (FEC前向纠错)</strong>.</p>
<h4 id="checksumming-methods">Checksumming Methods</h4>
<p>和UDP/TCP中的类似</p>
<h4 id="cyclic-redundancy-check-crc">Cyclic Redundancy Check (CRC)</h4>
<p>also named <strong>polynomial codes</strong>(多项式编码)</p>
<ol type="1">
<li><p>确定多项式 例如 x3+x2+1 = 1101</p></li>
<li><p>在目标码后加上多项式码长度-1 的0</p></li>
<li><p>做模2除法(除的过程不是减是异或)</p></li>
</ol>
<p>把最后的余数添加到原码的末尾,在接收端使用相同多项式除看余数是否是0</p>
<h3 id="multiple-access-links-and-protocols">5.3 Multiple Access Links
and Protocols</h3>
<ul>
<li><strong>point-to-point link</strong>: consists of a single sender at
one end of the link and a single receiver at the other end of the
link</li>
<li><strong>broadcast link</strong>: enables a single source node to
send a copy of a packet to a subset of the other network nodes</li>
</ul>
<ol type="1">
<li>channel partitioning protocols 信道划分协议</li>
<li>random access protocols 随机访问协议</li>
<li>taking-turns protocols 轮流协议</li>
</ol>
<p>a multiple access protocol for a broadcast channel of rate R bits per
second should have the following desirable characteristics:</p>
<ol type="1">
<li><p>当仅有一个节点发送数据时,具有R bps的吞吐量</p></li>
<li><p>当M给节点发送时,每个结点吞吐量为 R/M bps的平均传输速率</p></li>
<li><p>协议是分散的,不会因为某个主节点故障而使整个系统崩溃</p>
<p>no special node to coordinate transmissions</p>
<p>no synchronization of clocks, slots</p></li>
<li><p>协议是简单的,使实现不昂贵</p></li>
</ol>
<h4 id="channel-partitioning-protocols">Channel Partitioning
Protocols</h4>
<ul>
<li><p>time-division multiplexing (TDM): divides time into time frames
and further divides each time frame into N time slots(时隙)
仅有一个节点他的速度任然是R/N的速度</p></li>
<li><p>frequency-division multiplexing (FDM): 将R bps
信道划分为不同的频段, 具有TDM的缺点</p></li>
</ul>
<h4 id="random-access-protocols">Random Access Protocols</h4>
<ul>
<li><p><strong>Slotted ALOHA (时隙 ALOHA)</strong>:</p>
<p>有如下假设:</p>
<ul>
<li>All frames consist of exactly L bits.</li>
<li>Time is divided into slots of size L/R seconds (that is, a slot
equals the time to transmit one frame).</li>
<li>Nodes start to transmit frames only at the beginnings of slots.</li>
<li>The nodes are synchronized so that each node knows when the slots
begin.</li>
<li>If two or more frames collide in a slot, then all the nodes detect
the collision event before the slot ends.</li>
</ul>
<p>p 是一个0-1的概率, 有如下操作:</p>
<ul>
<li>当节点要发送一个新帧时,需要在下一个时隙开始并在该时隙传输整个帧</li>
<li>如果没有碰撞则成功传输,不需要考虑重传</li>
<li>如果有碰撞,该结点在时隙结束之前检测到碰撞,之后以p在之后的每一杠时隙重传,直到成功</li>
</ul>
<p>此协议需要时钟同步,但是当只有一个结点时,效率是R</p>
<p>此协议效率定义为:有大量活跃结点发送大量帧时,长期运行中成功时隙的份额</p>
<p>在p的概率下 N个结点的效率为<span
class="math inline">\(Np(1-p)^{N-1}\)</span> N趋于无穷时有极限1/e =
0.37</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_10.png" style="zoom:50%;" /></p></li>
<li><p>ALOHA</p>
<p>时隙ALOHA的无时钟同步版本, 效率降低一半</p></li>
<li><p>Carrier Sense Multiple Access (CSMA 载波监听多路访问)</p>
<p>规则:</p>
<ol type="1">
<li><em>Listen before speaking</em>, this is called <strong>carrier
sensing</strong></li>
<li><em>If someone else begins talking at the same time, stop
talking</em>, this is called <strong>collision detection</strong></li>
</ol>
<p>These two rules are embodied in the family of <strong>carrier sense
multiple access(CSMA)</strong> and <strong>CSMA with collision detection
(CSMA/CD)</strong> protocols</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_12.png" style="zoom:50%;" /></p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_13.png" style="zoom:50%;" /></p>
<p>CSMA/CD 的运行</p>
<ol type="1">
<li>The adapter obtains a datagram from the network layer, prepares a
link-layer frame, and puts the frame adapter buffer.</li>
<li>If the adapter senses that the channel is idle (that is, there is no
signal energy entering the adapter from the channel
即在96比特时间内没有检测到信道上有信号), it starts to transmit the
frame. If, on the other hand, the adapter senses that the channel is
busy, it waits until it senses no signal energy and then starts to
transmit the frame.</li>
<li>While transmitting, the adapter monitors for the presence of signal
energy coming from other adapters using the broadcast channel.</li>
<li>If the adapter transmits the entire frame without detecting signal
energy from other adapters, the adapter is finished with the frame. If,
on the other hand, the adapter detects signal energy from other adapters
while transmitting, it aborts the transmission (that is, it stops
transmitting its frame).</li>
<li>After aborting, the adapter waits a random amount of time and then
returns to step 2.</li>
</ol>
<p>选择随机回退时间算法:</p>
<p><strong>binary exponential
backoff(二进制指数后退)</strong>algorithm</p>
<p>经历n次碰撞之后,结点随机的从<span
class="math inline">\(\{0,1,2,...,2^n-1\}\)</span>选择一个值作为回退时间</p></li>
</ul>
<h4 id="taking-turns-protocols">Taking-Turns Protocols</h4>
<p>Recall that two desirable properties of a multiple access protocol
are (1) when only one node is active, the active node has a throughput
of R bps, and (2) when M nodes are active, then each active node has a
throughput of nearly R/M bps. The ALOHA and CSMA protocols have this
first property but not the second.</p>
<ul>
<li><strong>polling protocol(轮询协议)</strong>:
在一个主结点的控制下轮询各个结点</li>
<li><strong>token-passing
protocol(令牌传递协议)</strong>:结点构成一个环,将令牌传递,有令牌的发送,结束后传递给下一个</li>
</ul>
<p>具有单点失效性</p>
<h3 id="switched-local-area-networks">5.4 Switched Local Area
Networks</h3>
<h4 id="link-layer-addressing-and-arp">Link-Layer Addressing and
ARP</h4>
<ul>
<li><p><strong>MAC(LAN address, a physical address)</strong>: 48 bits,
FF-FF-FF-FF-FF-FF <strong>broadcast address</strong></p></li>
<li><p><strong>Address Resolution Protocol (ARP)</strong>:</p>
<p>ARP 维护一个ARP表</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_18.png" style="zoom:50%;" /></p>
<p>表中没有所需要的项时,就会发送一个ARP分组并向子网广播获取对方的MAC地址,当需要发送到子网以外时,需要先获取网关路由器的MAC地址,然后一步步转发出去</p></li>
</ul>
<h4 id="ethernet">Ethernet</h4>
<ul>
<li>hub(集线器): 比特级复制数据,可以达到广播的目的</li>
<li>switch(交换机):存储转发功能,且无碰撞(因为有缓存)</li>
</ul>
<p>结构:</p>
<p><img src="/assets/Note/Compute-Networking-A-Top-Down-Approach-6th/5_20.png" style="zoom:50%;" /></p>
<p>以太网技术提供不可靠服务,接收方会执行CRC校验,失败则丢弃,但不对发送方产生任何的反馈信息</p>
<h4 id="link-layer-switches">Link-Layer Switches</h4>
<ul>
<li><strong>Filtering</strong>: determines whether a frame should be
forwarded to some interface or should just be dropped.</li>
<li><strong>Forwarding</strong>: determines the interfaces to which a
frame should be directed, and then moves the frame to those
interfaces.</li>
</ul>
<p>一个目的MAC通过一个接口x到达交换机有3种情况:</p>
<ol type="1">
<li>没有此目的MAC的表项则广播</li>
<li>此表项和x已经关联,丢弃</li>
<li>不等于x的y接口是此目的MAC 则转发</li>
</ol>
<p>交换机是自学习的,即插即用,双工设备</p>
<ol type="1">
<li>初始交换机为空</li>
<li>对每个接口接收到的帧,存储 MAC, 接口, 时间信息</li>
<li>在老化期(aging time)之后没有收到该地址作为源的帧删除</li>
</ol>
<p>交换机的优点:</p>
<ol type="1">
<li><em>Elimination of collisions</em></li>
<li><em>Heterogeneous links</em>(异质的链路)</li>
<li><em>Management</em></li>
</ol>
<p>交换机和路由器比较:</p>
<ul>
<li><p>交换机:
即插即用、高转发过滤速率、没有提供广播风暴保护措施</p></li>
<li><p>路由器：一般不会死循环（TTL）、广播风暴有有防火墙保护，非即插即用，处理时间长</p></li>
</ul>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>傅里叶变换推导</title>
    <url>/2020/12/04/2020-12-04-FourierTransformation/</url>
    <content><![CDATA[<p>主要介绍从傅里叶级数出发推导傅里叶变换，知乎有很多优秀的傅里叶变换的推导，这里给出一个从傅里叶级数出发，化离散为连续推导出傅里叶变换（也参考了网上的一些思路）</p>
<p>本文的傅里叶形式主要为冈萨雷斯中文版《数字图形处理
第三版》第四章给出的形式，下文用《DIP》替代。</p>
<span id="more"></span>
<h2 id="傅里叶级数">傅里叶级数</h2>
<p>复数形式的傅里叶级数： <span class="math display">\[
\begin{align}
f(t) &amp;= \sum_{n=-\infty}^{\infty} C_n e^{j\frac{2\pi n}{T}t} \\
C_n &amp;= \frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t)
e^{-j\frac{2\pi n}{T}t} \text{d}t \\
n &amp;= 0,\pm 1,\pm 2,\dots
\end{align}
\]</span> 等式摘自《DIP》 4.2.2 傅里叶级数。</p>
<p>傅里叶级数的复数形式可参考网上，注意指数表达有角频率和频率两种，这里为角频率。傅里叶变换推导中将指出。</p>
<h2 id="傅里叶变换">傅里叶变换</h2>
<p>《DIP》4.2.4 给出了傅里叶变换对 <span class="math display">\[
\begin{align}
F(\mu) &amp;= \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t} \text{d}t \\
f(t) &amp;= \int_{-\infty}^{\infty} F(\mu) e^{-j2\pi \mu t} \text{d}\mu
\end{align}
\]</span>
其实我们发现傅里叶变换和傅里叶级数的形式是十分相似的，且<strong>级数与积分之间的关系可以用离散和连续来表示</strong>，那么可以试试将傅里叶级数连续化，看看是否可以得出傅里叶变换。傅里叶级数是适用于周期函数的，对于一般函数可认为
<span class="math inline">\(T\rightarrow \infty\)</span></p>
<p>重写一般函数的傅里叶级数如下： <span class="math display">\[
\begin{align}
f(t) &amp;= \lim_{T\rightarrow \infty} \sum_{n = -\infty}^{\infty} C_n
e^{j\frac{2\pi n}{T}t} \\
&amp;=\lim_{T\rightarrow \infty} \sum_{n = -\infty}^{\infty}
\{\frac{1}{T} \int_{-\frac{T}{2}}^{\frac{T}{2}} f(t) e^{-j\frac{2\pi
n}{T}t} \text{d}t\}
e^{j\frac{2\pi n}{T}t} \\
\end{align}
\]</span> 令 <span class="math inline">\(\Delta w =
\frac{2\pi}{T}\)</span>（角频率）， <span
class="math inline">\(T\rightarrow \infty\)</span> 所以 <span
class="math inline">\(\Delta w \rightarrow 0\)</span>，将 <span
class="math inline">\(\Delta w\)</span> 带入上式可得 <span
class="math display">\[
f(t) = \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty}
\{\frac{\Delta w}{2\pi} \int_{-\infty}^{\infty} f(t) e^{-j\Delta w\cdot
nt} \text{d}t\}
e^{j\Delta w\cdot nt}
\]</span> 令 <span class="math inline">\(w = \Delta w\cdot
n\)</span>，带入可得 <span class="math display">\[
f(t) = \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty}
\{\frac{\Delta w}{2\pi} \int_{-\infty}^{\infty} f(t) e^{-jwt}
\text{d}t\}
e^{jwt}
\]</span>
这里可以发现大括号内的就是傅里叶变换的形式。所以将其单独提取出来即：
<span class="math display">\[
F(w) = \int_{-\infty}^{\infty} f(t) e^{-jwt} \text{d}t
\]</span> 所以函数又可化为： <span class="math display">\[
\begin{align}
f(t) &amp;= \lim_{\Delta w\rightarrow 0} \sum_{n = -\infty}^{\infty}
\frac{\Delta w}{2\pi} F(w)
e^{jwt} \\
&amp;= \frac{1}{2\pi} \lim_{\Delta w\rightarrow 0} \sum_{n =
-\infty}^{\infty}
\Delta w F(w)
e^{jwt}
\end{align}
\]</span> 注意到 <span class="math inline">\(w = \Delta w\cdot
n\)</span> ，因为 <span class="math inline">\(n \in
(-\infty,\infty)\)</span>，所以 w 为<span
class="math inline">\((-\infty,\infty)\)</span> 上以 <span
class="math inline">\(\Delta w\)</span> 为间隔的点集。且有定义可知 w 是
n 的函数，对于确定的 <span class="math inline">\(\Delta w\)</span> ，有
<span class="math inline">\(\text{d}w = \Delta w\)</span>，现在，令
<span class="math inline">\(\Delta w\rightarrow 0\)</span> ，即将 w
连续化，所以上式的<strong>本质为函数 <span
class="math inline">\(F(w)e^{jwt}\)</span> 自变量 w 在 <span
class="math inline">\((-\infty,\infty)\)</span>
上的积分</strong>。最终可得： <span class="math display">\[
\begin{align}
f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty}
F(w) e^{jwt} \text{d} w \tag{1}\\
F(w)&amp; = \int_{-\infty}^{\infty} f(t) e^{-jwt} \text{d}t \tag{2} \\
w &amp;= \Delta w \cdot n \\
\Delta w &amp;= \frac{2\pi}{T}
\end{align}
\]</span> 式子 <span class="math inline">\((1),(2)\)</span>
构成了傅里叶变换对，<span class="math inline">\((1)\)</span>
为傅里叶逆变换，<span class="math inline">\((2)\)</span>
为傅里叶变换</p>
<p>其中并没有涉及到 <span class="math inline">\(\Delta w\)</span>
，只涉及到自变量 <span
class="math inline">\(t,w\)</span>。但傅里叶变换对是时域到频率域的转换。现在也很好理解为什么连接了频率域，<strong>因为推导过程涉及到了
<span class="math inline">\(\Delta w\)</span>，它的物理意义为角频率，而
w 是数轴上以 <span class="math inline">\(\Delta w\)</span>
分割的点集，也就覆盖了全部的频率，换句话说，w
是在频率域中的变量</strong>。</p>
<p>这个变换对定义式和《DIP》以及网上一些不同，主要在于系数 <span
class="math inline">\(\frac{1}{2\pi}\)</span>
以及指数部分，本质上都是相同的，不过是<strong>自变量取角频率还是频率的区别</strong>。</p>
<p>频率和角频率的关系为：<span class="math inline">\(w = 2 \pi
\mu\)</span>，带入角频率傅里叶变换对可得：</p>
<ol type="1">
<li><p>傅里叶变换 <span class="math display">\[
F(w) = F(2\pi \mu) = \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t}
\text{d}t = F&#39;(\mu)
\]</span></p></li>
<li><p>傅里叶逆变换 <span class="math display">\[
\begin{align}
f(t) &amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty}
F(w) e^{jwt} \text{d} w \\
&amp;= \frac{1}{2\pi} \int_{-\infty}^{\infty}
F(2\pi \mu) e^{j2\pi \mu t} \text{d} (2\pi \mu) \\
&amp;= \int_{-\infty}^{\infty}
F&#39;(\mu) e^{j2\pi \mu t} \text{d} \mu
\end{align}
\]</span></p></li>
</ol>
<p>即： $$ <span class="math display">\[\begin{align}
F(\mu) &amp;= \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t} \text{d}t \\
f(t) &amp;= \int_{-\infty}^{\infty}
F(\mu) e^{j2\pi \mu t} \text{d} \mu

\end{align}\]</span> $$</p>
<h2 id="总结">总结</h2>
<p>本文给出了傅里叶变换对的频率与角频率形式，以及从傅里叶级数出发推导傅里叶变换的方法，但不是很严谨，只能是说给出了一个思路，傅里叶变换其实为傅里叶级数拓展到无穷周期的表示。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>傅里叶变换</tag>
        <tag>信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>VERCEL（原名为ZEIT）DNS 记录的修改</title>
    <url>/2020/05/17/2020-05-17-VERCEL-DNS-EDIT/</url>
    <content><![CDATA[<blockquote>
<p>VERCEL提供静态网站的部署和CDN的加速，十分优秀的工具（适合白嫖）</p>
</blockquote>
<h2 id="问题简述">问题简述</h2>
<p>在部署自己的静态网站后（从GITHUB），VERCEL提供了他们的子域名，当然可以使用自己的域名。可以用CNAME将域名导向VERCEL的子域名，也可以直接使用我们自己的域名（不通过CNAME）。具体配置参考：<a
href="https://vercel.com/docs/v2/custom-domains">Custom Domain</a></p>
<p>但直接使用自己的域名会出现一个问题，使用VERCEL提供的DNS服务器后，原来配置的DNS解析失效了。原来我使用的是阿里云的云解析，在更改为VERCEL的DNS服务后，子域名的A记录失效。</p>
<span id="more"></span>
<h2 id="解决方案">解决方案</h2>
<p>既然域名解析失效，因为DNS服务器改成了VERCEL的，所以我们想要改回来需要通过VERCEL修改DNS记录。这需要通过VERCEL的CLI工具实现。下载地址为：https://vercel.com/download</p>
<p>需要先登录，执行：<code>vercel login</code>，登录好之后，就可以修改DNS解析了。（这里我登录验证了好久……）</p>
<p>跟着vercel的官方教程即可：https://vercel.com/docs/cli#commands/domains</p>
<p><code>vercel dns add [domain] [subdomain] [A || AAAA || ALIAS || CNAME || TXT] [value]</code></p>
<p>便可以修改记录</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Tool</category>
      </categories>
  </entry>
  <entry>
    <title>计算机系统结构 张晨曦-第二版 整理</title>
    <url>/2020/05/24/2020-05-24-Computer-System-Architecture-Note/</url>
    <content><![CDATA[<blockquote>
<p>Github：<a
href="https://github.com/Weijun-Lin/Notes/tree/master/计算机系统结构-张晨曦-第二版">笔记-计算机系统结构-张晨曦-第二版</a></p>
</blockquote>
<span id="more"></span>
<h2 id="第一章-计算机系统结构的基本概念">第一章
计算机系统结构的基本概念</h2>
<p>第一台通用电子计算机诞生于1946年</p>
<p>计算机技术的飞速发展得益于两个方面</p>
<ol type="1">
<li>计算机制造技术的发展</li>
<li>计算机系统结构的创新</li>
</ol>
<p>系统结构的重大转折：</p>
<ol type="1">
<li>从单纯依靠指令级并行转向开发线程级并行和数据级并行</li>
<li>计算机系统结构在计算机的发展中有着极其重要的作用</li>
</ol>
<h3 id="计算机系统结构的概念">1.2 计算机系统结构的概念</h3>
<h4 id="计算机系统的层次结构">计算机系统的层次结构</h4>
<ol type="1">
<li>计算机系统＝硬件/固件＋软件</li>
<li>计算机语言从低级向高级发展</li>
<li>从计算机语言的角度，把计算机系统按功能划分成多层次结构</li>
</ol>
<h4 id="计算机系统结构的定义">计算机系统结构的定义</h4>
<ol type="1">
<li><p>计算机系统结构的经典定义：程序员所看到的计算机属性，即概念性结构与功能特性</p></li>
<li><p>按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同的属性</p></li>
<li><p>Amdahl提出的系统结构：传统机器语言级程序员所看到的计算机属性</p>
<p>属性主要为：</p>
<ul>
<li>指令系统</li>
<li>数据表示</li>
<li>寻址规则</li>
<li>寄存器定义</li>
<li>中断系统</li>
<li>机器工作状态的定义和切换</li>
<li>存储系统</li>
<li>信息保护</li>
<li>I/O结构</li>
</ul></li>
<li><p><strong>广义的系统结构定义：指令集结构、组成、硬件</strong></p></li>
<li><p>计算机系统结构概念的<strong>实质</strong>：确定计算机系统中软、硬件的界面，界面之上是软件实现的功能，界面之下是硬件和固件实现的功能</p></li>
</ol>
<h4 id="计算机组成和计算机实现">计算机组成和计算机实现</h4>
<p>一种体系结构可以有多种组成，一种组成可以有多种物理实现</p>
<ol type="1">
<li><p><strong>计算机系统结构</strong>：计算机系统的软、硬件的界面</p></li>
<li><p><strong>计算机组成</strong>：计算机系统结构的逻辑实现</p>
<p>物理机器级内各事件的排序方式与控制方式、各部件的功能以及各部件之间的联系</p></li>
<li><p><strong>计算机实现</strong>：计算机组成的物理实现（器件技术（起主导作用）、微组装技术）</p></li>
</ol>
<h4 id="计算机系统结构的分类">计算机系统结构的分类</h4>
<ol type="1">
<li><p><strong>冯氏分类法：用系统的最大并行度对计算机进行分类</strong></p>
<p>最大并行度：计算机系统在单位时间内能够处理的最大的二进制位数</p></li>
<li><p><strong>Flynn分类法：按照指令流和数据流的多倍性进行分类</strong></p>
<ul>
<li>指令流：计算机执行的指令序列</li>
<li>数据流：由指令流调用的数据序列</li>
<li>多倍性：在系统受限的部件上，同时处于同一执行阶段的指令或数据的最大数目</li>
</ul>
<p>可以分为四类：</p>
<ul>
<li>单指令流单数据流(SISD)</li>
<li>单指令流多数据流(SIMD)</li>
<li>多指令流单数据流(MISD)</li>
<li>多指令流多数据流(MIMD)</li>
</ul>
<p>以上四类的基本结构：IS：指令流，DS：数据流，CS：控制流，CU：控制部件，PU：处理部件，MM和SM：存储器</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/1-1.jpg" style="zoom:50%;" /></p></li>
</ol>
<h3 id="定量分析技术">1.3 定量分析技术</h3>
<h4 id="计算机系统结构的定量原理">计算机系统结构的定量原理</h4>
<ol type="1">
<li><p>以经常性事件为重点(大概率事件优先)</p></li>
<li><p>Amdahl定律</p>
<p>系统性能加速比：<strong><span
class="math inline">\(加速比=\frac{总执行时间_{改进前}}{总执行时间_{改进后}}\)</span></strong></p>
<p>加速比依赖于两个因素：</p>
<ol type="1">
<li><p>可改进比例：改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例</p></li>
<li><p>部件加速比：可改进部分改进后性能提高的倍数，改进前所需的执行时间于改进后执行时间的比</p></li>
<li><p>改进后的程序总执行时间： <span class="math display">\[
\begin{align}
总执行时间_{改进后} &amp;= 不可改进部分的执行时间 +
可改进部分改进后的执行时间 \nonumber \\
总执行时间_{改进后} &amp;=
(1-可改进比例)\times总执行时间_{改进前}+\frac{可改进比例\times总执行时间_{改进前}}{部件加速比}  \nonumber
\\
&amp;=
[(1-可改进比例)+\frac{可改进比例}{部件加速比}]\times总执行时间_{改进前}
\nonumber
\end{align}
\]</span></p></li>
<li><p>可得加速比为： <span class="math display">\[
\begin{align}
加速比 &amp;= \frac{总执行时间_{改进前}}{总执行时间_{改进后}}
\nonumber\\
&amp;= \frac{1}{(1-可改进比例)+\frac{可改进比例}{部件加速比}} \nonumber
\end{align}
\]</span></p></li>
<li><p>是一种性能改进的递减规则，如果只针对整个任务的一部分进行改进和优化，那么所获得的加速比不超过1/(1－可改进比例)</p></li>
</ol></li>
<li><p>CPU性能公式</p>
<ol type="1">
<li><p>执行一个程序所需的CPU时间</p>
<p><strong>CPU时间 = 执行程序所需的时钟周期数×时钟周期时间</strong></p>
<p>时钟周期时间是系统时钟频率的倒数</p></li>
<li><p>每条指令执行的平均时钟周期数CPI</p>
<p><strong>CPI =
执行程序所需的时钟周期数/IC，IC所执行的指令条数</strong>
程序执行的CPU时间可以写为：IC ×CPI ×时钟周期时间</p></li>
<li><p>CPU的性能取决于3个参数：</p>
<ol type="1">
<li>时钟周期时间：取决于硬件实现技术和计算机组成</li>
<li>CPI：取决于计算机组成和指令集结构</li>
<li>IC：取决于指令集结构和编译技术</li>
</ol></li>
<li><p>CPU性能公式进一步细化：</p>
<p>CPIi ：第i种指令的处理时间 ICi ：在程序中第i种指令出现的次数 <span
class="math inline">\(CPU时钟周期数=\sum_{i=1}^{n}{CPI_i\times
IC_i}\)</span></p>
<p><span class="math inline">\(CPI=\frac{时钟周期数}{IC} =
\sum_{i=1}^{n}{CPI_i\times \frac{IC_i}{IC}}\)</span></p></li>
</ol></li>
<li><p>程序的局部性原理</p>
<p>程序执行时所访问的存储器地址分布不是随机的，而是相对地簇聚</p>
<p>常用的应该经验规则：程序执行时间的90%都是在执行程序中10%的代码</p>
<ul>
<li><p>程序的时间局部性：</p>
<p>程序即将用到的信息很可能就是目前正在使用的信息</p></li>
<li><p>程序的空间局部性：</p>
<p>程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近</p></li>
</ul></li>
</ol>
<h4 id="计算机系统的性能测评">计算机系统的性能测评</h4>
<ol type="1">
<li><p>执行时间和吞吐率</p>
<p>用户角度：单个程序的执行时间</p>
<p>数据管理与：吞吐率（单位时间里能够完成的任务）</p></li>
<li><p>主要标准：执行程序的时间</p>
<ol type="1">
<li>MIPS，每秒百万条指令数 <span class="math display">\[
\begin{align}
MIPS &amp;= 指令条数/(执行时间\times 10^6) \nonumber \\
&amp;= 时钟频率/(CPI\times 10^6) \nonumber
\end{align}
\]</span></li>
</ol></li>
<li><p>MFLOPS，每秒百万次浮点操作次数 = 程序中的浮点操作次数
/（执行时间×10^6）</p></li>
<li><p>利用基准测试程序</p></li>
</ol>
<h3 id="计算机系统结构的发展">1.4 计算机系统结构的发展</h3>
<h4 id="冯诺依曼结构">冯·诺依曼结构</h4>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/1-2.jpg" style="zoom:50%;" /></p>
<p>主要特点：（存储程序计算机）</p>
<ul>
<li>以运算器为中心。</li>
<li>在存储器中，指令和数据同等对待</li>
<li>存储器是按地址访问、按顺序线性编址的一维结构，每个单元的位数是固定的</li>
<li>指令的执行是顺序的</li>
<li>指令由操作码和地址码组成</li>
<li>指令和数据均以二进制编码表示，采用二进制运算</li>
</ul>
<h3 id="计算机系统中并行性的发展">1.5 计算机系统中并行性的发展</h3>
<h4 id="并行性的概念">并行性的概念</h4>
<ol type="1">
<li>并行性：计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作，只要在时间上相互重叠，就存在并行性
<ul>
<li>同时性：两个或两个以上的事件在同一时刻发生。</li>
<li>并发性：两个或两个以上的事件在同一时间间隔内发生。</li>
</ul></li>
<li>从执行程序的角度来看，并行性等级从低到高可分为
<ul>
<li>指令内部并行</li>
<li>指令级并行</li>
<li>线程级并行</li>
<li>任务级或过程级并行</li>
<li>作业或程序级并行</li>
</ul></li>
<li>提高并行性的技术途径
<ul>
<li>时间重叠</li>
<li>资源重复</li>
<li>资源共享</li>
</ul></li>
</ol>
<h2 id="第二章-计算机指令集结构mips">第二章
计算机指令集结构（MIPS）</h2>
<ul>
<li><p>CISC（复杂指令集计算机）</p>
<p>增强指令功能，把越来越多的功能交由硬件来实现，并且指令的数量也是越来越多。</p></li>
<li><p>RISC（精简指令集计算机）
尽可能地把指令集简化，不仅指令的条数少，而且指令的功能也比较简单。</p></li>
</ul>
<h2 id="第三章-流水线技术">第三章 流水线技术</h2>
<h3 id="重叠执行和先行控制">3.1 重叠执行和先行控制</h3>
<h4 id="重叠执行">重叠执行</h4>
<p>二次重叠执行过程如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-1.png" style="zoom:48%;" /></p>
<p>此时，执行n条指令花费的时间为<span
class="math inline">\(T=(2+n)t\)</span></p>
<p>有以下优点：</p>
<ul>
<li>时间缩短</li>
<li>部件利用率提高</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要增加更多的硬件</li>
<li>需要设置独立的取指令部件，指令分析部件和指令执行部件</li>
</ul>
<p>存在主存的访问冲突问题（读写主存），有以下四种解决方法：</p>
<ul>
<li><p>设置两个独立编址的存储器：
指令存储器（存放指令）、数据存储器（存放数据）</p></li>
<li><p>指令和数据仍然混合存放在同一个主存中，但设置两个Cache：指令Cache、数据Cache，<strong>程序空间和数据空间相互独立的系统结构被称为哈佛结构</strong></p></li>
<li><p>指令和数据仍然混合存放在同一个主存中，但主存采用多体交叉结构</p></li>
<li><p>在主存和指令分析部件之间增设指令缓冲站（又被称为先行指令缓冲站
）</p>
<p>先行指令缓冲站的组成如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-2.jpg" style="zoom:50%;" /></p>
<ul>
<li>指令缓冲存储区和相应的控制逻辑
<ul>
<li>按队列方式工作</li>
<li>只要指令缓冲站不满，它就自动地向主存控制器发取指令请求，不断地预取指令</li>
</ul></li>
<li>指令分析部件
<ul>
<li>每分析完一条指令，就自动向指令缓冲站发出取下一条指令的请求。指令取出之后就把指令缓冲站中的该指令作废</li>
<li>指令缓冲站中存放的指令的条数是动态变化的</li>
</ul></li>
<li>两个程序计数器
<ul>
<li>先行程序计数器PC1：用于从主存预取指令</li>
<li>现行程序计数器PC：用来记录指令分析部件当前正在分析的指令的地址</li>
</ul></li>
</ul></li>
</ul>
<p>当每个子过程执行的时间不相等时，会出现部件空闲的情况：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-3.png" style="zoom:48%;" /></p>
<h4 id="先行控制">先行控制</h4>
<ol type="1">
<li><p>先行控制技术：缓冲技术和预处理技术的结合</p>
<ul>
<li>缓冲技术：在工作速度不固定的两个功能部件之间设置缓冲器，用以平滑它们的工作</li>
<li>预处理技术：预取指令、对指令进行加工以及预取操作数等。</li>
</ul></li>
<li><p>采用先行控制方式的处理机结构</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-4.jpg" style="zoom:50%;" /></p>
<p>特点：</p>
<ul>
<li>缓冲站按先进先出的方式工作</li>
<li>每个存储单元由3部分组成：先行地址字段、先行操作数字段、标志字段</li>
</ul></li>
</ol>
<h3 id="流水线的基本概念">3.2 流水线的基本概念</h3>
<h4 id="什么是流水线">什么是流水线</h4>
<ol type="1">
<li>流水线技术
<ul>
<li>把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现</li>
<li>把多个处理过程在时间上错开，依次通过各功能段，这样，每个子过程就可以与其他的子过程并行进行</li>
</ul></li>
<li>流水线中的每个子过程及其功能部件称为流水线的级或段，段与段相互连接形成流水线。流水线的段数称为流水线的深度</li>
<li>流水技术的特点
<ul>
<li>流水线把一个处理过程分解为若干个子过程（段），每个子过程由一个专门的功能部件来实现</li>
<li>流水线中各段的时间应尽可能相等，否则将引起流水线堵塞、断流。<strong>时间长的段将成为流水线的瓶颈</strong></li>
<li>流水线每一个功能部件的后面都要有一个缓冲寄存器（锁存器），称为流水寄存器，在相邻的两段之间传送数据，以保证提供后面要用到的数据，并把各段的处理工作相互隔离</li>
<li><strong>流水技术适合于大量重复的时序过程，只有在输入端不断地提供任务，才能充分发挥流水线的效率</strong></li>
<li>流水线需要有通过时间和排空时间
<ul>
<li>通过时间：第一个任务从进入流水线到流出结果所需的时间</li>
<li>排空时间：最后一个任务从进入流水线到流出结果所需的时间</li>
</ul></li>
</ul></li>
</ol>
<h4 id="流水线的分类">流水线的分类</h4>
<ul>
<li><p>单功能流水线于多功能流水线</p>
<ul>
<li>单功能：只能完成一种固定功能的流水线</li>
<li>多功能：流水线的各段可以进行不同的连接，以实现不同的功能</li>
</ul></li>
<li><p>静态与动态流水线</p>
<ul>
<li>静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作，只有输入为一串相同的运算任务时，流水的效率才得到充分的发挥</li>
<li>动态流水线：在同一时间内，多功能流水线中的各段可以按照不同的方式连接，同时执行多种功能</li>
</ul>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-5.png" style="zoom:75%;" /></p></li>
<li><p>部件级、处理机级及处理机间流水线</p>
<ul>
<li>部件级流水线（运算操作流水线）：把处理机的算术逻辑运算部件分段，使得各种类型的运算操作能够按流水方式进行</li>
<li>处理机级流水线（指令流水线）：把指令的解释执行过程按照流水方式处理。把一条指令的执行过程分解为若干个子过程，每个子过程在独立的功能部件中执行</li>
<li>处理机间流水线（宏流水线）：它是由两个或者两个以上的处理机串行连接起来，对同一数据流进行处理，每个处理机完成整个任务中的一部分</li>
</ul></li>
<li><p>线性流水线和非线性流水线</p>
<ul>
<li>线性流水线：流水线的各段串行连接，没有反馈回路。数据通过流水线中的各段时，每一个段最多只流过一次</li>
<li>非线性流水线：流水线中除了有串行的连接外，还有反馈回路</li>
</ul></li>
<li><p>顺序流水线和乱序流水线</p>
<ul>
<li>顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的。</li>
<li>乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）</li>
</ul></li>
<li><p>标量处理机与向量流水处理机</p>
<ul>
<li>标量处理机：处理机不具有向量数据表示和向量指令，仅对标量数据进行流水处理</li>
<li>向量流水处理机：具有向量数据表示和向量指令的处理机</li>
</ul></li>
</ul>
<h3 id="流水线的性能指标">3.3 流水线的性能指标</h3>
<h4 id="吞吐率">吞吐率</h4>
<blockquote>
<p>在单位时间内流水线所完成的任务数量或输出结果的数量，<span
class="math inline">\(TP=\frac{n}{T_k}\)</span>，其中n为任务数，<span
class="math inline">\(T_k\)</span>为处理完成n个任务所用的时间</p>
</blockquote>
<ol type="1">
<li><p>各段时间均相等的流水线</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-6.jpg" style="zoom:50%;" /></p>
<p>由图可以得出，此流水线的实际吞吐率为:</p>
<p><span class="math inline">\(TP=\frac{n}{(k+n-1)\Delta t}\)</span></p>
<p>最大吞吐率为：</p>
<p><span class="math inline">\(TP_{max} = lim_{n\rightarrow \infty}
\frac{n}{(k+n-1)\Delta t} = \frac{1}{\Delta t}\)</span></p></li>
<li><p>各段不完全相等的流水线</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-7.jpg" style="zoom:70%;" /></p>
<p>实际吞吐率如下：</p>
<p><span class="math inline">\(TP = \frac{n}{\sum_{i=1}^{k}\Delta
t_i+(n-1)max(\Delta t_1, \dots,\Delta t_k)}\)</span></p>
<p>同样的最大吞吐率为：</p>
<p><span class="math inline">\(TP_{max} = \frac{1}{max(\Delta t_1,
\dots,\Delta t_k)}\)</span></p></li>
</ol>
<p>解决流水线瓶颈问题的常用方法</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-8.jpg" style="zoom:50%;" /></p>
<ol type="1">
<li><p>细分瓶颈段</p>
<p>对上图<span
class="math inline">\(S_3\)</span>，将其划分为3个子流水线段即可</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-9.jpg" style="zoom:50%;" /></p></li>
<li><p>重复设置瓶颈段</p>
<p>使用空间弥补的方法，对$S_3 $只需要设置3个即可</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-10.jpg" style="zoom:50%;" /></p>
<p>重置后的时空图如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-11.jpg" style="zoom:50%;" /></p></li>
</ol>
<h4 id="加速比">加速比</h4>
<blockquote>
<p>完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比</p>
</blockquote>
<p>即：<span class="math inline">\(S=\frac{T_s}{T_k}\)</span>，<span
class="math inline">\(T_s\)</span>为顺序执行所用的时间，<span
class="math inline">\(T_k\)</span>为流水线后的时间</p>
<ol type="1">
<li><p>流水线各段时间相等</p>
<p>此时流水线实际加速比为：<span
class="math inline">\(S=\frac{nk}{k+n-1}\)</span>，最大加速比为k，当<span
class="math inline">\(n\rightarrow \infty\)</span>时取到</p></li>
<li><p>流水线的各段时间不完全相等时 <span class="math display">\[
S=\frac{n\sum_{i=1}^k \Delta t_i}{\sum_{i=1}^k \Delta
t_i+(n-1)max{\Delta t_1,\dots,\Delta t_k}}
\]</span></p></li>
</ol>
<h4 id="效率">效率</h4>
<blockquote>
<p>流水线中的设备实际使用时间与整个运行时间的比值，即流水线设备的利用率。由于流水线有通过时间和排空时间，所以在连续完成n个任务的时间内，各段并不是满负荷地工作</p>
</blockquote>
<p>从时空图上看，效率就是n个任务占用的时空面积和k个段总的时空面积之比</p>
<ol type="1">
<li><p>各段时间相等：</p>
<p>根据面积比可以得出：<span class="math inline">\(E=\frac{n\Delta
t}{(k+n-1)\Delta t} =
\frac{n}{k+n-1}\)</span>，可以看出和吞吐率有关系，为<span
class="math inline">\(E=TP\Delta
t\)</span>，同样的和加速比也有关系，<span class="math inline">\(E =
\frac{S}{k}\)</span></p></li>
<li><p>各段时间不相等时： <span class="math display">\[
E=\frac{n\sum_{i=1}^k \Delta t_i}{k[\sum_{i=1}^k \Delta t_i+(n-1)\times
max{\Delta t_1,\dots,\Delta t_k}]}
\]</span></p></li>
</ol>
<h4 id="流水线设计中的若干问题">流水线设计中的若干问题</h4>
<ol type="1">
<li><p>瓶颈问题</p>
<ul>
<li>理想情况下，流水线在工作时，其中的任务是同步地每一个时钟周期往前流动一段</li>
<li>当流水线各段不均匀时，机器的时钟周期取决于瓶颈段的延迟时间</li>
<li>在设计流水线时，要尽可能使各段时间相等</li>
</ul></li>
<li><p>流水线的额外开销</p>
<ul>
<li>流水寄存器需要建立时间和传输延迟</li>
<li>时钟偏移开销</li>
</ul>
<p>注意几个细节：</p>
<ul>
<li>流水线并不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率</li>
<li>增加流水线的深度（段数）可以提高流水线的性能</li>
<li>流水线的深度受限于流水线的额外开销</li>
<li>当时钟周期小到与额外开销相同时，流水已没意义。因为这时在每一个时钟周期中已没有时间来做有用的工作</li>
</ul></li>
<li><p>冲突问题</p></li>
</ol>
<h3 id="流水线的相关与冲突">3.4 流水线的相关与冲突</h3>
<h4 id="经典5段流水线">经典5段流水线</h4>
<p>虚线代表此处仅花费时钟单元的一半时间,
可以在前半段时间写回后半段从寄存器读取</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-13.jpg" style="zoom:50%;" /></p>
<ol type="1">
<li><p>取指令周期IF</p></li>
<li><p>指令译码/读寄存器周期（ID）</p></li>
<li><p>执行/有效地址计算周期（EX）</p>
<p>4种不同指令所进行的操作不同：</p>
<ul>
<li>存储器访问指令：ALU把所指定的寄存器的内容与偏移量相加，形成用于访存的有效地址</li>
<li>寄存器－寄存器ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的数据进行运算</li>
<li>寄存器－立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读取的第一操作数和立即数进行运算</li>
<li>分支指令：ALU把偏移量与PC值相加，形成转移目标的地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功</li>
</ul></li>
<li><p>存储器访问／分支完成周期（MEM）</p>
<p>该周期处理的指令只有load、store和分支指令（分支“成功”，就把转移目标地址送入PC）。其他类型的指令在此周期不做任何操作</p></li>
<li><p>写回周期（WB）</p>
<p>ALU运算指令和load指令在这个周期把结果数据写入通用寄存器组</p></li>
</ol>
<p>采用流水线实现时需要解决的问题：</p>
<ol type="1">
<li>要保证不会在同一时钟周期要求同一个功能段做两件不同的工作</li>
<li>避免IF段的访存（取指令）与MEM段的访存（读/写数据）发生冲突</li>
<li>ID段和WB段都要访问同一寄存器文件，<strong>把写操作安排在时钟周期的前半拍完成，把读操作安排在后半拍完成</strong>，解决对同一寄存器的访问冲突</li>
<li>考虑PC的问题，在MEM段进行的分支和IF段取下一个PC的冲突</li>
</ol>
<h4 id="相关与流水线冲突">相关与流水线冲突</h4>
<h5 id="相关">相关</h5>
<blockquote>
<p>两条指令之间存在某种依赖关系。如果两条指令相关，则它们就有可能不能在流水线中重叠执行或者只能部分重叠执行</p>
</blockquote>
<p>有三种类型：</p>
<p><strong>前提条件：对于两个指令i，j且i在j前</strong></p>
<ul>
<li><p><strong>数据相关（真数据相关）</strong></p>
<p>满足下列条件表明j与i数据相关，数据相关具有传递性</p>
<ul>
<li>指令j使用指令i产生的结果</li>
<li>指令j与k数据相关，k与i数据相关</li>
</ul>
<p>寄存器的数据相关比较容易检测，单存储器检测比较复杂，因为有效地址生成的规则复杂</p></li>
<li><p><strong>名相关</strong></p>
<p>如果两条指令使用相同的名，但是它们之间并<strong>没有数据流动</strong>（不存在数据相关），则称这两条指令存在名相关，如果一条指令中的名改变了，并不影响另外一条指令的执行</p>
<ul>
<li>反相关：指令j写的名＝指令i读的名</li>
<li>输出相关：指令j写的名＝指令i写的名</li>
</ul>
<p>通过<strong>换名技术</strong>消除名相关：通过改变指令中操作数的名来消除名相关，对于寄存器操作数进行换名称为寄存器换名</p></li>
<li><p><strong>控制相关</strong></p>
<p>控制相关是指由分支指令引起的相关，有以下两个限制</p>
<ul>
<li>与一条分支指令控制相关的指令不能被移到该分支之前，否则这些指令就不受该分支控制了</li>
<li>如果一条指令与某分支指令不存在控制相关，就不能把该指令移到该分支之后</li>
</ul></li>
</ul>
<h5 id="流水线冲突">流水线冲突</h5>
<blockquote>
<p>是指对于具体的流水线来说，由于相关的存在，使得指令流中的下一条指令不能在指定的时钟周期执行</p>
</blockquote>
<p>带来的问题：</p>
<ul>
<li>导致错误的执行结果</li>
<li>流水线可能会出现停顿，从而降低流水线的效率和实际的加速比</li>
</ul>
<p>当一条指令被暂停时，在该暂停指令之后流出的所有指令都要被暂停，而在该暂停指令之前流出的指令则继续进行（否则就永远无法消除冲突）</p>
<p>有三种类型：</p>
<ul>
<li><p><strong>结构冲突</strong></p>
<p>因硬件资源满足不了指令重叠执行的要求而发生的冲突</p>
<p>有些流水线处理机只有一个存储器，将数据和指令放在一起，访存指令会导致访存冲突</p>
<p><strong>通过插入暂停周期（气泡）</strong>解决，或者设置独立的指令存储器和数据存储器或者设置独立的Cache</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-14.jpg" style="zoom:40%;" /></p>
<p>插入气泡后：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-15.jpg" style="zoom:40%;" /></p>
<p>结构冲突有时候是允许的，可以减少硬件成本</p></li>
<li><p><strong>数据冲突</strong></p>
<p>当指令在流水线中重叠执行时，因需要用到前面指令的执行结果而发生的冲突</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-16.jpg" style="zoom:40%;" /></p>
<p><strong>前提条件：对于两个指令i，j且i在j前</strong>，有以下三种类型：</p>
<ul>
<li><p>写后读冲突RAW</p>
<p>在i写之前j去读，对于真数据相关</p></li>
<li><p>写后写冲突WAW</p>
<p>在i写入之前j先写，对应输出相关</p>
<p>仅发生在这样的流水线中：</p>
<ul>
<li>流水线中不只一个段可以进行写操作</li>
<li>当先前某条指令停顿时，允许其后续指令继续前进</li>
</ul>
<p>我们之前的5段流水线不会发生</p></li>
<li><p>读后写冲突WAR</p>
<p>在i读之前j先写，对应反相关</p>
<p>仅发生这样的流水线中：</p>
<ul>
<li>有些指令的写结果操作提前了，而且有些指令的读操作滞后了</li>
<li>指令被重新排序了</li>
</ul>
<p>我们之前的5段流水线不会发生</p></li>
</ul>
<p><strong>通过定向技术（也称为旁路或短路），减少数据冲突引起的停顿：</strong></p>
<p>关键思想：在某条指令产生计算结果之前，后面等待使用该结果的指令并不一定立即需要该结果，如果能够将该计算结果从其产生的地方（ALU出口）直接送到其他指令需要它的地方（ALU入口），那么就可以避免停顿。</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-17.jpg" style="zoom:40%;" /></p>
<p>并不是所有的数据冲突都可以用定向技术来解决，必要时需要增加<strong>暂停</strong>：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-18.jpg" style="zoom:40%;" /></p>
<p><strong>通过编译器解决数据冲突</strong></p>
<p>改变指令的执行顺序解决数据冲突</p></li>
<li><p><strong>控制冲突</strong></p>
<p>流水线遇到分支指令和其他会改变PC值的指令所引起的冲突</p>
<p>处理分支指令最简单的方法：排空流水线，给流水线带来3个时钟周期的延迟</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-19.jpg" style="zoom:70%;" /></p>
<p>由分支指令引起的延迟为<strong>分支延迟</strong></p>
<p>可采取两种措施来减少分支延迟</p>
<ul>
<li>在流水线中尽早判断出分支转移是否成功</li>
<li>尽早计算出分支目标地址</li>
</ul>
<p>下面的讨论中，我们假设：这两步工作被提前到ID段完成，即分支指令是在ID段的末尾执行完成，所带来的分支延迟为一个时钟周期</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-20.jpg" style="zoom:50%;" /></p>
<p><strong>减少分支延迟的方法</strong>:</p>
<p>共同点:</p>
<ul>
<li><p>对分支的处理方法在程序的执行过程中始终是不变的，是静态的</p></li>
<li><p>要么总是预测分支成功，要么总是预测分支失败</p></li>
<li><p><strong>预测分支失败</strong></p>
<p>允许分支指令后的指令继续在流水线中流动，就好象什么都没发生似的
若确定分支失败，将分支指令看作是一条普通指令，流水线正常流动</p>
<p>要保证：分支结果出来之前不会改变处理机的状态，以便一旦猜错时，处理机能够回退到原先的状态</p></li>
</ul></li>
<li><p><strong>预测分支成功</strong></p>
<p>假设分支转移成功，并从分支目标地址处取指令执行。
起作用的前题：先知道分支目标地址，后知道分支是否成功
前述5段流水线中，这种方法没有任何好处</p></li>
<li><p><strong>延迟分支</strong></p>
<p>从逻辑上“延长”分支指令的执行时间。把延迟分支看成是由原来的分支指令和若干个延迟槽构成，不管分支是否成功，都要按顺序执行延迟槽中的指令</p>
<pre><code>  &lt;img src=&quot;/assets/Note/计算机系统结构-张晨曦-第二版/3-21.jpg&quot; style=&quot;zoom:70%;&quot; /&gt;</code></pre>
<p>分支延迟指令的调度:</p>
<ul>
<li><p>从前调度</p>
<ul>
<li>从目标处调度</li>
</ul></li>
<li><p>从失败处调度</p></li>
</ul>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-22.jpg" style="zoom:70%;" /></p>
<pre><code>  分支延迟受到两个方面的限制：</code></pre>
<ul>
<li><p>可以被放入延迟槽中的指令要满足一定的条件</p>
<ul>
<li>编译器预测分支转移方向的能力。</li>
</ul>
<p>进一步改进：分支取消机制（取消分支）
当分支的实际执行方向和事先所预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化成一个空操作</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/3-23.jpg" style="zoom:70%;" /></p></li>
</ul></li>
</ul>
<h3 id="向量处理机">3.5 向量处理机</h3>
<blockquote>
<p>在流水线处理机中，设置向量数据表示和相应的向量指令，称为向量处理机。
不具有向量数据表示和相应的向量指令的流水线处理机，称为标量处理机</p>
</blockquote>
<h2 id="第四章-指令级并行">第四章 指令级并行</h2>
<h3 id="指令级并行的概念-ilp">4.1 指令级并行的概念 ILP</h3>
<p>几乎所有的处理机都利用流水线来使指令重叠并行执行，以达到提高性能的目的。这种指令之间存在的潜在并行性称为指令级并行
ILP：Instruction-Level Parallelism</p>
<h3 id="指令的调度">4.2 指令的调度</h3>
<h4 id="静态和动态调度">静态和动态调度</h4>
<ul>
<li><p>静态调度</p>
<p><strong>依靠编译器</strong>对代码进行静态调度，以减少相关和冲突。它不是在程序执行的过程中、而是在编译期间进行代码调度和优化。通过把相关的指令拉开距离来减少可能产生的停顿</p></li>
<li><p>动态调度</p>
<p>在程序的执行过程中，<strong>依靠专门硬件</strong>对代码进行调度，减少数据相关导致的停顿</p>
<p>优点：</p>
<ol type="1">
<li>能够处理一些在编译时情况不明的相关（比如涉及到存储器访问的相关），并简化了编译器</li>
<li>能够使本来是面向某一流水线优化编译的代码在其他的流水线（动态调度）上也能高效地执行</li>
</ol>
<p>但增加了硬件复杂性</p></li>
</ul>
<h4 id="非线性流水线的调度问题">非线性流水线的调度问题</h4>
<p>非线性流水线中由于有些段需要在时间上复用，就不能像线性流水线那样逐时段连续地输入指令。把前一条指令输入开始到下一条指令输入为止的时间差，称为<strong>启动距离</strong></p>
<p>那些会引起冲突的启动距离，被称为禁止启动距离。将在任何时间都不会发生冲突的启动距离称为启动循环</p>
<h4 id="最优调度方法">最优调度方法</h4>
<p>为了避免冲突，就要对指令输入流水线的时间进行控制，这个任务就是流水线的无冲突调度。方案如下：</p>
<ol type="1">
<li><p><strong>根据预约表写出禁止向量</strong></p>
<p>禁止向量：各个段内的X标记的差的集合</p></li>
<li><p><strong>由禁止向量变换成初始冲突向量</strong></p>
<p>使用<span class="math inline">\(初始冲突向量：C_0=(C_mC_{m-1}\dots
C_2C_1)\)</span>，m为冲突向量的最大值，根据禁止向量，令<span
class="math inline">\(C_m = 1\)</span>，仅当<span
class="math inline">\(m \in 禁止向量\)</span></p></li>
<li><p><strong>根据初始冲突向量推算出全部冲突向量</strong></p>
<p>从初始冲突向量出发，检查其中0的位，假设初始向量中<span
class="math inline">\(C_k =
0\)</span>，就将初始向量右移K位之后和初始向量执行或运算，若得到一个新的向量，继续检查0的位，执行右移运算，并和<span
class="math inline">\(C_0\)</span>做或运算，直到不存在新的向量</p></li>
<li><p><strong>画出表示冲突向量迁移的有向图</strong></p>
<p>节点值为向量，边权为右移的位数，构建有向图</p></li>
<li><p><strong>从全部调度方案中选出最优调度法</strong></p>
<p>从<strong>各个闭合回路</strong>（不需要从初始向量出发）中找出平均间隔最小的一个，平均间隔为边权和除以边数</p></li>
</ol>
<p>例题：</p>
<p>某单功能流水线预约表如下：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>t1</th>
<th>t2</th>
<th>t3</th>
<th>t4</th>
<th>t5</th>
<th>t6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S1</td>
<td>×</td>
<td></td>
<td></td>
<td></td>
<td>×</td>
<td></td>
</tr>
<tr class="even">
<td>S2</td>
<td></td>
<td>×</td>
<td></td>
<td></td>
<td></td>
<td>×</td>
</tr>
<tr class="odd">
<td>S3</td>
<td></td>
<td></td>
<td>×</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>S4</td>
<td></td>
<td></td>
<td></td>
<td>×</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>请确定最佳调度方案。按此方案输入8个指令时，性能指标如何？</p>
<p>禁止向量为：<span
class="math inline">\(F={4}\)</span>，初始冲突向量为：<span
class="math inline">\(C_0 = (1000)\)</span></p>
<p>获取状态转换图：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-1.jpg" style="zoom:50%;" /></p>
<p>其中5权值边可以看作是0C，右移5位形成的，构建成新的闭合回路</p>
<p>可以获得调度方案如下：</p>
<table>
<thead>
<tr class="header">
<th>回路</th>
<th>平均间隔</th>
<th>回路</th>
<th>平均间隔</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1,5</td>
<td>6/2</td>
<td>2,1,2,5</td>
<td>10/4</td>
</tr>
<tr class="even">
<td>1,1,5</td>
<td>7/3</td>
<td>2,3,5</td>
<td>10/3</td>
</tr>
<tr class="odd">
<td><strong>1,1,1,5</strong></td>
<td><strong>8/4</strong></td>
<td>3,5</td>
<td>8/2</td>
</tr>
<tr class="even">
<td>1,2,5</td>
<td>8/3</td>
<td>3</td>
<td>3</td>
</tr>
<tr class="odd">
<td>1,2,3,5</td>
<td>11/4</td>
<td>3,2,5</td>
<td>10/3</td>
</tr>
<tr class="even">
<td>2,5</td>
<td>7/3</td>
<td>3,2,1,5</td>
<td>11/4</td>
</tr>
<tr class="odd">
<td>2,1,5</td>
<td>8/3</td>
<td>2,3</td>
<td>5/2</td>
</tr>
</tbody>
</table>
<p>最佳方案为1，1，1，5，平均最少延时为2拍</p>
<p>8个指令进入流水线的时空图如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-2.jpg" style="zoom:50%;" /></p>
<p>吞吐率 P = 8/(17Δt)； 加速比 S = (6Δt×8)/(17Δt)=48/17 效率 E =
(6Δt×8) /(17Δt×4)=12/17</p>
<h4 id="动态调度的基本思想">动态调度的基本思想</h4>
<p>到目前为止我们所使用流水线的最大的局限性，指令必须按序流出和执行，一旦一条指令受阻，其后的指令都将停顿，可以通过乱序执行解决。动态调度的流水线支持多条指令同时处于执行当中。</p>
<p>指令乱序完成带来的最大问题：</p>
<ul>
<li><p>异常处理比较复杂</p></li>
<li><p>动态调度要保持正确的异常行为</p>
<p>只有那些在程序严格按程序顺序执行时会发生的异常，才能真正发生</p></li>
</ul>
<h4 id="tomasulo算法">Tomasulo算法</h4>
<blockquote>
<p>记录和检测指令相关，操作数一旦就绪就立即执行，把发生RAW冲突的可能性减少到最小通过寄存器换名来消除WAR冲突和WAW冲突</p>
</blockquote>
<p>基于MIPS的Tomasulo基本结构：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-3.jpg" style="zoom:50%;" /></p>
<ul>
<li><p>保留站</p>
<p>每个保留站中保存一条已经流出并等待到本功能部件执行的指令（相关信息）包括：操作码、操作数以及用于检测和解决冲突的信息</p>
<p>上图有3个浮点加法器保留站，2个浮点乘法器保留站</p>
<p>每个保留站都有一个标识字段，唯一地标识了该保留站</p></li>
<li><p>公共数据总线CDB</p>
<p>所有功能部件的计算结果都是送到CDB上，由它把这些结果直接送到（播送到）各个需要该结果的地方。在具有多个执行部件且采用多流出（即每个时钟周期流出多条指令）的流水线中，需要采用多条CDB</p></li>
<li><p>load缓冲器和store缓冲器</p>
<p>存放读/写存储器的数据或地址 load缓冲器的作用有3个：</p>
<ul>
<li>存放用于计算有效地址的分量</li>
<li>记录正在进行的load访存，等待存储器的响应</li>
<li>保存已经完成了的load的结果（即从存储器取来的数据），等待CDB传输</li>
</ul>
<p>store缓冲器的作用有3个：</p>
<ul>
<li>存放用于计算有效地址的分量</li>
<li>保存正在进行的store访存的目标地址，该store正在等待存储数据的到达</li>
<li>保存该store的地址和数据，直到存储部件接收</li>
</ul></li>
<li><p>浮点寄存器FP</p>
<p>它们通过一对总线连接到功能部件，并通过CDB连接到store缓冲器</p></li>
<li><p>指令队列</p>
<p>指令部件送来的指令放入指令队列
指令队列中的指令按先进先出的顺序流出</p></li>
<li><p>运算部件</p></li>
</ul>
<p>Tomasulo算法具有以下两个特点:</p>
<ul>
<li>冲突检测和指令执行控制是分布的</li>
<li>计算结果通过CDB直接从产生它的保留站传送到所有需要它的功能部件，而不用经过寄存器</li>
</ul>
<p>指令执行的步骤：</p>
<ol type="1">
<li><p><strong>流出：从指令队列的头部取一条指令</strong></p>
<ul>
<li>如果该指令的操作所要求的保留站有空闲的，就把该指令送到该保留站</li>
<li>如果其操作数在寄存器中已经就绪，就将这些操作数送入保留站</li>
<li>如果其操作数还没有就绪，就把将产生该操作数的保留站的标识送入保留站</li>
<li>一旦被记录的保留站完成计算，它将直接把数据送给保留站</li>
<li>完成对目标寄存器的预约工作</li>
<li>如果没有空闲的保留站，指令就不能流出</li>
</ul></li>
<li><p><strong>执行</strong></p>
<ul>
<li>当两个操作数都就绪后，本保留站就用相应的功能部件开始执行指令规定的操作</li>
<li>load和store指令的执行需要两个步骤：
<ul>
<li>计算有效地址（要等到基地址寄存器就绪）</li>
<li>把有效地址放入load或store缓冲器</li>
</ul></li>
</ul></li>
<li><p><strong>写结果</strong></p>
<p>功能部件计算完毕后，就将计算结果放到CDB上，所有等待该计算结果的寄存器和保留站（包括store缓冲器）都同时从CDB上获得所需要的数据</p></li>
</ol>
<p>Tomasulo示例：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-4.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-5.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-6.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-7.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-8.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-9.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-10.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-11.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-12.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-13.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-14.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-15.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-16.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-17.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-18.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-19.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-20.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-21.jpg" style="zoom:50%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-22.jpg" style="zoom:50%;" /></p>
<h3 id="动态分支预测技术">4.3 动态分支预测技术</h3>
<p>所开发的ILP越多，控制相关的制约就越大，分支预测就要有更高的准确度</p>
<p><strong>动态分支预测：</strong>在程序运行时，根据分支指令过去的表现来预测其将来的行为</p>
<p>分支预测的有效性取决于:</p>
<ul>
<li><p>预测的准确性</p></li>
<li><p>预测正确和不正确两种情况下的分支开销</p>
<p>决定分支开销的因素</p>
<ul>
<li>流水线的结构</li>
<li>预测的方法</li>
<li>预测错误时的恢复策略等</li>
</ul></li>
<li><p>采用动态分支预测技术的目的</p>
<ul>
<li>预测分支是否成功</li>
<li>尽快找到分支目标地址（或指令）</li>
</ul></li>
</ul>
<h4 id="采用分支历史表-bht">采用分支历史表 BHT</h4>
<blockquote>
<p>最简单的动态分支预测方法，用BHT来记录分支指令最近一次或几次的执行情况（成功或不成功），并据此进行预测</p>
</blockquote>
<ul>
<li><p>只有1个预测位的分支预测缓冲</p>
<p>记录分支指令最近一次的历史，BHT中只需要1位二进制位</p></li>
<li><p>采用两位二进制位来记录历史</p>
<p>提高预测的准确度，研究结果表明：两位分支预测的性能与n位（n&gt;2）分支预测的性能差不多</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-23.jpg" style="zoom:50%;" /></p></li>
</ul>
<p>适用情况：</p>
<p><strong>判定分支是否成功所需的时间大于确定分支目标地址所需的时间</strong></p>
<p>由于判定分支是否成功和计算分支目标地址都是在ID段完成，所以BHT方法不会给该流水线带来好处。</p>
<h4 id="采用分支目标缓冲器btb">采用分支目标缓冲器BTB</h4>
<p>目标：将分支的开销降为 0</p>
<p>方法：分支目标缓冲</p>
<ul>
<li>将分支成功的分支指令的地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识</li>
<li>这个缓冲区就是分支目标缓冲器（Branch-Target
Buffer，简记为BTB，或者Branch-Target Cache）</li>
</ul>
<p>结构如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-24.jpg" style="zoom:50%;" /></p>
<p>看成是用专门的硬件实现的一张表格。 表格中的每一项至少有两个字段：</p>
<ul>
<li>执行过的成功分支指令的地址；（作为该表的匹配标识 ）</li>
<li>预测的分支目标地址</li>
</ul>
<p>执行流程如下：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-25.jpg" style="zoom:50%;" /></p>
<p>BTB的另一种形式:</p>
<p>在分支目标缓冲器中存放一条或者多条分支目标处的指令，有三个好处：</p>
<ul>
<li>更快地获得分支目标处的指令</li>
<li>可以一次提供分支目标处的多条指令，这对于多流出处理器是很有必要的</li>
<li>使我们可以进行称为分支折叠（branch folding）的优化</li>
</ul>
<h4 id="基于硬件的前瞻执行">基于硬件的前瞻执行</h4>
<p>基本思想（延迟写入）：</p>
<p>对分支指令的结果进行猜测，并假设这个猜测总是对的，然后按这个猜测结果继续取、流出和执行后续的指令。只是执行指令的结果不是写回到寄存器或存储器，而是放到一个称为ROB（ReOrder
Buffer）的缓冲器中。等到相应的指令得到“确认”（commit）（即确实是应该执行的）之后，才将结果写入寄存器或存储器</p>
<ol type="1">
<li><p>基于硬件的前瞻执行结合了三种思想</p>
<ul>
<li>动态分支预测。用来选择后续执行的指令</li>
<li>在控制相关的结果尚未出来之前，前瞻地执行后续指令</li>
<li>用动态调度对基本块的各种组合进行跨基本块的调度</li>
</ul></li>
<li><p>对Tomasulo算法加以扩充，就可以支持前瞻执行</p>
<p>把Tomasulo算法的写结果和指令完成加以区分，分成两个不同的段：</p>
<ul>
<li><p>写结果段</p>
<p>把前瞻执行的结果写到ROB中通过CDB在指令之间传送结果，供需要用到这些结果的指令使用</p></li>
<li><p>指令确认段</p>
<p>在分支指令的结果出来后，对相应指令的前瞻执行给予确认。如果前面所做的猜测是对的，把在ROB中的结果写到寄存器或存储器。如果发现前面对分支结果的猜测是错误的，那就不予以确认，并从那条分支指令的另一条路径开始重新执行。</p></li>
</ul></li>
</ol>
<p><strong>实现前瞻的关键思想</strong>：允许指令乱序执行，但必须顺序确认</p>
<p>符合前瞻执行的结构：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/4-26.jpg" style="zoom:50%;" /></p>
<p>ROB中的每一项由以下4个字段组成：</p>
<ul>
<li><p>指令类型</p>
<p>指出该指令是分支指令、store指令或寄存器操作指令</p></li>
<li><p>目标地址
给出指令执行结果应写入的目标寄存器号（如果是load和ALU指令）或存储器单元的地址（如果是store指令）</p></li>
<li><p>数据值字段 用来保存指令前瞻执行的结果，直到指令得到确认</p></li>
<li><p>就绪字段 指出指令是否已经完成执行并且数据已就绪</p></li>
</ul>
<p>Tomasulo算法中保留站的换名功能是由ROB来完成的</p>
<p><strong>采用前瞻执行机制后，指令的执行步骤</strong>：</p>
<ol type="1">
<li><p>流出</p>
<ul>
<li>从浮点指令队列的头部取一条指令</li>
<li>如果有空闲的保留站（设为r）且有空闲的ROB项（设为b），就流出该指令，并把相应的信息放入保留站r和ROB项b</li>
<li>如果保留站或ROB全满，便停止流出指令，直到它们都有空闲的项</li>
</ul></li>
<li><p>执行</p>
<ul>
<li>如果有操作数尚未就绪，就等待，并不断地监测CDB。(检测RAW冲突)</li>
<li>当两个操作数都已在保留站中就绪后，就可以执行该指令的操作</li>
</ul></li>
<li><p>写结果</p>
<ul>
<li>当结果产生后，将该结果连同本指令在流出段所分配到的ROB项的编号放到CDB上，经CDB写到ROB以及所有等待该结果的保留站</li>
<li>释放产生该结果的保留站</li>
<li>store指令在本阶段完成，其操作为：
<ul>
<li>如果要写入存储器的数据已经就绪，就把该数据写入分配给该store指令的ROB项。</li>
<li>否则，就监测CDB，直到那个数据在CDB上播送出来，这时才将之写入分配给该store指令的ROB项。</li>
</ul></li>
</ul></li>
<li><p>确认</p>
<p>对分支指令、store指令以及其他指令的处理不同</p>
<ul>
<li><p>其他指令（除分支指令和store指令）</p>
<p>当该指令到达ROB队列的头部而且其结果已经就绪时，就把该结果写入该指令的目标寄存器，并从ROB中删除该指令</p></li>
<li><p>store指令</p>
<p>处理与上面类似，只是它把结果写入存储器</p></li>
<li><p>分支指令</p>
<ul>
<li>当预测错误的分支指令到达ROB队列的头部时，清空ROB，并从分支指令的另一个分支重新开始执行（错误的前瞻执行）</li>
<li>当预测正确的分支指令到达ROB队列的头部时，该指令执行完毕</li>
</ul></li>
</ul></li>
</ol>
<h3 id="多指令流出技术">4.4 多指令流出技术</h3>
<ol type="1">
<li>多流出处理机有两种基本风格
<ul>
<li>超标量
<ul>
<li>在每个时钟周期流出的指令条数不固定，依代码的具体情况而定。（有上限）</li>
<li>设这个上限为n，就称该处理机为n流出</li>
<li>可以通过编译器进行静态调度，也可以基于Tomasulo算法进行动态调度</li>
</ul></li>
<li>超长指令字VLIW
<ul>
<li>在每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者一个指令包。</li>
<li>指令包中，指令之间的并行性是通过指令显式地表示出来的。</li>
<li>指令调度是由编译器静态完成的</li>
</ul></li>
</ul></li>
<li>超标量处理机与VLIW处理机相比有两个优点
<ul>
<li>超标量结构对程序员是透明的，因为处理机能自己检测下一条指令能否流出，从而不需要重新排列指令来满足指令的流出。</li>
<li>即使是没有经过编译器针对超标量结构进行调度优化的代码或是旧的编译器生成的代码也可以运行，当然运行的效果不会很好</li>
</ul></li>
</ol>
<h4 id="基于动态调度的多流出技术">基于动态调度的多流出技术</h4>
<p>扩展Tomasulo算法：支持两路超标量</p>
<ul>
<li>每个时钟周期流出两条指令</li>
<li>一条是整数指令，另一条是浮点指令</li>
</ul>
<ol type="1">
<li><p>采用一种比较简单的方法</p>
<ul>
<li>指令按顺序流向保留站，否则会破坏程序语义</li>
<li>将整数所用的表结构与浮点用的表结构分离开，分别进行处理，这样就可以同时地流出一条浮点指令和一条整数指令到各自的保留站</li>
</ul></li>
<li><p>有两种不同的方法可以实现多流出</p>
<p>关键在于：对保留站的分配和对流水线控制表格的修改</p>
<ul>
<li>在半个时钟周期里完成流出步骤，这样一个时钟周期就能处理两条指令。</li>
<li>设置一次能同时处理两条指令的逻辑电路</li>
</ul></li>
</ol>
<h4 id="超长指令字技术vliw">超长指令字技术（VLIW）</h4>
<ul>
<li>把能并行执行的多条指令组装成一条很长的指令。（100多位到几百位）</li>
<li>设置多个功能部件</li>
<li>指令字被分割成一些字段，每个字段称为一个操作槽，直接独立地控制一个功能部件</li>
<li>在VLIW处理机中，所有的处理和指令安排都是由编译器完成的</li>
</ul>
<p>VLIW存在的一些问题</p>
<ul>
<li><p>程序代码长度增加了</p>
<ul>
<li>提高并行性而进行的大量的循环展开</li>
<li>指令字中的操作槽并非总能填满</li>
</ul></li>
<li><p>采用了锁步机制</p>
<p>任何一个操作部件出现停顿时，整个处理机都要停顿</p></li>
<li><p>机器代码的不兼容性</p></li>
</ul>
<h4 id="多流出处理器受到的限制">多流出处理器受到的限制</h4>
<ol type="1">
<li>程序所固有的指令级并行性</li>
<li>硬件实现上的困难</li>
<li>超标量和超长指令字处理器固有的技术限制</li>
</ol>
<h5 id="超流水线处理机">超流水线处理机</h5>
<ul>
<li>将每个流水段进一步细分，这样在一个时钟周期内能够分时流出多条指令。这种处理机称为超流水线处理机。</li>
<li>对于一台每个时钟周期能流出n条指令的超流水线计算机来说，这n条指令不是同时流出的，而是每隔1/n个时钟周期流出一条指令实际上该超流水线计算机的流水线周期为1/n个时钟周期</li>
</ul>
<h2 id="第5章-存储层次">第5章 存储层次</h2>
<h3 id="存储器的层次结构">5.1 存储器的层次结构</h3>
<p>假设：S（容量），<span
class="math inline">\(T_A\)</span>（访问时间），C（每位价格）</p>
<p>假设由M1和M2构成的两级存储层次</p>
<p>M1的参数为：<span class="math inline">\(S_1,T_{A1},C_1\)</span></p>
<p>M2的参数为：<span class="math inline">\(S_1,T_{A1},C_1\)</span></p>
<ol type="1">
<li><p>每位价格：<span
class="math inline">\(C=\frac{C_1S_1+C_2S_2}{S_1+S_2}\)</span></p></li>
<li><p>命中率和失效率</p>
<ul>
<li>命中率：<span
class="math inline">\(H=\frac{N_1}{N_1+N_2}\)</span>，N1为访问M1的次数，N2为访问M2的次数</li>
<li>失效率：<span class="math inline">\(F=1-H\)</span></li>
</ul></li>
<li><p>平均访问时间 <span class="math display">\[
\begin{align}
T_A &amp;= HT_{A1}+(1-H)(T_{A1}+T_M) \nonumber \\
&amp;= T_{A1}+(1-H)T_M \nonumber \\
&amp;= T_A1+FT_M \nonumber \\
\end{align} \nonumber
\\
T_M 为失效开销，从向M_2发出访问请求到把整个数据块调入M_1中所需的时间 \\
T_M = T_{A2} + T_B \\
T_B为传送一个信息块所需的时间
\]</span></p></li>
</ol>
<ul>
<li>“Cache－主存”层次：弥补主存速度的不足</li>
<li>“主存－辅存”层次： 弥补主存容量的不足</li>
</ul>
<h3 id="cache的基本知识">5.2 Cache的基本知识</h3>
<h4 id="映像规则">映像规则</h4>
<ul>
<li><p>全相联规则</p>
<p>主存中的任一块可以被放置到Cache中的任意一个位置</p></li>
<li><p>直接映像</p>
<p>主存中的每一块只能被放置到Cache中唯一的一个位置，取模运算（模Cache的块数）</p></li>
<li><p>组相联映像</p>
<p>主存中的每一块可以被放置到Cache中唯一的一个组中的任何一个位置</p>
<p>若主存第i 块映象到第k 组，则：$K=i G $，G为Cache的组数</p>
<p>n路组相联，每组中有n个块，n也称为相联度，相联度越高，Cache空间的利用率就越高，块冲突概率就越低，失效率也就越低</p></li>
</ul>
<h4 id="查找算法">查找算法</h4>
<p>通过查找目录表来实现</p>
<p>目录表结构：</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-1.png" style="zoom:48%;" /></p>
<h4 id="替换算法">替换算法</h4>
<ul>
<li><p>随机法</p></li>
<li><p>先进先出法FIFO</p></li>
<li><p>最近最少使用法LRU</p>
<p>选择近期最少被访问的块作为被替换的块，选择最久没有被访问过的块作为被替换的块，失效率低</p></li>
</ul>
<h4 id="写策略">写策略</h4>
<p>“写”在所有访存操作中所占的比例：</p>
<p>统计结果表明，对于一组给定的程序：</p>
<ul>
<li>load指令：26％</li>
<li>store指令：9％</li>
</ul>
<p>“写”在所有访存操作中所占的比例：9％/(100％＋26％＋9％)≈7％（100%指：取指令的指令访存）
“写”在访问数据Cache操作中所占的比例：9％/(26％＋9％)≈25％</p>
<p>“写”操作必须在确认是命中后才可进行，“写”访问有可能导致Cache和主存内容的不一致</p>
<p>两种写策略：</p>
<ul>
<li><p>写直达法：</p>
<p>执行“写”操作时，不仅写入Cache，而且也写入下一级存储器</p>
<p>易于实现，一致性好</p></li>
<li><p>写回法：</p>
<p>执行“写”操作时，只写入Cache。仅当Cache中相应的块被替换时，才写回主存</p>
<p>速度快，所使用的存储器带宽较低</p></li>
</ul>
<p>采用写直达法时，若在进行“写”操作的过程中CPU必须等待，直到“写”操作结束，则称CPU写停顿，减少写停顿的一种常用的优化技术：<strong>采用写缓冲器</strong></p>
<p>“写”操作时的调块：</p>
<ul>
<li><p>按写分配(写时取)</p>
<p>写失效时，先把所写单元所在的块调入Cache，再行写入</p></li>
<li><p>不按写分配(绕写法)</p>
<p>写失效时，直接写入下一级存储器而不调块</p></li>
</ul>
<p>写策略与调块：</p>
<ul>
<li>写回法 ── 按写分配</li>
<li>写直达法 ── 不按写分配</li>
</ul>
<h4 id="cache的性能分析">Cache的性能分析</h4>
<ul>
<li><p>失效率</p>
<ul>
<li>与硬件速度无关</li>
<li>容易产生一些误导</li>
</ul></li>
<li><p>平均访存时间</p>
<p><strong>平均访存时间 ＝ 命中时间＋失效率×失效开销</strong></p></li>
<li><p>程序执行时间</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-2.png" style="zoom:48%;" /></p></li>
</ul>
<p>Cache失效对于一个CPI较小而时钟频率较高的CPU来说，影响是双重的：</p>
<ul>
<li><p>CPIexecution越低，固定周期数的Cache失效开销的相对影响就越大</p></li>
<li><p>在计算CPI时，失效开销的单位是时钟周期数。因此，即使两台计算机的存储层次完全相同，时钟频率较高的CPU的失效开销较大，其CPI中存储器停顿这部分也就较大</p>
<p><strong>存储器停顿时钟周期数＝访存次数×失效率×失效开销</strong></p></li>
</ul>
<p>因此Cache对于低CPI、高时钟频率的CPU来说更加重要</p>
<h4 id="改进cache的性能">改进Cache的性能</h4>
<ul>
<li><strong>平均访存时间＝命中时间＋失效率×失效开销</strong></li>
<li>可以从三个方面改进Cache的性能：
<ul>
<li>降低失效率</li>
<li>减少失效开销</li>
<li>减少Cache命中时间</li>
</ul></li>
</ul>
<h3 id="降低cache失效率的方法">5.3 降低Cache失效率的方法</h3>
<p>三种失效：</p>
<ul>
<li><p>强制失效</p>
<p>当第一次访问一个块时，该块不在Cache中，需从下一级存储器中调入Cache</p></li>
<li><p>容量失效</p>
<p>如果程序执行时所需的块不能全部调入Cache中，则当某些块被替换后，若又重新被访问，就会发生失效</p></li>
<li><p>冲突失效</p>
<p>在组相联或直接映象Cache中，若太多的块映象到同一组(块)中，则会出现该组中某个块被别的块替换(即使别的组或块有空闲位置)，然后又被重新访问的情况</p></li>
</ul>
<p>失效和Cache容量大小的关系：</p>
<ul>
<li>相联度越高，冲突失效就越少</li>
<li>强制性失效和容量失效不受相联度的影响</li>
<li>强制性失效不受Cache容量的影响，但容量失效却随着容量的增加而减少</li>
<li>大小为N的直接映象Cache的失效率约等于大小为N/2的2路组相联Cache的失效率</li>
</ul>
<p>减少三种失效的方法：</p>
<ul>
<li>强制性失效：增加块大小，预取</li>
<li>容量失效：增加容量</li>
<li>冲突失效：提高相联度</li>
</ul>
<p><strong>许多降低失效率的方法会增加命中时间或失效开销</strong></p>
<h4 id="增加cache块大小">1. 增加Cache块大小</h4>
<p>对于给定的Cache容量，当块大小增加时，失效率开始是下降，后来反而上升了</p>
<p>原因：</p>
<ul>
<li>一方面它减少了强制性失效</li>
<li>另一方面，由于增加块大小会减少Cache中块的数目，所以有可能会增加冲突失效</li>
</ul>
<p>Cache容量越大，使失效率达到最低的块大小就越大</p>
<p>增加块大小会增加失效开销</p>
<h4 id="提高相联度">2. 提高相联度</h4>
<p>采用相联度超过8的方案的实际意义不大</p>
<p>2:1
Cache经验规则：容量为N的直接映象Cache的失效率和容量为N/2的2路组相联Cache的失效率差不多相同</p>
<p>提高相联度是以增加命中时间为代价</p>
<h4 id="增加cache的容量">3. 增加Cache的容量</h4>
<p>最直接的方法是增加Cache的容量 缺点:</p>
<ul>
<li>增加成本</li>
<li>可能增加命中时间</li>
</ul>
<p>这种方法在片外Cache中用得比较多</p>
<h4 id="victim-cache">4. Victim Cache</h4>
<p>一种能减少冲突失效次数而又不影响时钟频率的方法 基本思想：</p>
<p>在Cache和它从下一级存储器调数据的通路之间设置一个全相联的小Cache，用于存放被替换出去的块(称为Victim)，以备重用</p>
<p>作用：对于减小冲突失效很有效，特别是对于小容量的直接映象数据Cache，作用尤其明显</p>
<h4 id="伪相联-cache">5. 伪相联 Cache</h4>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-3.png" style="zoom:60%;" /></p>
<p>伪相联Cache的优点：</p>
<ul>
<li>命中时间小</li>
<li>失效率低</li>
</ul>
<p>基本思想及工作原理：</p>
<p>在逻辑上把直接映象Cache的空间上下平分为两个区。对于任何一次访问，伪相联Cache先按直接映象Cache的方式去处理。若命中，则其访问过程与直接映象Cache的情况一样。若不命中，则再到另一区相应的位置去查找。若找到，则发生了伪命中，否则就只好访问下一级存储器</p>
<h4 id="硬件预取">6. 硬件预取</h4>
<ul>
<li>指令和数据都可以预取</li>
<li>预取内容既可放入Cache，也可放在外缓冲器中。例如：指令流缓冲器</li>
<li>指令预取通常由Cache之外的硬件完成</li>
</ul>
<p>平均访存时间预取
＝命中时间＋失效率×预取命中率×1＋失效率×（1－预取命中率）×失效开销</p>
<h4 id="编译器控制的预取">7. 编译器控制的预取</h4>
<p>在编译时加入预取指令，在数据被用到之前发出预取请求</p>
<h4 id="编译器优化">8. 编译器优化</h4>
<p>在编译时，对程序中的指令和数据进行重新组织，以降低Cache失效率</p>
<p>数组合并技术、内外循环交换技术、循环融合技术</p>
<h3 id="减少cache失效开销">5.4 减少Cache失效开销</h3>
<h4 id="让读失效优先于写">1. 让读失效优先于写</h4>
<p>Cache中的写缓冲器导致对存储器访问的复杂化：</p>
<p>写缓冲器进行的写入操作是滞后进行的，所以该缓冲器也被称为后行写数缓冲器</p>
<p>解决问题的方法(读失效的处理)：</p>
<ul>
<li>推迟对读失效的处理：（缺点：读失效的开销增加，如50％）</li>
<li>检查写缓冲器中的内容</li>
</ul>
<p>在写回法Cache中，也可采用写缓冲器</p>
<h4 id="写缓冲合并">2. 写缓冲合并</h4>
<ul>
<li>提高写缓冲器的效率</li>
<li>写直达Cache：依靠写缓冲来减少对下一级存储器写操作的时间</li>
<li>如果写缓冲器为空，就把数据和相应地址写入该缓冲器</li>
<li>如果写缓冲器中已经有了待写入的数据，就要把这次的写入地址与写缓冲器中已有的所有地址进行比较，看是否有匹配的项。如果有地址匹配而对应的位置又是空闲的，就把这次要写入的数据与该项合并。这就叫写缓冲合并</li>
<li>如果写缓冲器满且又没有能进行写合并的项，就必须等待</li>
</ul>
<p><strong>提高了写缓冲器的空间利用率，而且还能减少因写缓冲器满而要进行的等待时间</strong></p>
<h4 id="请求字处理技术">3. 请求字处理技术</h4>
<ul>
<li>请求字：从下一级存储器调入Cache的块中，只有一个字是立即需要的</li>
<li>应尽早把请求字发送给CPU：
<ul>
<li>尽早重启动：调块时，从块的起始位置开始读起。一旦请求字到达，就立即发送给CPU，让CPU继续执行</li>
<li>请求字优先：调块时，从请求字所在的位置读起。这样，第一个读出的字便是请求字。将之立即发送给CPU</li>
</ul></li>
</ul>
<p>这种技术在以下情况下效果不大：</p>
<ul>
<li>Cache块较小</li>
<li>下一条指令正好访问同一Cache块的另一部分</li>
</ul>
<h4 id="非阻塞cache技术">4. 非阻塞Cache技术</h4>
<p>即为：Cache失效时仍允许CPU进行其他的命中访问。即允许“失效下命中”</p>
<h4 id="采用两级cache">5. 采用两级Cache</h4>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-4.png" style="zoom:60%;" /></p>
<p>局部失效率与全局失效率：</p>
<ul>
<li><p>局部失效率：</p>
<p>该级Cache的失效次数/到达该级Cache的访问次数</p></li>
<li><p>全局失效率</p>
<p>该级Cache的失效次数/CPU发出的访存的总次数</p>
<p>全局失效率L2＝部分失效率L1×部分失效率L2</p></li>
</ul>
<p>对于第二级Cache，我们有以下结论：</p>
<ul>
<li>在第二级Cache比第一级
Cache大得多的情况下，两级Cache的全局失效率和容量与第二级Cache相同的单级Cache的失效率非常接近。</li>
<li>局部失效率不是衡量第二级Cache的一个好指标，因此，在评价第二级Cache时，应用全局失效率这个指标</li>
</ul>
<p>第二级Cache的参数：</p>
<ul>
<li><p>容量</p>
<p>第二级Cache的容量一般比第一级的大许多</p></li>
<li><p>相联度</p>
<p>第二级Cache可采用较高的相联度或伪相联方法</p></li>
</ul>
<h3 id="减少命中时间">5.5 减少命中时间</h3>
<p>命中时间直接影响到处理器的时钟频率。在当今的许多计算机中，往往是Cache的访问时间限制了处理器的时钟频率</p>
<h4 id="容量小结构简单的cache">1. 容量小、结构简单的Cache</h4>
<p>硬件越简单，速度就越快。应使Cache足够小，以便可以与CPU一起放在同一块芯片上</p>
<p>某些设计采用了一种折中方案：</p>
<p>把Cache的标识放在片内，而把Cache的数据存储器放在片外</p>
<h4 id="虚拟cache">2.虚拟Cache</h4>
<ul>
<li>虚拟Cache：访问Cache的索引以及Cache中的标识都是虚拟地址(一部分)</li>
<li>物理Cache：使用物理地址的传统Cache</li>
</ul>
<p>虚拟索引＋物理标识：</p>
<ul>
<li>优点：兼得虚拟Cache和物理Cache的好处</li>
<li>局限性：Cache容量受到限制（Cache容量≤页大小×相联度）</li>
</ul>
<h4 id="cache访问流水化">3. Cache访问流水化</h4>
<ul>
<li>对第一级Cache的访问按流水方式组织</li>
<li>访问Cache需要多个时钟周期才可以完成</li>
</ul>
<h4 id="trace-cache">4. Trace Cache</h4>
<ul>
<li>开发指令级并行性所遇到的一个挑战是：
当要每个时钟周期流出超过4条指令时，要提供足够多条彼此互不相关的指令是很困难的</li>
<li>一个解决方法：采用Trace Cache
存放CPU所执行的动态指令序列包含了由分支预测展开的指令，该分支预测是否正确需要在取到该指令时进行确认</li>
</ul>
<p>优缺点：</p>
<ul>
<li>地址映象机制复杂。</li>
<li>相同的指令序列有可能被当作条件分支的不同选择而重复存放。</li>
<li>能够提高指令Cache的空间利用率</li>
</ul>
<h4 id="cache优化技术总结">5. Cache优化技术总结</h4>
<p>“＋”号：表示改进了相应指标 “－”号：表示它使该指标变差
空格栏：表示它对该指标无影响 复杂性：0表示最容易，3表示最复杂</p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-5.png" style="zoom:60%;" /></p>
<p><img src="/assets/Note/计算机系统结构-张晨曦-第二版/5-6.png" style="zoom:60%;" /></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Note</category>
      </categories>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title>霍夫变换直线检测原理实现</title>
    <url>/2020/12/31/2020-12-31-HoughTransform/</url>
    <content><![CDATA[<h2 id="简单介绍">简单介绍</h2>
<p>霍夫变换可以用于边缘检测，更一般的则可以拟合曲线。基本原理如下：由曲线的定义式可得，如果
XY
确定，其对应的未知数构成的等式也可视作一个曲线表达式，这个新的表达式称作<strong>参数空间</strong>（自变量为原来的参数）改变
XY
的过程中这些位置构成的新的表达式必会都经过某一个固定点，这个固定点代表的参数就是原来曲线表达式。</p>
<span id="more"></span>
<p>但实际上的曲线会受到噪声影响，也就是说参数空间中所有的表达式并不会经过同一点，而是大部分曲线会经过某一固定点，这个固定点可能不止一个，所以我们将参数空间切分为一个个子区域，并统计子区域中线的交点（也可以直接统计线的点数，只要代表密度即可），交点最多的那个区域就是原曲线的参数。</p>
<p>更加详细的介绍可见《数字图像处理》中文第三版 <em>P472</em> 10.2.7
边缘检测和边界检测。或参考<a
href="https://www.cnblogs.com/Ponys/p/3146753.html">Matlab 霍夫变换 (
Hough Transform） 直线检测 - Pony_s - 博客园 (cnblogs.com)</a></p>
<h2 id="代码实现">代码实现</h2>
<p>以下为 matlab 代码实现，基本实现过程如下：</p>
<ol type="1">
<li>实现生成直线</li>
<li>给直线增加噪声</li>
<li>对噪声处理后的图像生成其参数空间</li>
<li>对参数空间的所有曲线做直方图统计，得到最大数量的参数表达</li>
<li>获得拟合的直线</li>
</ol>
<p>代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 霍夫变换 &amp; 直线</span></span><br><span class="line"><span class="comment">% 生成直线 y = 2x + 3</span></span><br><span class="line">x = <span class="number">-5</span>:<span class="number">5</span>;</span><br><span class="line">y = <span class="number">2</span>*x + <span class="number">3</span>;</span><br><span class="line"><span class="comment">% 添加噪声</span></span><br><span class="line">y_noise = y + <span class="built_in">randn</span>(<span class="number">1</span>, <span class="built_in">size</span>(x, <span class="number">2</span>))*<span class="number">1.5</span>;</span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;霍夫变换&quot;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">% 绘制原始线和噪声后的线</span></span><br><span class="line"><span class="built_in">plot</span>(x,y, x, y_noise, <span class="string">&#x27;--+&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;直线拟合&quot;</span>);</span><br><span class="line">axis equal</span><br><span class="line">grid on</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制霍夫变换参数空间，ysin(theta)+xcos(theta) = p</span></span><br><span class="line"><span class="comment">% 设置范围</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">% 设置角度范围</span></span><br><span class="line">[theta_min, theta_max] = deal(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line">theta = theta_min:<span class="number">0.1</span>:theta_max;</span><br><span class="line"><span class="comment">% 预开辟所有点的参数空间存储</span></span><br><span class="line">p_all = <span class="built_in">zeros</span>(<span class="built_in">size</span>(x,<span class="number">2</span>), <span class="built_in">length</span>(theta(:)));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(x, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">% 生成对应范围内的参数曲线</span></span><br><span class="line">    p = y_noise(<span class="built_in">i</span>) * <span class="built_in">sin</span>(theta) + x(<span class="built_in">i</span>) * <span class="built_in">cos</span>(theta);</span><br><span class="line">    p_all(<span class="built_in">i</span>, :) = p;</span><br><span class="line">    <span class="comment">% 绘制参数空间的曲线</span></span><br><span class="line">    <span class="built_in">plot</span>(theta, p);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">title(<span class="string">&quot;参数空间&quot;</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">axis normal</span><br><span class="line">grid on</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">% 统计其中每个子区域中的点数，并记录最大的</span></span><br><span class="line"><span class="comment">% 这里使用直方图hist3计算</span></span><br><span class="line">theta_repeat = <span class="built_in">repmat</span>(theta, <span class="number">11</span>, <span class="number">1</span>);</span><br><span class="line">hist3([theta_repeat(:) p_all(:)], <span class="string">&#x27;CDataMode&#x27;</span>,<span class="string">&#x27;auto&#x27;</span>,<span class="string">&#x27;FaceColor&#x27;</span>,<span class="string">&#x27;interp&#x27;</span>);</span><br><span class="line">title(<span class="string">&quot;直方图统计交点最多的区域&quot;</span>);</span><br><span class="line"><span class="comment">% num 是每个bin的数量，center为对应的x,y坐标</span></span><br><span class="line">[num, center] = hist3([theta_repeat(:) p_all(:)]);</span><br><span class="line"><span class="comment">% 找到最大的那个bin的下标并获取对应的参数</span></span><br><span class="line">[<span class="built_in">i</span>, <span class="built_in">j</span>] = <span class="built_in">find</span>(num == <span class="built_in">max</span>(<span class="built_in">max</span>(num)));</span><br><span class="line">theta_best = center&#123;<span class="number">1</span>&#125;(<span class="built_in">i</span>);</span><br><span class="line">p_best = center&#123;<span class="number">2</span>&#125;(<span class="built_in">j</span>);</span><br><span class="line"><span class="comment">% 获得拟合后的直线并绘制</span></span><br><span class="line">y_simulate = (p_best - x*<span class="built_in">cos</span>(theta_best))/<span class="built_in">sin</span>(theta_best);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(x, y_simulate);</span><br><span class="line"><span class="built_in">legend</span>([<span class="string">&quot;y=2x+3&quot;</span>, <span class="string">&quot;y=2x+3+noise&quot;</span>, <span class="string">&quot;simulate&quot;</span>], <span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;northwest&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>
<p>最后的效果如下：</p>
<p><img src="/assets/ArticleImg/2020/hough.png" /></p>
<p>其中参数空间的方框为交点比较多的，也就是比较密集的，这里有两个，代码里就取了一个，另外一个也是可以的。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>DIP</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>特征检测</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积的简单概况</title>
    <url>/2020/11/01/2020-11-01-ConvolutionAndCorrelation/</url>
    <content><![CDATA[<p>计算机视觉与图形图像处理等方面傅里叶变换都是一个十分重要的工具，与傅里叶变换紧密结合起来的便是<strong>卷积和相关</strong>，尤其是卷积（Convolution）在《数字图像处理-冈萨雷斯》中对卷积的的介绍比较笼统。</p>
<span id="more"></span>
<p>以下内容参考自《傅里叶变换-冷建华》以及《DIP》</p>
<p>卷积和相关有连续时间和离散时间两种形式，称之为时间是因为傅里叶是和信号紧密相关的，信号简单来说就是有意义的改变量，一般是随时间改变。</p>
<h2 id="冲激信号">冲激信号</h2>
<p>类似的冲激信号也有连续和离散两种形式，冲激信号是十分重要的基本信号，在傅里叶变换和取样有重要作用。</p>
<h3 id="连续时间的冲激信号">连续时间的冲激信号</h3>
<p>基本形式如下： <span class="math display">\[
\delta_a(t) =
\left\{
\begin{aligned}
+\infty&amp;, &amp;t = 0 \\
0&amp;, &amp;t\neq 0
\end{aligned}
\right.
\]</span> 且满足： <span class="math display">\[
\int_{-\infty}^{+\infty} \delta_a(t) dt = 1
\]</span> 下标 a
表示模拟信号（analog），有以下的积分形式的取样特性（sift）： <span
class="math display">\[
\int_{-\infty}^{+\infty} f(t) \delta_a(t) dt = f(0) \\
\int_{-\infty}^{+\infty} f(t) \delta_a(t-t_0) dt = f(t_0)
\]</span></p>
<h3 id="离散时间的冲激信号">离散时间的冲激信号</h3>
<p>和连续形式的冲激类似，其形式如下： <span class="math display">\[
\delta(n) =
\left\{
\begin{aligned}
1&amp;, &amp;n = 0 \\
0&amp;, &amp;n\neq 0
\end{aligned}
\right.
\]</span> 其中 n 为整数，满足： <span class="math display">\[
\sum_{n = -\infty}^{+\infty}\delta(n) = 1
\]</span> 类似的取样特性如下： <span class="math display">\[
\sum_{n = -\infty}^{+\infty} f(n)\delta(n) = f(0) \\
\sum_{n = -\infty}^{+\infty} f(n)\delta(n - x_0) = f(x_0)
\]</span></p>
<h2 id="连续时间信号的卷积">连续时间信号的卷积</h2>
<h3 id="线性卷积">线性卷积</h3>
<p>定义如下： <span class="math display">\[
x_a(t) * y_a(t) = \int_{-\infty}^{+\infty} x_a(\tau) y_a(t-\tau) d\tau
\]</span> 也就是将 <span class="math inline">\(y_a\)</span>
翻转（卷）之后对应相乘（积）然后平移计算出所有的值。</p>
<p>具有<strong>冲激不变性</strong>： <span class="math display">\[
x_a(t) * \delta_a(t) = \int_{-\infty}^{+\infty} x_a(\tau)
\delta_a(t-\tau) d\tau = x_a(t)
\]</span> 线性卷积一般针对一般信号，需要在整个定义域内进行计算</p>
<h3 id="周期卷积">周期卷积</h3>
<p>周期卷积也就是针对的是周期信号的卷积，因为是周期信号所以只需要关注一个周期就可以了</p>
<p>定义如下： <span class="math display">\[
x_a(t) * y_a(t) = \int_{0}^{T} x_a(\tau) y_a(t-\tau) d\tau
\]</span> 其中 <span class="math inline">\(x_a\)</span> 和 <span
class="math inline">\(y_a\)</span> 都是周期为 T
的信号，和线性卷积唯一不同的就是积分区域，这里采用的是 <span
class="math inline">\([0 \sim
T]\)</span>，其实只要满足一个周期就可以了</p>
<h3 id="循环卷积">循环卷积</h3>
<p>循环卷积是针对有限信号，即在某一段区域内有定义的信号（定义域外为
0）假设信号 <span class="math inline">\(x_a,y_a\)</span> 定义在 <span
class="math inline">\([0 \sim T]\)</span> 上，循环卷积定义如下： <span
class="math display">\[
x_a(t) * y_a(t) = \int_{0}^{T} x_a(\tau) y_a(&lt;t-\tau&gt;_T) d\tau
\]</span> 其中 <span class="math inline">\(&lt;t-\tau&gt;_T\)</span>
表示对 <span class="math inline">\(t-\tau\)</span> 取模 T
运算，即余数。</p>
<p>卷积后的信号仅在 <span class="math inline">\([0\sim T]\)</span>
有定义，其它均为 0。</p>
<p><strong>周期卷积和循环卷积同样满足冲击不变性</strong>。</p>
<h2 id="离散时间信号的卷积">离散时间信号的卷积</h2>
<p>类似于连续信号，离散信号（序列）仅仅是将积分改为求和，离散卷积同样具有冲击不变性</p>
<h3 id="线性卷积-1">线性卷积</h3>
<p>定义如下： <span class="math display">\[
x(n) * y(n) = \sum_{i=-\infty}^{+\infty} x(i) y(n-i)
\]</span> n 为整数，代表离散</p>
<h3 id="周期卷积-1">周期卷积</h3>
<p>周期卷积对应的就是周期序列，两个周期为 N 的信号的卷积如下： <span
class="math display">\[
x(n) * y(n) = \sum_{i=0}^{N-1} x(i) y(n-i)
\]</span></p>
<h3 id="循环卷积-1">循环卷积</h3>
<p>循环卷积定义的是一般有限序列，定义如下： <span
class="math display">\[
x(n) * y(n) = \sum_{i=0}^{N-1} x(i) y(&lt;n-i&gt;_N)
\]</span></p>
<h2 id="简单补充">简单补充</h2>
<p>循环卷积和周期卷积本质上并无区别，循环卷积就是对有限序列直接进行<strong>周期拓展</strong>后的周期卷积</p>
<p>循环卷积也叫做圆周卷积</p>
<p>对于长度不同的序列做循环卷积一般会进行拓展，即在末尾补0，假设两个信号长度分别为
M，N，则补充 0 后的长度应该至少为
M+N，这样的循环卷积才会和直接线性卷积相同。即两个信号的高低频不会混淆。</p>
<h2 id="拓充参考">拓充参考</h2>
<p><a
href="https://www.cnblogs.com/kensporger/p/12903152.html">序列卷积：线性、周期和圆周</a></p>
<p><a
href="https://zhuanlan.zhihu.com/p/100289337">别怕，"卷积"其实很简单</a></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>傅里叶变换</tag>
        <tag>信号处理</tag>
        <tag>卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>单应变换的局限性</title>
    <url>/2021/01/14/2021-01-14-HomographyLimits/</url>
    <content><![CDATA[<h2 id="单应变换">单应变换</h2>
<p>单应变换就是两个平面内保持共线的变换，变换是一个 3*3
的矩阵，因为齐次坐标的尺度无关性所以只有8个自由度。DLT（直接线性变换）算法讨论了单应变换的相关性质，以及变换矩阵的求解。</p>
<h2 id="局限性">局限性</h2>
<p>单应变换简单来说就是可以将一个四边形映射为另一个任意的四边形，只需要满足共线点变换后仍为共线即可。在很多算法中都使用到单应变换，但单应变换只能模拟两种情况的变换：</p>
<ol type="1">
<li>相机几何中心位置不变，目标场景任意</li>
<li>相机位置任意，目标场景为平面（或近似为平面，很多低空遥感图像都视作为平面）</li>
</ol>
<span id="more"></span>
<p>在论文 <a
href="%5BPerspective-SIFT:%20An%20efficient%20tool%20for%20low-altitude%20remote%20sensing%20image%20registration%20-%20ScienceDirect%5D(https://www.sciencedirect.com/science/article/abs/pii/S0165168413001503)">Perspective-SIFT:
An efficient tool for low-altitude remote sensing image registration</a>
中提取的透视不变特征使用的就是单应变换模拟。</p>
<p>但上面两个局限性使得在相机位置改变（平移变换）时，场景需要约束到平面。</p>
<h2 id="局限性的解释">局限性的解释</h2>
<blockquote>
<p>下面的内容参考自 <a
href="http://singvision.net/tag/homography/">Homography | 奇点视觉
(singvision.net)</a></p>
</blockquote>
<p>相机位置改变的图示如下：</p>
<p><img src="/assets/ArticleImg/2021/Homography_2.png" /></p>
<p>其中 <span class="math inline">\(o,o&#39;\)</span>
表示相机位置，横线表示相机的成像平面，<span
class="math inline">\(s_1,s_2\)</span> 表示目标物，这里的 <span
class="math inline">\(s_1,s_2\)</span> 在 <span
class="math inline">\(o\)</span>
的视角下就成为了一个点，也就是说存在遮挡，这样使用单应变换就不能将一幅图像变换为另一幅图像，在图像拼接中，也就找不到对应点。</p>
<p>但是当目标为平面时，无论视角怎么改变都不会丢失点（除非视角在平面上），当视角位置不变，仅存在旋转角度的改变时，此时单应也能模拟这种变换。</p>
<p>视角不变时，单应可以模拟变换，但会造成另一种情况：</p>
<p><img
src="/assets/ArticleImg/2021/Homography_Near90Degreee2.png" /></p>
<p>成像在 <span class="math inline">\(P&#39;\)</span> 上为均匀的点，但在
<span class="math inline">\(P\)</span> 上却是间隔非均匀的点，当 <span
class="math inline">\(P\)</span> 和 <span
class="math inline">\(P’\)</span> 垂直时，这种差距更大，可能会使得 <span
class="math inline">\(P’\)</span> 上的点在 <span
class="math inline">\(P\)</span>
上变成无穷远的点，这在大视角的图像拼接会造成很大的误差。一种解决方法是将图像重投影到均匀圆柱面或者球面上：</p>
<p><img src="/assets/ArticleImg/2021/Homography_Warp1.png" /></p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>Homography</tag>
      </tags>
  </entry>
  <entry>
    <title>MLS移动最小二乘法原理及其实现</title>
    <url>/2021/01/07/2021-01-07-MLS/</url>
    <content><![CDATA[<h2 id="原理介绍">原理介绍</h2>
<p>原理可参考<a
href="http://read.pudn.com/downloads196/doc/920470/MovingLeast-SquaresMLS.pdf">基于移动最小二乘法的曲线曲面拟合，曾清红，卢德唐</a>，这里面已经讲得很详细了。可以结合<a
href="https://blog.csdn.net/qq_36686437/article/details/106103760">CSDN
移动最小二乘原理</a>，一起看，曾清红论文的式子稍微有点难懂，结合起来看很不错。</p>
<p>MLS(Moving
Least-Squares)，移动最小二乘，是一种比较方便的曲线、曲面拟合方法，和传统最小二乘法相比有很多优点，在论文中都提到了。这里主要对其原理做个简单的说明和补充。</p>
<span id="more"></span>
<p>最小二乘法是通过给定的目标函数和点集中找到目标函数的一组系数使其误差最小（L2范式）。一般是多项式函数，未知数为系数，通过找到最佳的系数来拟合。这就有很大的缺陷，对于一般的函数，很难用一个多项式函数来全局拟合。但分段拟合，其中的光滑又很难保证，会带来很大的困难。</p>
<h3 id="拟合函数的建立">拟合函数的建立</h3>
<p>移动最小二乘法其实本质上也类似，不同的是它采取的系数是 x
的函数，也就是对不同的目标拟合点它所属的多项式函数是不同的。这就有了很大的灵活性。有点上面直接分段的意思。</p>
<p>在拟合区域的一个局部上，拟合函数 <span
class="math inline">\(f(x)\)</span> 表示为： <span
class="math display">\[
f(x) = \sum_{i=1}^m \alpha_i(x) p_i(x) = p^T(x)\alpha(x)
\]</span> 乘积相加就可以转换为向量点积，其中： <span
class="math display">\[
\begin{align}
\alpha(x) &amp;= [\alpha_1(x),\alpha_2(x),\cdots,\alpha_m(x)]^T \\
p(x) &amp;= [p_1(x), p_2(x),\cdots,p_m(x)]^T
\end{align}
\]</span> <span class="math inline">\(\alpha(x)\)</span>
为待求系数，每一个元素都是 x 的函数。<span
class="math inline">\(p(x)\)</span>
为基函数，一个多项式函数的基，例如拟合线可以使用 <span
class="math inline">\([1,x]^T, [1,x,x^2]\)</span>
这类的，对于二维问题（拟合曲面）则可以采用 <span
class="math inline">\([1,x,y]^T,[1,x,y,x^2,xy,y^2]\)</span>，优化的目标函数为：
<span class="math display">\[
J = \sum_{i=1}^n w(x-x_i)[f(x_i)-y_i]^2 = \sum_{i=1}^n
w(x-x_i)[p^T(x_i)\alpha(x)-y_i]^2 \rightarrow \mathrm{min}
\]</span> 表示的意思其实是对某个小区间，其中的 x 和它对应的 <span
class="math inline">\(\alpha(x)\)</span> 使得上式最小，这里<strong>把 x
视作为已知量</strong>，要求的未知量是向量 <span
class="math inline">\(\alpha(x)\)</span>。上面的 <span
class="math inline">\(f(x)\)</span> 我修改为 <span
class="math inline">\(f(x_i)\)</span> ，感觉这才符合论文意思。因为 <span
class="math inline">\(w(x-x_i)\)</span>
为权函数，并且具有紧支性（范围之外为 0）也就是<strong>只考虑与 “x”
这个小区间相邻的部分</strong>，其余那些远离它的部分没有影响。</p>
<p>其中 n 为已知点的数量，<span class="math inline">\(x_i,y_i\)</span>
为已知点集的点。对拟合量 x 来说，未知的只有 <span
class="math inline">\(\alpha(x)\)</span> 所以对它求导可得： <span
class="math display">\[
\begin{align}
\frac{\partial J}{\partial \alpha} &amp;= A(x)\alpha(x) - B(x)y = 0\\
A(x) &amp;= \sum_{i=1}^n w(x-x_i)p(x_i)p^T(xi) \\
B(x) &amp;= [w(x-x_1)p(x_1), w(x-x_2)p(x_2), \cdots, w(x-x_n)p(x_n)] \\
y^T &amp;= [y_1, y_2, \cdots,y_n]
\end{align}
\]</span> 可以先对 <span class="math inline">\(\alpha_i(x)\)</span>
求导，然后拓展到向量形式，偏导等于 0 时取到最小值，此时有： <span
class="math display">\[
\alpha(x) = A^{-1}(x)B(x)y
\]</span> 此时便得到 x 对应的系数向量，其中 <span
class="math inline">\(A^{-1}(x),B(x),y\)</span> 为 <span
class="math inline">\(m\times m,m\times n,n\times 1\)</span> 的矩阵，把
<span class="math inline">\(\alpha(x)\)</span> 带入 <span
class="math inline">\(f(x)\)</span> 定义式有： <span
class="math display">\[
f(x) = p^T(x)A^{-1}(x)B(x)y = \Phi(x) y
\]</span> <span class="math inline">\(\Phi(x)\)</span>
就称为形函数，是一个 <span class="math inline">\(1\times m\)</span>
的向量</p>
<h3 id="权函数">权函数</h3>
<p>权函数在最小移动二乘法有很大的作用，甚至是核心作用。它具有紧支性，也就是<strong>权函数在
<em>x</em> 的一个子域内不等于</strong></p>
<p><strong>零
在这个子域之外全为零</strong>，这个子域称为支持域。权函数是<strong>非负的</strong>，并且随着距离（<span
class="math inline">\(\vert\vert x-x_i \vert\vert\)</span>)
的增加而减小，也就是原理 x 的认为对 x
的影响小。权函数还需要具有一定的<strong>光滑性</strong>，因为需要继承原函数的连续性。论文给出的是三次样条函数曲线（这里归一化了）：
<span class="math display">\[
w(\overline s) =
\left \{
\begin{align}
&amp; \frac{2}{3}-4 \overline s^2 + 4\overline s^3 &amp; &amp;(\overline
s \le \frac{1}{2}) \\
&amp; \frac{4}{3}-4\overline s+4\overline s^2-\frac{4}{3}\overline s^3
&amp; &amp;(\frac{1}{2} &lt;\overline s\le 1 ) \\
&amp; 0 &amp;&amp;(\overline s &gt; 1)
\end{align}
\right.
\]</span></p>
<p>其中，<span class="math inline">\(s = x - x_i,\overline s =
\frac{s}{s_{max}}\)</span>，<span class="math inline">\(s_{max}\)</span>
为影响区域的大小，也就是支持域的大小。需要注意的是，支持域的选取很麻烦，因为拟合函数需要矩阵
A
的逆，这就需要保证<strong>每个拟合点的支持域中的非共线（共面）的点数达到最低要求</strong>。对于使用一维二次基
<span class="math inline">\([1,x,x^2]\)</span>
的曲线拟合，就需要保证拟合点 x
支持域中至少有三个非共线的点。权函数并不是只可以用这个，只要满足上述的特征就可以。</p>
<p>可以考虑<strong>支持域的动态化</strong>，唯一的支持域对非均匀分部的曲线拟合很不友好，动态化或许可以缓解。</p>
<h2 id="matlab-实现">Matlab 实现</h2>
<p>这里使用 matlab
实现，代码不多，只要把思路理清即可，这里分为曲线和曲面拟合，分别对应论文中的两个实验，使用的也是论文中的数据。</p>
<h3 id="曲线拟合">曲线拟合</h3>
<p>虽然使用和论文相同的数据，但这里采用了一维二次基 <span
class="math inline">\([1,x,x^2]\)</span>
拟合，可以看出比论文的效果稍微好一些。</p>
<p>代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line"><span class="comment">% 已知点数据</span></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>, <span class="number">0.5</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>, <span class="number">1.0</span>];</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">14.5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line">n = <span class="built_in">size</span>(x,<span class="number">2</span>);</span><br><span class="line">[min_x, max_x] = deal(<span class="built_in">min</span>(x), <span class="built_in">max</span>(x));</span><br><span class="line"><span class="comment">% 绘制点的数量，也就是估计的点</span></span><br><span class="line">points_num = <span class="number">1000</span>;</span><br><span class="line">simulated_x = <span class="built_in">linspace</span>(min_x, max_x, points_num);</span><br><span class="line">simulated_y = <span class="built_in">zeros</span>(<span class="number">1</span>, points_num);</span><br><span class="line"><span class="comment">% 定义格子范围（紧支）需要保证有三个不共线的点，否则A矩阵可能不可逆，这里取4个点范围，避免共线</span></span><br><span class="line"><span class="comment">% 这里是比较均匀的，而且点比较多，到曲面就很难选取了</span></span><br><span class="line">smax = (max_x-min_x)*<span class="number">4</span>/n;</span><br><span class="line"><span class="comment">% 使用一维二次基 [1, x, x^2] m = 3</span></span><br><span class="line">m = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 拟合每一个拟合点</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:points_num</span><br><span class="line">    x_val = simulated_x(<span class="built_in">j</span>);</span><br><span class="line">    <span class="comment">% 预分配 A B, 这里的p就是[1，x_val，x_val^2]</span></span><br><span class="line">    A = <span class="built_in">zeros</span>(m, m);</span><br><span class="line">    B = <span class="built_in">zeros</span>(m, n);</span><br><span class="line">    <span class="comment">% 计算 w 求和</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">        xi = x(<span class="built_in">i</span>);</span><br><span class="line">        w = w_func(<span class="built_in">abs</span>(x_val - xi)/smax);</span><br><span class="line">        p_i = [<span class="number">1</span>;xi;xi^<span class="number">2</span>];</span><br><span class="line">        A = A + w * (p_i*p_i&#x27;);</span><br><span class="line">        B(:, <span class="built_in">i</span>) = w*p_i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    px = [<span class="number">1</span>, x_val, x_val^<span class="number">2</span>];</span><br><span class="line">    simulated_y(<span class="built_in">j</span>) = px * (A\B) * y&#x27;;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(x, y,<span class="string">&#x27;--o&#x27;</span>, simulated_x, simulated_y);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[w]</span> = <span class="title">w_func</span><span class="params">(s)</span></span></span><br><span class="line">    <span class="keyword">if</span> s &lt;= <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">        w = <span class="number">2</span>/<span class="number">3</span> - <span class="number">4</span>*s^<span class="number">2</span> + <span class="number">4</span>*s^<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">elseif</span> s &lt;= <span class="number">1</span></span><br><span class="line">        w = <span class="number">4</span>/<span class="number">3</span> - <span class="number">4</span>*s + <span class="number">4</span>*s^<span class="number">2</span> - <span class="number">4</span>/<span class="number">3</span>*s^<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>拟合图如下：</p>
<p><img src="/assets/ArticleImg/2021/MLS_line.png" /></p>
<p>圆点为数据，虚线为直接连接的线，曲线为拟合线</p>
<h3 id="曲面拟合">曲面拟合</h3>
<p>曲面使用的是论文给的函数，使用的和论文的一样的二维线性基 <span
class="math inline">\([1,x,y]\)</span> <span class="math display">\[
\begin{align}
z &amp;= f(x,y) \\
&amp;= 2*(1-x)^2 * exp(-x^2 - (y+1)^2) - 10*(x^4/5 - y^5)
* exp(-x^2 - y^2) - 1/3*exp(-(x+1)^2 - y^2)
\end{align}
\]</span> 函数图像为：</p>
<p><img src="/assets/ArticleImg/2021/MLS_surface1.png" /></p>
<p>代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line"><span class="comment">% 定义域</span></span><br><span class="line">l = <span class="number">-3</span>; r = <span class="number">3</span>;</span><br><span class="line"><span class="comment">% 生成随机点 n 个，这 n 个点为已知数据</span></span><br><span class="line">n = <span class="number">200</span>;</span><br><span class="line">x = (r - l) * <span class="built_in">rand</span>(<span class="number">1</span>, n) + l;</span><br><span class="line">y = (r - l) * <span class="built_in">rand</span>(<span class="number">1</span>, n) + l;</span><br><span class="line"><span class="comment">% 函数定义</span></span><br><span class="line">z = <span class="number">2</span>*(<span class="number">1</span>-x).^<span class="number">2</span> .* <span class="built_in">exp</span>(-x.^<span class="number">2</span> - (y+<span class="number">1</span>).^<span class="number">2</span>) - <span class="number">10</span>*(x.^<span class="number">4</span>/<span class="number">5</span> - y.^<span class="number">5</span>) ...</span><br><span class="line">.* <span class="built_in">exp</span>(-x.^<span class="number">2</span> - y.^<span class="number">2</span>) - <span class="number">1</span>/<span class="number">3</span>*<span class="built_in">exp</span>(-(x+<span class="number">1</span>).^<span class="number">2</span> - y.^<span class="number">2</span>);</span><br><span class="line"><span class="comment">% 点是随机的数据，meshgrid 生成点，也就是这里的划分网格</span></span><br><span class="line">[xq, yq] = <span class="built_in">meshgrid</span>(l:<span class="number">0.1</span>:r, l:<span class="number">0.1</span>:r);</span><br><span class="line"><span class="comment">% 插值生成对应的网格数据</span></span><br><span class="line">zq = griddata(x, y, z, xq, yq);</span><br><span class="line"><span class="comment">% 绘制网格和点，这里的网格是插值生成的</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">mesh(xq, yq, zq);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"><span class="comment">% 拟合上面的网格</span></span><br><span class="line">points_sum = <span class="built_in">size</span>(xq, <span class="number">1</span>);</span><br><span class="line">simulated_z = <span class="built_in">zeros</span>(points_sum, points_sum);</span><br><span class="line"><span class="comment">% 使用二维线性基[1, x, y] 作为基函数</span></span><br><span class="line">m = <span class="number">3</span>;</span><br><span class="line"><span class="comment">% 定义格子范围（紧支）需要保证有三个不共线的点，否则A矩阵可能不可逆，这个值很难取以避免奇异矩阵的产生，这里简单的取了很大的值</span></span><br><span class="line"><span class="comment">% 我认为严谨的应该事先判断有几个点，对那些产生奇异的块适当的扩大紧支</span></span><br><span class="line">smax = (r-l)/<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% i,j 为拟合点的下标</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:points_sum</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:points_sum</span><br><span class="line">        x_val = xq(<span class="number">1</span>, <span class="built_in">i</span>); y_val = yq(<span class="built_in">j</span>, <span class="number">1</span>);</span><br><span class="line">        A = <span class="built_in">zeros</span>(m, m);</span><br><span class="line">        B = <span class="built_in">zeros</span>(m, n);</span><br><span class="line">        <span class="comment">% 对每个点加权获得拟合值</span></span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">1</span>:n</span><br><span class="line">            xk = x(k); yk = y(k);</span><br><span class="line">            w = w_func(((x_val-xk)^<span class="number">2</span> + (y_val - yk)^<span class="number">2</span>)^<span class="number">0.5</span>/smax);</span><br><span class="line">            p = [<span class="number">1</span>; xk; yk];</span><br><span class="line">            A = A + w*(p*p&#x27;);</span><br><span class="line">            B(:, k) = w * p;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        p_xy = [<span class="number">1</span>, x_val, y_val];</span><br><span class="line">        <span class="comment">% 注意这里 x_val 是第 i 列， y_val是第 j 行 注意mesh的对应下标</span></span><br><span class="line">        simulated_z(<span class="built_in">j</span>, <span class="built_in">i</span>) = p_xy * (A\B) * z&#x27;;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">surf(xq, yq, simulated_z);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line"><span class="comment">% 这里的s就是半径相当于，也可以设置为格子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[w]</span> = <span class="title">w_func</span><span class="params">(s)</span></span></span><br><span class="line">    <span class="keyword">if</span> s &lt;= <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">        w = <span class="number">2</span>/<span class="number">3</span> - <span class="number">4</span>*s^<span class="number">2</span> + <span class="number">4</span>*s^<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">elseif</span> s &lt;= <span class="number">1</span></span><br><span class="line">        w = <span class="number">4</span>/<span class="number">3</span> - <span class="number">4</span>*s + <span class="number">4</span>*s^<span class="number">2</span> - <span class="number">4</span>/<span class="number">3</span>*s^<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>拟合图如下：</p>
<p><img src="/assets/ArticleImg/2021/MLS_surface2.png" /></p>
<p>上面为随机生成的点图和 matlab 插值生成的网格图，下面为 MLS
拟合的曲面，效果还是不错的</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CG</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>曲线曲面拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>As-Projective-As-Possible Image Stitching with Moving DLT</title>
    <url>/2021/01/18/2021-01-14-APAP/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a
href="https://ieeexplore.ieee.org/document/6619147">As-Projective-As-Possible
Image Stitching with Moving DLT</a></p>
<p>这里主要对文章的 Moving DLT
做介绍，其它关于图像拼接的细节就不描述了，文章的重点就在使用 Moving DLT
来模拟一个复杂映射</p>
</blockquote>
<p><strong>摘要</strong>：图像拼接的商用化给我们带来了这个问题已经被解决的错误印象。实际上，在某些严厉的成像条件上，这些结果都不能够使人信服，除非在<strong>只有视角旋转变化或者场景为平面</strong>的条件下。在这些约束下，可以使用二维射影变换或者单应来对齐图片。在一般情况下，这种条件经常被打破，造成错误的对齐或者鬼影。现在这些拼接技术依赖于后处理方法来消除或减轻鬼影。在这篇文章中，提出一种不同的估计技术，名为
“移动直接线性变换 (Moving
DLT)”，可以优化射影变换使得其适应输入数据和理想条件的偏差。这生成了一种
<em>尽可能投影的</em>
的图像对齐方法，有效的减少了鬼影并且不损害透视图象拼接的几何写实性。此外，还描述了如何将这种对齐方法使用到多幅图像的大全景图生成中，通过将光束法平差（Bundle
Adjustment）同时用于优化以达到准确地对齐。</p>
<p><strong>关键词</strong>：图像拼接，图像对齐，射影变换，直接线性变换，移动最小二乘法</p>
<span id="more"></span>
<h2 id="介绍">介绍</h2>
<p>文章的介绍部分主要谈到了当前图像拼接算法模型的不足，使用单应变换来实现图像对齐。但<a
href="https://weijun-lin.top/2021/01/14/2021-01-14-HomographyLimits/">单应变换有着自身的局限性</a>，只适用于视角仅旋转变换和目标场景为平面两种情况。当违反这两个条件后，会造成鬼影并且错误的对齐。为此，提出了一个名为“移动DLT”的估计技术，可以优化全局单应变换带来的误差。其它技术带来的鬼影等不良影响虽然可以通过后期技术优化，但是作者认为在对齐阶段就消除是很有必要的。</p>
<h2 id="尽可能射影的变换-apap">尽可能射影的变换 APAP</h2>
<h3 id="二维射影变换dlt">二维射影变换（DLT）</h3>
<p>令 <span class="math inline">\(\textbf{x} = [x,y]^T,\textbf{x}&#39;=
[x&#39;,y&#39;]^T\)</span>，为两幅具有重叠部分图像 <span
class="math inline">\(I,I&#39;\)</span> 上的对应点，它们之间的关系为：
<span class="math display">\[
\widetilde {\textbf{x}}&#39; \sim \textbf{H} \widetilde {\textbf{x}}
\]</span> 字符上的波浪线代表着齐次坐标归一化。也就是说将 <span
class="math inline">\(\widetilde {\textbf{x}}\)</span>
通过单应矩阵变换后还需要齐次坐标归一化，也就是除第三个分量。其中 <span
class="math inline">\(3\times 3\)</span> 的矩阵 <span
class="math inline">\(\textbf{H}\)</span>
为单应矩阵，上面的等式展开后有： <span class="math display">\[
\begin{align}
x&#39; = \frac{r_1[x,y,1]^T}{r_3[x,y,1]^T} \\
y&#39; = \frac{r_2[x,y,1]^T}{r_3[x,y,1]^T}
\end{align}
\]</span> 其中 <span class="math inline">\(r_j\)</span> 表示矩阵 <span
class="math inline">\(\textbf{H}\)</span> 的第 j
行。齐次坐标需要除以第三个分量使得它不是一个线性变换，直接线性变换（DLT）是一种在含有噪声的匹配点中估计单应矩阵的基础方法。首先，因为
<span class="math inline">\(\widetilde {\textbf{x}}&#39; \sim \textbf{H}
\widetilde {\textbf{x}}\)</span> 有 <span
class="math inline">\(\textbf{0}_{3\times 1} = \widetilde
{\textbf{x}}&#39; \times \textbf{H}\widetilde {\textbf{x}}\)</span>
，这个式子可以化为： <span class="math display">\[
\begin{align}
\textbf{0}_{3\times 1} &amp;=
\left[
\begin{matrix}
\textbf{0}_{1\times 3} &amp; -\widetilde{\textbf{x}}^T &amp;
y&#39;\widetilde {\textbf{x}}^T\\
\widetilde {\textbf{x}}^T &amp; \textbf{0}_{1\times 3} &amp;
-x&#39;\widetilde {\textbf{x}}^T\\
-y&#39;\widetilde {\textbf{x}}^T &amp; x&#39;\widetilde {\textbf{x}}^T
&amp; \textbf{0}_{1\times 3}
\end{matrix}
\right]
\times \textbf{h} \\
\textbf{h} &amp;=
\left[
\begin{matrix}
r_1^T \\
r_2^T \\
r_3^T
\end{matrix}
\right]
\end{align}
\]</span> <span class="math inline">\(\textbf{h}\)</span> 就是矩阵 <span
class="math inline">\(\textbf{H}\)</span> 的向量表示，上面 3*9
的矩阵中，只有两行是线性无关的，所以对某一对对应点 <span
class="math inline">\(\{\textbf{x}_i,\textbf{x}_i&#39;\}\)</span> 使用
<span class="math inline">\(\textbf{a}_i\)</span>
表示矩阵的前两行，对于需要估计的向量 <span
class="math inline">\(\textbf{h}\)</span>，<span
class="math inline">\(\vert\vert \textbf{a}_i
\textbf{h}\vert\vert\)</span> 为第 i 个点的代数误差（因为理想情况下
<span class="math inline">\(a_ih\)</span> 为 0），所以 DLT
的目标就是将所有对应点的代数误差和做到最小，即： <span
class="math display">\[
\hat{\textbf{h}} = \mathop{argmin}_{\textbf{h}} \sum_{i=1}^{N}
\vert\vert \textbf{a}_i \textbf{h}\vert\vert ^2 \qquad \text{s.t.}
\vert\vert \textbf{h}\vert\vert = 1
\]</span> 将所有的点累积起来还可以转变为矩阵的形式： <span
class="math display">\[
\hat{\textbf{h}} = \mathop{argmin}_{\textbf{h}}
\vert\vert \textbf{A} \textbf{h}\vert\vert ^2 \qquad \text{s.t.}
\vert\vert \textbf{h}\vert\vert = 1
\]</span> 其中 <span class="math inline">\(\textbf{A} \in
\mathbb{R}^{2N\times
9}\)</span>，这就是一个代数最小二乘问题，它的解是<strong>最小奇异值对应的右奇异向量</strong>。也就是说对于原图像
<span class="math inline">\(I\)</span> 中的任意一点 <span
class="math inline">\(\textbf{x}_*\)</span>，它映射到对齐图像 <span
class="math inline">\(I&#39;\)</span> 上的点为 <span
class="math inline">\(\textbf{x}&#39;_*\)</span>，理想情况下，有以下关系成立：
<span class="math display">\[
\widetilde {\textbf{x}}_*&#39; \sim \textbf{H} \widetilde {\textbf{x}}_*
\]</span> 前面已经提到了单应的局限性，DLT
算法适合在避免了单应局限性，并存在一些离群点（噪声）的情况下，获得最佳的单应映射。但是在一般成像下，一个<strong>全局的单应</strong>不足以拟合所有的点，也就是说会有很大一部分点不符合这个单应矩阵表示的映射。文章提供了一种使用单应模拟复杂映射（非纯单应）的方法，也就是下面要提到的<strong>移动
DLT</strong>。</p>
<p>在做 DLT
之前可以先将数据归一化可以避免很多数值上的错误，归一化可参考：<a
href="https://zhuanlan.zhihu.com/p/52023208">《CV中的多视图几何》——图像之间的单应变换
- 知乎 (zhihu.com)</a>，其中也谈到了归一化后的反归一化。</p>
<h3 id="moving-dlt">Moving DLT</h3>
<p>Moving DLT 本质上就是使用局部单应拟合映射。此时的点 <span
class="math inline">\(\textbf{x}_*,\textbf{x}_*&#39;\)</span> 满足下式：
<span class="math display">\[
\widetilde {\textbf{x}}_*&#39; \sim \textbf{H}_* \widetilde
{\textbf{x}}_*
\]</span> 这里的 <span class="math inline">\(\textbf{H}_*\)</span>
和点有关，也就是单应的局部表示。而 <span
class="math inline">\(\textbf{H}_*\)</span>
则从下面的加权优化问题中得出： <span class="math display">\[
\textbf{h}_* = \mathop{argmin}_{\textbf{h}} \sum_{i=1}^{N}\vert\vert
w_*^i \textbf{a}_i \textbf{h}\vert\vert ^2 \qquad \text{s.t.} \vert\vert
\textbf{h}\vert\vert = 1
\]</span> 其中的 <span class="math inline">\(w_*^i\)</span>
是最关键的部分，它给了那些与 <span
class="math inline">\(\textbf{x}_*\)</span>
相近的点更高的权重。可以使用高斯函数来确定： <span
class="math display">\[
w_*^i = \exp(-\vert\vert \textbf{x}_* - \textbf{x}_i
\vert\vert^2/\sigma^2)
\]</span> 自然的 <span class="math inline">\(\sigma\)</span>
表示尺度参数。和 <a href="/2021/01/07/2021-01-07-MLS/">WLS</a>
的权函数类似，只要符合权函数那几个定义即可。这差不多就是 Moving DLT
的定义了。就加了一个权函数。上式可以矩阵化为： <span
class="math display">\[
\textbf{h}_* = \mathop{argmin}_{\textbf{h}} \vert\vert \textbf{W}_*
\textbf{A} \textbf{h}\vert\vert ^2 \qquad \text{s.t.} \vert\vert
\textbf{h}\vert\vert = 1
\]</span> 其中的 <span class="math inline">\(\textbf{W}_*\)</span>
为权重组成的对角矩阵： <span class="math display">\[
\textbf{W}_* = \mathop{diag}([w_*^1 w_*^1 w_*^2 w_*^2 \cdots w_*^N
w_*^N])
\]</span> 每一个权重都出现两次是因为 <span
class="math inline">\(\textbf{a}_i\)</span> 是一个 2
行的矩阵。矩阵化后就变成了一个加权 SVD（WSVD） 问题，它的解为 <span
class="math inline">\(\textbf{W}_*\textbf{A}\)</span>
最小奇异值的右奇异向量。为了确保有界，对那些远离的点做一个补偿（正则化），当权值低于某个值时，将它设为预定的值，因为有些时候没有匹配点（不再图像的重叠区域内），这时那些有匹配点原理当前点，则会数据不足。所以改进后的权值表达如下：
<span class="math display">\[
w_*^i = \max(\exp(-\vert\vert \textbf{x}_* - \textbf{x}_i
\vert\vert^2/\sigma^2), \gamma)
\]</span> 概念上讲 Moving DLT 是 MLS（移动最小二乘）的单应变换版本。</p>
<h3
id="图像拼接的高效计算复杂度优化">图像拼接的高效计算（复杂度优化）</h3>
<h4 id="ransac-过滤离群点">RANSAC 过滤离群点</h4>
<p>数据一般都不会是理想的，总存在噪声或者错误匹配的点（离群值）。文章使用
RANSAC 来移除离群值来减少不必要的数据。RANSAC 还是使用的
DLT，这就使得一些正确匹配点（单应局限性造成）和这些离群值一样会在 RANSAC
中产生误差，但离群点的误差会比单应局限性造成的误差大，所以 RANSAC
还是可以有效的工作。</p>
<h4 id="划分网格">划分网格</h4>
<p>为每一个源图像中的点计算它的单应模型是没有必要的，因为相近的点的单应差别不大，所以讲图像均分为网格可以提高效率并且保证准确度。可以将原图像划分为
<span class="math inline">\(C_1\times C_2\)</span>
大小的网格，每一个网格的单应由它的中心点 <span
class="math inline">\(\textbf{x}_*\)</span>
代表。这样会使得格子之间的单应变换不连续，因为使用离散的网格中心点导致权值不是连续变化。但作者在实验中认为只要分辨率足够高就不会有明显的不连续感。</p>
<h4 id="wsvd-更新">WSVD 更新</h4>
<p>在计算 Moving DLT
的时候每一次改变的只有权重矩阵，但是权重矩阵中大部分都是 <span
class="math inline">\(\gamma\)</span>（因为里当前点远的点更多），现在考虑是否不用每次都重新计算当前点的
DLT，而是通过上一次的结果来更新。</p>
<p>首先考虑权重矩阵 <span class="math inline">\(\textbf{W}_\gamma =
\gamma \textbf{I}\)</span>，令 <span
class="math inline">\(\textbf{V}\)</span> 为矩阵 <span
class="math inline">\(\textbf{W}_\gamma\textbf{A}\)</span>
右奇异向量，这个矩阵的特征值分解如下： <span class="math display">\[
\textbf{A}^T\textbf{W}_\gamma^T  \textbf{W}_\gamma\textbf{A} =
\textbf{V}\textbf{D}\textbf{V}^T
\]</span> 令 <span class="math inline">\(\tilde {\textbf{W}}\)</span> 为
<span class="math inline">\(\textbf{W}_\gamma\)</span> 改变第 i
个对角元素得到的矩阵。对它进行特征值分解有： <span
class="math display">\[
\begin{align}
\textbf{A}^T\tilde {\textbf{W}}^T  \tilde {\textbf{W}}\textbf{A} &amp;=
\textbf{V}\textbf{D}\textbf{V}^T + \rho \textbf{r}_i \textbf{r}_i^T
= \textbf{V}(\textbf{D} + \rho \overline{\textbf{r}}_i
\overline{\textbf{r}}_i^T)\textbf{V}^T \\
\rho &amp;= (\tilde{w}^2_i/\gamma^2 - 1)
\end{align}
\]</span> 其中 <span class="math inline">\(\textbf{r}_i\)</span> 为矩阵
<span class="math inline">\(\textbf{A}\)</span> 的第 i 行，<span
class="math inline">\(\overline{\textbf{r}}_i =
\textbf{V}^T\textbf{r}_i\)</span>。 <span
class="math inline">\(\textbf{D} + \rho \textbf{r}_i
\textbf{r}_i^T\)</span> 又可以特征值分解为 <span
class="math inline">\(\tilde{\textbf{C}}\tilde{\textbf{D}}\tilde{\textbf{C}}^T\)</span>，这个可以使用特征方程得到。解特征方程可以使用相关方法加速。最后解为
<span
class="math inline">\(\textbf{V}\tilde{\textbf{C}}\)</span>，这个称为
<strong>Rank-One Update</strong>，可参考<a
href="https://zhuanlan.zhihu.com/p/27742729">特征值分解（EVD）的rank 1
update - 知乎 (zhihu.com)</a>。</p>
<p>参考图如下：</p>
<p><img src="/assets/ArticleImg/2021/APAP_1.png" /></p>
<p>其中 a 为原图，b 为将原图网格化，c 为将原图通过 Moving DLT
映射到待匹配平面的结果。</p>
<h2 id="同时优化">同时优化</h2>
<p>这里讲的是将 Moving DLT
用到多幅图像（大于三幅）同时拼接用于产生全景图时，产生的相关问题和解决方法。</p>
<p>这里就没有怎么了解了。</p>
<p>主要是<strong>拼接顺序的选择</strong>以及<strong>光束法平差优化（Bundle
Adjustment）</strong>两个方面的内容。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>Homography</tag>
        <tag>图像拼接</tag>
        <tag>Moving DLT</tag>
        <tag>DLT</tag>
        <tag>MLS</tag>
        <tag>论文研读</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab ransac 库函数介绍</title>
    <url>/2021/01/25/2021-01-25-RANSAC-MATLAB/</url>
    <content><![CDATA[<p>matlab 自带了 ransac 函数，这里总结一下用法。matlab
自带的这个函数其实是 MSAC（M-estimator sample
consensus）算法，但其实差不多，它对给定数据集，以及自定的模型计算函数和误差计算函数返回具有最大内点的模型。</p>
<span id="more"></span>
<h2 id="函数声明">函数声明</h2>
<p>从 ransac 函数的源文件介绍中截取一段：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%RANSAC Fit a model to noisy data. </span></span><br><span class="line"><span class="comment">%   [model, inlierIdx] = RANSAC(data, fitFcn, distFcn, sampleSize, maxDistance) </span></span><br><span class="line"><span class="comment">%   fits a model to noisy data using the M-estimator SAmple Consensus </span></span><br><span class="line"><span class="comment">%   (MSAC) algorithm, a version of RAndom SAmple Consensus algorithm.</span></span><br><span class="line"><span class="comment">%   </span></span><br><span class="line"><span class="comment">%   Inputs      Description </span></span><br><span class="line"><span class="comment">%   ------      -----------</span></span><br><span class="line"><span class="comment">%   data        An M-by-N matrix, whose rows are data points to be modeled.</span></span><br><span class="line"><span class="comment">%               For example, for fitting a line to 2-D points, data would be an </span></span><br><span class="line"><span class="comment">%               M-by-2 matrix of [x,y] coordinates. For fitting a geometric </span></span><br><span class="line"><span class="comment">%               transformation between two sets of matched 2-D points, </span></span><br><span class="line"><span class="comment">%               the coordinates can be concatenated into an M-by-4 matrix.</span></span><br><span class="line"><span class="comment">%   </span></span><br><span class="line"><span class="comment">%   fitFcn      A handle to a function, which fits the model to a minimal</span></span><br><span class="line"><span class="comment">%               subset of data. The function must be of the form </span></span><br><span class="line"><span class="comment">%                 model = fitFcn(data)</span></span><br><span class="line"><span class="comment">%               model returned by fitFcn can be a cell array, if it is</span></span><br><span class="line"><span class="comment">%               possible to fit multiple models to the data. </span></span><br><span class="line"><span class="comment">%  </span></span><br><span class="line"><span class="comment">%   distFcn     A handle to a function, which computes the distances from the</span></span><br><span class="line"><span class="comment">%               model to the data. The function must be of the form</span></span><br><span class="line"><span class="comment">%                 distances = distFcn(model, data)</span></span><br><span class="line"><span class="comment">%               If model is an N-element cell array, then distances must be an </span></span><br><span class="line"><span class="comment">%               M-by-N matrix. Otherwise, distances must be an M-by-1 vector.</span></span><br><span class="line"><span class="comment">%  </span></span><br><span class="line"><span class="comment">%   sampleSize  Positive numeric scalar containing the minimum size of a </span></span><br><span class="line"><span class="comment">%               sample from data required by fitFcn to fit a model.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%   maxDistance Positive numeric scalar specifying the distance threshold </span></span><br><span class="line"><span class="comment">%               for finding outliers. Increasing this value will make the </span></span><br><span class="line"><span class="comment">%               algorithm converge faster, but may adversely affect the </span></span><br><span class="line"><span class="comment">%               accuracy of the result.</span></span><br><span class="line"><span class="comment">%  </span></span><br><span class="line"><span class="comment">%   Outputs     Description</span></span><br><span class="line"><span class="comment">%   -------     -----------</span></span><br><span class="line"><span class="comment">%   model       The model, which best fits the data.</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">%   inlierIdx   An M-by-1 logical array, specifying which data points are </span></span><br><span class="line"><span class="comment">%               inliers.</span></span><br></pre></td></tr></table></figure>
<p>Matlab 官网介绍：<a
href="https://ww2.mathworks.cn/help/vision/ref/ransac.html">Fit model to
noisy data - MATLAB ransac - MathWorks 中国</a></p>
<p>这里已经讲的比较清楚了，函数接收五个参数，两个返回值</p>
<h3 id="参数">参数</h3>
<ul>
<li><em>data</em>：一行为一个数据的数据集</li>
<li><em>fitFcn</em>：计算模型的<strong>函数句柄</strong>，比如匿名函数或者一般函数前面加
@ 符号</li>
<li><em>distFcn</em>：同样是函数句柄，它返回每一个数据对模型的误差，接收参数为数据以及
<em>fitFcn</em> 计算出的模型</li>
<li><em>sampleSize</em>：随机选取数据点的个数，通过这几个数据作为
<em>fitFcn</em> 的输入参数</li>
<li><em>maxDistance</em>：认为是模型到数据的可接受误差，小于这个的都认为是内点，越大函数执行的速度越快</li>
</ul>
<h3 id="返回值">返回值</h3>
<ul>
<li><em>model</em>：得出的模型</li>
<li><em>inlierIdx</em>：一个和 <em>data</em>
相同行数的逻辑矩阵，代表最后符合此模型的内点</li>
</ul>
<h2 id="使用例子">使用例子</h2>
<p>官网给出了个例子，用的是匿名函数和一些库函数计算直线，这里用自己的函数实现官网的例子。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;clc;</span><br><span class="line"><span class="comment">% 自带的数据 </span></span><br><span class="line">load pointsForLineFitting.mat</span><br><span class="line">data = points;</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(data(:,<span class="number">1</span>), data(:,<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">axis equal</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line">sampleSize = <span class="number">2</span>;</span><br><span class="line">maxDistance = <span class="number">1</span>;</span><br><span class="line">[model, inlierIdx] = ransac(data, @fitFcn, @distFcn, sampleSize, maxDistance);</span><br><span class="line"><span class="comment">% 绘制内点</span></span><br><span class="line">inlier = data(inlierIdx, :);</span><br><span class="line"><span class="built_in">plot</span>(inlier(:,<span class="number">1</span>), inlier(:,<span class="number">2</span>), <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">x = [<span class="built_in">min</span>(data(:,<span class="number">1</span>)), <span class="built_in">max</span>(data(:, <span class="number">1</span>))];</span><br><span class="line">y = model(<span class="number">1</span>)*x + model(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;g--&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line"><span class="comment">% 这里的模型就是算直线的 k 和 b ，y = kx+b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">model</span> = <span class="title">fitFcn</span><span class="params">(data)</span></span></span><br><span class="line">    x = data(:,<span class="number">1</span>);</span><br><span class="line">    y = data(:,<span class="number">2</span>);</span><br><span class="line">    k = (y(<span class="number">1</span>) - y(<span class="number">2</span>))/(x(<span class="number">1</span>) - x(<span class="number">2</span>));</span><br><span class="line">    b = -k*x(<span class="number">2</span>) + y(<span class="number">2</span>);</span><br><span class="line">    model = [k, b];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 就是算 (y - y&#x27;)^2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distances</span>  = <span class="title">distFcn</span><span class="params">(model, data)</span></span></span><br><span class="line">    k = model(<span class="number">1</span>);</span><br><span class="line">    b = model(<span class="number">2</span>);</span><br><span class="line">    distances  = (data(:,<span class="number">2</span>) - (k*data(:,<span class="number">1</span>) + b)).^<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/assets/ArticleImg/2021/ransac-matlab.png" /></p>
<p>其中圆点表示数据，橘色代表最后的内点，直线为最后得到的模型。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>RANSAC</tag>
      </tags>
  </entry>
  <entry>
    <title>对极几何简单介绍</title>
    <url>/2021/06/11/2021-06-11-%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="相机模型">相机模型</h2>
<blockquote>
<p><a
href="https://zhuanlan.zhihu.com/p/52790054">《CV中的多视图几何》——再谈相机模型
- 知乎 (zhihu.com)</a></p>
<p><a
href="https://im.perhapsbay.es/kb/an-introduction-to-epipolar-geometry">An
Introduction to Epipolar Geometry | Sanyam Kapoor
(perhapsbay.es)</a></p>
</blockquote>
<p>小孔相机是相机模型的简化，小孔与成像平面之间的距离称为焦距。一般来说，小孔越小成像越清晰，但太小会造成衍射，导致成像模糊。</p>
<figure>
<img src="/assets/ArticleImg/2021/对极几何相关.assets/mIBhDt8.png"
alt="A Simple Pinhole Camera Model" />
<figcaption aria-hidden="true">A Simple Pinhole Camera
Model</figcaption>
</figure>
<p>由相似三角形可得，空间上一点 <span
class="math inline">\((X,Y,Z)\)</span> 在成像平面上的点为：<span
class="math inline">\((f\frac{X}{Z},f\frac{Y}{Z})\)</span>，矩阵表达如下：
<span class="math display">\[
\left(
\begin{matrix}
fX\\
fY\\
Z
\end{matrix}
\right)
=
\left[
\begin{matrix}
f &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; f &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
\end{matrix}
\right]
\left(
\begin{matrix}
X \\
Y \\
Z\\
1
\end{matrix}
\right)
\tag{1}
\]</span> 即 <span class="math inline">\(\mathbf{x} =
P\mathbf{X}\)</span>，需要注意的是，这里矩阵相乘的结果还需要除以第三个分量的
<span class="math inline">\(Z\)</span>
才为真正的图像平面坐标（齐次化），即 <span class="math inline">\(\bf
x\)</span>
为摄像机坐标系下的坐标，除以第三个分量为图像坐标系下的点，即像素点，其中矩阵：
<span class="math display">\[
K =
\left[
\begin{matrix}
f_x &amp; s &amp; p_x \\
0 &amp; f_y &amp; p_y \\
0 &amp; 0 &amp; 1
\end{matrix}
\right]
\]</span> 为相机内参矩阵，为式(1)矩阵的拓展，其中 <span
class="math inline">\(f_x,f_y\)</span> 表示相机像素长宽不一定一致，<span
class="math inline">\(p_x,p_y\)</span>
为成像平移，因为不一定在中心，<span class="math inline">\(s\)</span>
为仿射畸变，即成像横纵轴不一定垂直。理想状态下相机如式(1)所示。</p>
<p>令 <span class="math inline">\(\bf p\)</span>
表示图像坐标系上的点有：<span class="math inline">\(Z\mathbf{p} =
\mathbf{x} = K\mathbf{X}\)</span>，其中 <span class="math inline">\(X =
(X,Y,Z)\)</span>，<strong>归一化坐标</strong>表示为 <span
class="math inline">\(\mathbf{\hat X} = (X/Z, Y/Z,
1)\)</span>，也就是将坐标都压缩到 <span class="math inline">\(Z =
1\)</span> 平面上。</p>
<p>归一化坐标和图像坐标有以下关系： <span class="math display">\[
\begin{align}
Z\mathbf{p} &amp;= \mathbf{x} = K\mathbf{X} \\
\mathbf{p} &amp;= K\mathbf{\hat X} \\
\mathbf{\hat X} &amp;= K^{-1}\mathbf{p} \tag 2
\end{align}
\]</span></p>
<span id="more"></span>
<h2 id="对极几何-epipolar-geometry">对极几何 Epipolar Geometry</h2>
<blockquote>
<p><a
href="https://towardsdatascience.com/introduction-to-epipolar-geometry-1bbe6e505b81">Introduction
To Epipolar Geometry | by Nabil MADALI | Towards Data Science</a></p>
<p><a
href="https://im.perhapsbay.es/kb/an-introduction-to-epipolar-geometry">An
Introduction to Epipolar Geometry | Sanyam Kapoor
(perhapsbay.es)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/368843742">VSLAM
笔记——我们如何通过图像来计算位姿的变化：对极几何 - 知乎
(zhihu.com)</a></p>
</blockquote>
<p><strong>对极几何考虑的是两个成像视图中固有的投影几何，独立于场景结构，且只取决于相机的内外参数。</strong>一般用于解决双目匹配和视图对应点搜索一类的问题。</p>
<p>对极几何模型如下图所示：</p>
<figure>
<img src="/assets/ArticleImg/2021/对极几何相关.assets/GbafZIY.png"
alt="Point Correspondence and Epipolar Geometry" />
<figcaption aria-hidden="true">Point Correspondence and Epipolar
Geometry</figcaption>
</figure>
<p>上图中 <span class="math inline">\(\bf{C,C&#39;}\)</span>
为两个摄像机的光心，<span class="math inline">\(\mathbf{X}\)</span>
为三维空间中的目标点，它在两幅图像的投影点分别为 <span
class="math inline">\(\bf{x},\bf{x&#39;}\)</span>，光心连线交两个成像平面分别于
<span class="math inline">\(\bf{e},
\bf{e&#39;}\)</span>。对极几何的一些基础概念如下：</p>
<ul>
<li><strong>基线 Baseline：</strong>光心连线 <span
class="math inline">\(\bf{CC&#39;}\)</span></li>
<li><strong>对极平面 Epipolar plane：</strong>由光心和目标点组成的平面
<span class="math inline">\(\bf{\pi:CXC&#39;}\)</span></li>
<li><strong>极点 Epipolar Point：</strong>光心连线交成像平面的点 <span
class="math inline">\(\bf{e,e&#39;}\)</span></li>
<li><strong>极线 Epipolar line：</strong>投影点和极点的连线 <span
class="math inline">\(\bf{l:xe,l&#39;:x&#39;e&#39;}\)</span></li>
</ul>
<p>对极几何主要有以下两个方向的用途：</p>
<ol type="1">
<li>立体匹配问题。两个投影之间的空间位置关系已知的情况下，由于对极几何模型带来的一致性约束，将搜索空间定位在两张图像上，也就是在相应的极线上搜索。将最初的二维搜索问题直接简化为一维搜索。双目测距就是一个典型应用。</li>
<li>确定两个拍摄点的相对位置和姿态。在不知道视角位置的情况下，通过搜索图像对中的匹配点，便可以确定它们之间的相对位置和姿态。广泛应用于机器人导航，地图构建，三维重建等方向。</li>
</ol>
<h3 id="本质矩阵-essential-matrix">本质矩阵 Essential Matrix</h3>
<blockquote>
<p><a
href="https://zhuanlan.zhihu.com/p/56700255">《CV中的多视图几何》——基础矩阵、本质矩阵
- 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/368843742">VSLAM
笔记——我们如何通过图像来计算位姿的变化：对极几何 - 知乎
(zhihu.com)</a></p>
<p><a
href="https://towardsdatascience.com/introduction-to-epipolar-geometry-1bbe6e505b81">Introduction
To Epipolar Geometry | by Nabil MADALI | Towards Data Science</a></p>
</blockquote>
<p>两个相机 <span class="math inline">\(\bf {C,C&#39;}\)</span>
，对应的相机若以 <span class="math inline">\(\bf C\)</span>
为标准，有以下式子成立： <span class="math display">\[
\begin{align}
Z_1p_1 &amp;= K_1X \\
Z_2p_2 &amp;= K_2X&#39; \\
&amp;= K_2(RX+T) \\
&amp;= K_2(Z_1RK_1^{-1}p_1 + T) \\
K_2^{-1}p_2 &amp;= \frac{1}{Z_2}(Z_1RK_1^{-1}p_1 + T) \\
\text{由式（2）可得:}\\
x_2 &amp;= \frac{1}{Z_2}(Z_1Rx_1 + T) \tag{3}
\end{align}
\]</span> 式(3)的 <span class="math inline">\(x_1,x_2\)</span> 为 <span
class="math inline">\(X,X&#39;\)</span> 在各自坐标系下的归一化坐标，其中
<span class="math inline">\(R,T\)</span>
分别为旋转矩阵和平移向量。式(3)两边同与 <span
class="math inline">\(T\)</span> 做叉积可得： <span
class="math display">\[
T\times x_2 = \frac{Z_1}{Z_2}T\times R x_1
\]</span> 然后与 <span class="math inline">\(x_2\)</span> 做点积可得：
<span class="math display">\[
x_2\cdot(T\times x_2) = x_2\cdot (\frac{Z_1}{Z_2}T\times R x_1) = 0 \tag
4
\]</span> 对于向量 <span class="math inline">\(a =
(a_1,a_2,a_3)\)</span> ，向量 <span class="math inline">\(b =
(b_1,b_2,b_3)\)</span> 有以下关系成立（可参考<a
href="http://www.liuxiao.org/wiki/linear-algebra/反对称矩阵-skew-symmetric-matrix/">反对称矩阵
(Skew-symmetric Matrix) - 技术刘 (liuxiao.org)</a>）： <span
class="math display">\[
\begin{align}
a \times b &amp;= [a]_{\times}  b \\
[a]_{\times} &amp;=
\left[
\begin{matrix}
0 &amp; -a_3 &amp; a_2 \\
a_3 &amp; 0 &amp; -a_1 \\
-a_2 &amp; a_1 &amp; 0 \\
\end{matrix}
\right]
\end{align}
\]</span></p>
<p>所以式(4)可以化简为： <span class="math display">\[
\begin{align}
x_2 \cdot [T]_{\times} R x_1 &amp;= 0 \\
x_2^T E x_1 &amp;= 0 \tag 5
\end{align}
\]</span> 令 <span class="math inline">\(E =
[T]_{\times}R\)</span>，即为<strong>本质矩阵，反映了归一化坐标与相机相对位置姿态的关系。</strong></p>
<h3 id="基础矩阵-fundamental-matrix">基础矩阵 Fundamental Matrix</h3>
<blockquote>
<p><a
href="https://im.perhapsbay.es/kb/an-introduction-to-epipolar-geometry">An
Introduction to Epipolar Geometry | Sanyam Kapoor
(perhapsbay.es)</a></p>
<p><a
href="https://zhuanlan.zhihu.com/p/56700255">《CV中的多视图几何》——基础矩阵、本质矩阵
- 知乎 (zhihu.com)</a></p>
</blockquote>
<p>根据式(2)中归一化坐标与像素坐标的关系有： <span
class="math display">\[
x_1 = K_1^{-1} p_1 \\
x_2 = K_2^{-1}p_2
\]</span> 带入式(5)可得： <span class="math display">\[
\begin{align}
p_2^TK_2^{-T}EK_1^{-1}p_1 &amp;= 0\\
p_2^T F p_1 &amp;= 0 \tag{6}
\end{align}
\]</span> 令 <span class="math inline">\(F =
K_2^{-T}EK_1^{-1}\)</span>，其中 <span class="math inline">\(F\)</span>
就称为基础矩阵，<strong>基础矩阵表示了像素坐标与摄像机内参以及相机相对位置姿态之间的关系。</strong></p>
<p><strong>基础矩阵本质上是点到极线的一个映射</strong>。此映射推导过程如下：</p>
<p><span class="math inline">\(y_1 = P_1X\)</span>，由 <span
class="math inline">\(y_1\)</span> 可确定一条直线，这条直线均可投影到
<span class="math inline">\(y_1\)</span> 处，如下： <span
class="math display">\[
X(\lambda) = P_1^+ y_1+\lambda C_1
\]</span> <span class="math inline">\(y_1,X(\lambda)\)</span> 分别为
<span class="math inline">\(C_1\)</span> 下的图像坐标，<span
class="math inline">\(C_1\)</span> 坐标系三维坐标。<span
class="math inline">\(P_1^+\)</span> 为 <span
class="math inline">\(P_1\)</span> 的伪逆，有 <span
class="math inline">\(P_1^+ = P_1^T(P_1P_1^T)^{-1}\)</span>，可验证
<span class="math inline">\(P_1 X(\lambda) = P_1P_1^+y_1 + \lambda P_1
C_1 = y_1\)</span>。（伪逆可参考：<a
href="https://www.cnblogs.com/bigmonkey/p/12070331.html">线性代数笔记34——左右逆和伪逆
- 我是8位的 - 博客园 (cnblogs.com)</a>）</p>
<p><span class="math inline">\(X(\lambda)\)</span>
通过另外一个相机投影矩阵 <span class="math inline">\(P_2\)</span>
投影便可以获得极线 <span class="math inline">\(l&#39;\)</span>，可以取
<span class="math inline">\(X(\lambda)\)</span> 上两个特殊点 <span
class="math inline">\(P_1^+y_1,C_1\)</span> ，分别通过 <span
class="math inline">\(P_2\)</span> 投影可得 <span
class="math inline">\(P_2P_1^+y_1,P_2C_1\)</span>，注意这里的 <span
class="math inline">\(P_2\)</span>
包括了外参矩阵和内参矩阵。这两个点叉乘便可以得到极线 <span
class="math inline">\(l&#39;\)</span> 的参数表达式，<span
class="math inline">\(P_2C_1\)</span> 就是极点 <span
class="math inline">\(e&#39;\)</span> 所以有： <span
class="math display">\[
l&#39; = e&#39; \times P_2P_1^+y_1 = [e&#39;]_{\times}P_2P_1^+y_1 \tag 7
\]</span> <span class="math inline">\(X\)</span> 在 <span
class="math inline">\(C_2\)</span> 下的投影点为 <span
class="math inline">\(y_2\)</span>，显然 <span
class="math inline">\(y_2\)</span> 在极线上，所以有： <span
class="math display">\[
y_2\cdot l&#39; = y_2^T [e&#39;]_{\times}P_2P_1^+y_1 = 0
\]</span> 令 <span class="math inline">\(F =
[e&#39;]_{\times}P_2P_1^+\)</span> 便得到： <span
class="math display">\[
y_2^T F y_1 = 0
\]</span></p>
<p>此时这里的 <span class="math inline">\(y_1,y_2\)</span>
为相机坐标系下的点，和对于图像坐标系的点有以下关系 <span
class="math inline">\(y_1 = Z_1p_1,y_2 =
Z_2p_2\)</span>，带入上式消去常数 <span
class="math inline">\(Z_1,Z_2\)</span>，可得式(6)： <span
class="math display">\[
p_2^T F p_1 = 0
\]</span> 极线还可表达为：<span
class="math inline">\(l&#39;=e&#39;\times
y_2\)</span>，根据单应矩阵的性质，可得 <span class="math inline">\(y_2 =
H_{\pi} y_1\)</span>，即有 <span class="math inline">\(l&#39; = e&#39;
\times H_{\pi} y_1\)</span>，对比式(7) ，可以得到: <span
class="math display">\[
H_\pi = P_2P_1^+
\]</span> 此时便得到了基础矩阵，相机矩阵，单应矩阵之间的联系。</p>
<p>之前提到 <span class="math inline">\(P_2\)</span>
由相机内参和外参组成，可令 <span class="math inline">\(C_1\)</span>
相机坐标系和世界坐标系重合，代数表达如下： <span class="math display">\[
P_1 = K_1[\mathbf{I}|\mathbf{0}] \\
P_2 = K_2[\mathbf{R}|\mathbf{T}] \\
\]</span> <a
href="https://zhuanlan.zhihu.com/p/56700255">《CV中的多视图几何》——基础矩阵、本质矩阵
- 知乎 (zhihu.com)</a>中解释了如何将 <span class="math inline">\(F =
[e&#39;]_{\times}P_2P_1^+\)</span> 推导为 <span class="math inline">\(F
= K_2^{-T}EK_1^{-1}\)</span> 的过程。</p>
<h3 id="补充">补充</h3>
<p>以上引用文章中的推导将归一化坐标，图像坐标，摄像机坐标描述的很模糊，摄像机坐标到图像坐标本质上是一个齐次化过程，但都描述的比较模糊。</p>
<p>一些另外补充：</p>
<ul>
<li><p><a
href="https://zhuanlan.zhihu.com/p/55567702">本质矩阵，基础矩阵，自由度及其解法
- 知乎 (zhihu.com)</a></p></li>
<li><p><a
href="https://www.zhihu.com/question/270431743/answer/401695352">为什么本质矩阵５自由度，基础矩阵７自由度，单应矩阵８自由度？
- 知乎 (zhihu.com)</a></p></li>
<li><p>如何得到本质矩阵 <span class="math inline">\(E\)</span>
以及如何将本质矩阵 <span class="math inline">\(E =
[T]_{\times}R\)</span> 经过SVD 分解得到 <span
class="math inline">\(T,R\)</span> 的方法参考：<a
href="https://zhuanlan.zhihu.com/p/368843742">VSLAM
笔记——我们如何通过图像来计算位姿的变化：对极几何 - 知乎
(zhihu.com)</a>，一般通过图像匹配点获得基础矩阵，然后得到本质矩阵，最后分解得到
<span
class="math inline">\(R,T\)</span>，相机内参矩阵可通过标定得到。</p></li>
</ul>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
        <category>三维视觉与SLAM</category>
      </categories>
      <tags>
        <tag>对极几何</tag>
        <tag>相机模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】图像特征检测，描述和匹配</title>
    <url>/2020/12/03/2020-12-03-Image%20Features%20Detection%20Description%20and%20Matching/</url>
    <content><![CDATA[<blockquote>
<p>Hassaballah, M. , A. A. Ali , and H. A. Alshazly . "Image Features
Detection, Description and Matching." (2016).a</p>
<p>原文地址：<a
href="https://link.springer.com/chapter/10.1007%2F978-3-319-28854-3_2">Image
Features Detection, Description and Matching</a></p>
</blockquote>
<p><strong>摘要</strong>
特征检测，描述和匹配是计算机视觉应用中重要的组成部分，因此它们在前几十年中受到了极大的注意。几种特征检测器和描述符已经在文献在中被提出，且对图像中那些具有潜在吸引力（即，具有一种独特的属性）的点做了许多定义。这篇文章为检测和描述图像特征介绍了基本符号和数学概念。然后文章还讨论了完美特征所具有的性质并且概述了现存的多种检测和描述方法。更深地，文章还解释了一些特征匹配方法。最后，文章讨论了最常用的检测和描述算法性能评估技术。</p>
<p><strong>关键词</strong> 兴趣点 特征检测器 特征描述符 特征提取
特征匹配</p>
<span id="more"></span>
<h2 id="介绍">1 介绍</h2>
<p>在前几十年中，图像特征检测器和描述符已经成为计算机视觉社区中最流行的工具并且被广泛应用在大量的应用中。图像表示
【1】，图像分类和图像检索 【2-5】，目标识别和匹配 【6-10】，三维场景重建
【11】，动作追踪 【12-14】，纹理分类 【15-16】，机器人定位
【17-19】，以及生物识别系统
【20-22】，所有都依赖于图像中稳定且有代表性的特征。因此，对于这些应用，检测和提取图像特征是十分重要的步骤。</p>
<p>为了建立图像之间的对应关系，其中两个或多个图像的对应关系是需要的，确定每一幅图像中显著的点集是重要的
【8，23】。在分类任务中，目标图像的特征描述符和训练完成的图像特征相匹配，并且已训练图像中具有最大一致对应关系的就是最佳匹配。在这种情况下，特征描述符匹配可以建立在距离测量上，例如欧几里得距离或者马氏距离。对于图像配准，同一场景不同设备不同时间获取的两幅或者多幅图像的空间对齐是十分重要的。图像配准或对齐任务中主要的步骤为：特征检测，特征匹配，基于图像中一致特征的变换函数的推导，以及基于导出的变换函数的图像重建【24】。任何匹配、识别系统的首要步骤是检测以及描述图像中的兴趣位置。一旦计算出描述符，比较这些描述符可以得到图像间的关系以完成匹配、识别任务。另外，对于线上街道级别虚拟导航应用，我们需要特征检测和特征描述符从一些平面图像（全景图像）中取提取特征【25】。</p>
<p>基本思想是首先检测对一类转换协变的兴趣区域。然后，对于每个检测到的区域，在检测到的关键点周围构建图像数据的不变特征向量表示（即描述符）。<u>从图像中提取特征描述符可以基于二阶统计数据、参数模型、从图像变换中获取的参数，甚至是这些方法的组合。</u>两种图像特征可以从图像内容表示中提取出来：<u>全局特征和局部特征</u>。全局特征（例如颜色和纹理）目的是将图像作为整体考虑，可以解释为从图像所有像素中获取的一种特别的属性。然而，局部特征是用于发现和描述图像中的关键点或兴趣区域。在这方面，如果局部特征算法在图像中检测到
n 个关键点，就有 n
个向量描述每一个关键点的形状，颜色，方向，纹理等。全局颜色和纹理特征被证实在数据库中寻找相似图像十分有用，而面向局部结构的特征适合目标分类或者寻找同一对象或场景的其它事件【26】。同时，全局特征不能区分图像的前景和背景，以及两个部分的混合信息【27】。</p>
<p>另一方面，因为实时应用需要处理更多数据或者需要在计算能力有限的移动设备中运行，对可以快速计算，快速匹配，有效利用内存并且还要保持好的准确度的局部特征描述符的需求在不断增长。另外，对移动平台上的图像匹配来说，局部特征描述符被证实是一个很好的选择，在这里可以处理遮挡和丢失的对象【18】。<u>对于相机标定，图像分类，图像检索和目标追踪、重建这一类具体应用，特征检测器和描述符对亮度、视角改变和图像扭曲（例如噪声，模糊，光照）的鲁棒性是十分重要的</u>【28】。
而其他特定的视觉识别任务，如人脸检测或识别，则需要使用特定的检测器和描述符【29】。</p>
<p>在文献中，大量的特征提取方法被提出来计算可靠的描述符。有些描述符是专门为特定的应用场景设计例如形状匹配【29，30】。在这些描述符中，<u>尺度不变特征变换（SIFT）</u>描述符【31】利用了高斯函数中一系列差分（DoG）中的局部极值来提取鲁棒性特征，并且<u>加速稳健特征（SURF）</u>描述符【32】受到
SIFT 的部分启发，用于快速计算独特不变的局部特征，SURF
十分流行且广泛应用于多种应用。这些描述符使用预设的过滤器和非线性操作来表示突出的图像区域。在文章的剩余部分，
我们概述了这些方法和算法以及开发人员提出的改进。更深地，我们也将介绍检测和描述图像特征的基础符号和数学概念。我们还在细节上探索检测器和描述符之间的量化关系以及如何评估它们的性能。</p>
<h2 id="定义和原理">2 定义和原理</h2>
<h3 id="全局和局部特征">2.1 全局和局部特征</h3>
<p>在图像处理和计算机视觉任务中，我们需要表示图像通过其特征。原始图像对人眼是抑郁提取特征的，但是对于计算机算法并非如此。总的来说，有两种表示图像的方法，全局特征和局部特征。在全局特征表达中，图像通过一个多维特征向量表示，用来描述整幅图像中的信息。换句话说，全局表示方法会生成一个单一向量，这个向量包含图像的多个方面的可测量信息，例如颜色，纹理或者形状。特别地，每幅图像中提取的单一向量可以用来作比较。例如，当一个人想要区分两幅图像，分别是关于海（蓝色）和森林（绿色）的，一个关于颜色的全局描述符可以为每个类生成完全不同的向量。在这样的背景下，全局特征可以被解释为图像中涉及所有像素的一个特别的属性。这种属性可以是颜色直方图，纹理，边缘，甚至是将图像滤波后的描述符【33】。在另一方面，局部特征表示的主要目标是根据一些显著区域区别表示图像，同时保持视角和光照不变性。因此，<u>图像是基于它的局部结构，通过从一组被称为兴趣区域（即关键点）的图像区域中提取的局部特征描述符集合来描述的</u>。
<strong><em>Fig. 1</em></strong>
描述了这些兴趣区域。大部分局部特征表达了图像块中的纹理。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201111213719530.png" alt="image-20201111213719530" style="zoom:60%;" /></p>
<p>总的来说，使用哪一种特征一般上很大程度上会依赖于手头上的应用，开发者偏向于最具有区分度的。例如，一个有着大鼻子和小眼睛的人和另一个小鼻子和大眼睛的人在释放图或者灰度分布上会有相似的面部照片。然后，从局部特征簇提取的局部特征或者全局模式看起来会根据有区分度。然而，<u>对于在
WEB
尺度级图像索引应用中的大型数据库，考虑全局特征识是合适的</u>。再者，<u>全局特征对那些可以接受粗略地兴趣目标分割应用是有用的。全局特征的优势在于它们更快，更紧凑同时易于计算且内存友好</u>。不过，全局表示也受到一些众所周知的限制，尤其是它们<u>对一些重要变换不能保持不变，并且对杂物和遮挡敏感</u>。在一些应用中，例如副本检测，许多非法拷贝和原件是十分相似的；它们仅收到压缩，缩放或者有限的裁剪【34】。同时，使用为大尺度图像搜索局部特征可以提供更好的效果【35】。另外因为局部结构比其它平滑区域结构更易区分且稳定，所以局部特征在图像匹配和目标识别中更有用。然而，它们经常需要大量的内存，因为图像可能包含成百上千个局部图像描述符。研究者建议将局部图像描述符聚集为一个紧凑向量并且降维优化【35】。</p>
<h3 id="特征检测器的特征">2.2 特征检测器的特征</h3>
<p><em>Tuytelaars</em> 和
<em>Mikolajczyk</em>【27】将局部特征定义为“是一个与其邻居区分开的图像模式”。因此，它们认为局部不变特征的目标是提供一种可以有效匹配图像间局部结构的表示。也就是说，我们希望获取一组稀疏的局部度量，这些度量可以捕获输入图像的本质并对它们的兴趣区域进行编码。为了这个目标，特征检测器和提取器必须有某些性质，同时需要记住这些性质的重要性依赖于实际的应用设置以及做出的妥协。下面列举的性质对在计算机视觉应用中运用特征是十分重要的：</p>
<ul>
<li><strong>鲁棒性</strong>，特征检测算法需要检测出同一个特征位置，不依赖缩放，选择，平移，光度变形，人为压缩和噪声。</li>
<li><strong>可重用性</strong>，特征检测算法可以在不同观测条件下获取的同一场景图像反复检测出相同的特征。</li>
<li><strong>准确性</strong>，特征检测算法应该准确地定位图像特征（相同像素位置），尤其是在需要精确对应关系来估计对极几何<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>（the epipolar
geometry）的图像匹配任务中。</li>
<li><strong>通用性</strong>，特征检测算法需要可以在不同应用中检测特征。</li>
<li><strong>高效性</strong>，特征检测算法应该能够在新图像中快速检测特征以支持实时应用。</li>
<li><strong>保量性</strong>，图像检测算法需要检测所有的或者大量的图像特征。其中，检测出的特征密度应该反映图像的信息内容以提供紧凑的图像表示。</li>
</ul>
<h3 id="尺度和仿射不变性">2.3 尺度和仿射不变性</h3>
<p>事实上，基于矩形或者圆形这类固定形状的区域匹配，在存在一些几何和光度畸变下，寻找对应关系是不可靠的，因为它们会影响区域形状。数字图形中的目标在不同的观察尺度下会有不同的外表。因此，在分析图像内容时，尺度改变会产生重要的影响。已经提出了不同的技术来解决在这种条件下检测和提取不变图像特征。一些是处理尺度变化，还有一些则更深层次地处理仿射变换。为了解决尺度变化，这些技术假设尺度的变化在所有方向上都是相同的(即均匀的)，并使用尺度空间的连续核函数在所有可能的尺度上搜索稳定的特征。其中，<u>图像的大小是不同的，并且滤波器（例如，高斯滤波器）重复地用来平滑图像，也可以保持原始图像大小，改变滤波器的大小</u>，如
<strong><em>Fig. 2</em></strong>
所示。更多关于在尺度改变下的特征检测细节可以在【36】中找到，在这之中提出了一个用于生成图像兴趣尺度级的假设，通过在高斯拉普拉斯（LoG）归一化后的尺度中寻找尺度空间极值。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201114203537215.png" alt="image-20201114203537215" style="zoom:60%;" /></p>
<p>在另一个方面，<u>在仿射变换中每一个方向的缩放可以是不同的</u><a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>。不均匀的缩放对定位，尺度，局部结构形状都有影响。因此，尺度不变检测器在这种显著仿射变换中会失效。因此，在这种均匀缩放下的特征检测器需要拓展成仿射不变检测器，以检测局部图像结构的仿射形状。因此，这些放射不变检测器可以看作是尺度不变检测器的一般推广。</p>
<p>总的来说，仿射变换是一系列变换的组合：平移，缩放，翻转，旋转，和剪切<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>。一个仿射变换（affinity）是任一个保持共线性和距离比的线性映射。在这个角度上看，仿射意味着是射影变换的一个特殊情况，他不会把任何对象从仿射空间
<span class="math inline">\(\mathbb{R}^3\)</span>
移至无穷远平面，反之亦然。简单来说，<span
class="math inline">\(\mathbb{R}^n\)</span> 仿射变换是一个映射 <span
class="math inline">\(f:\mathbb{R}^n \rightarrow
\mathbb{R}^n\)</span>，具体形式如下： <span class="math display">\[
f(Y) = \mathbb{A} Y + \mathbb{B}
\]</span> 对所有的 <span class="math inline">\(Y\in
\mathbb{R}^n\)</span> ，其中 <span
class="math inline">\(\mathbb{A}\)</span> 为 <span
class="math inline">\(\mathbb{R}^n\)</span>
上的线性变换。在一些特殊的情况，如果 <span
class="math inline">\(det(\mathbb{A}) \gt
0\)</span>，这样的变换被称为保向，然而如果 <span
class="math inline">\(det(\mathbb{A}) \lt
0\)</span>，则被称为方向反转。众所周知的是，在特定变换族下的函数是不变的，当它的值不随其参数上的变换族改变而改变。二阶矩矩阵为估计局部图像特征的仿射形状提供了理论依据。<u>仿射不变检测器有以下几种：Harris-affine，Hessian-affine，以及
maximally stable extremal regions
(MSER)</u>。还需要记住的是这些检测器检测的特征会从圆形变换为椭圆形。</p>
<h2 id="图像特征检测器">3 图像特征检测器</h2>
<p><u>特征检测器可以大概地分为三类：单尺度检测器，多尺度检测器以及仿射不变检测器。</u>概括地说，单尺度意味着使用检测器内部参数对特征或目标轮廓仅有一个表示。单尺度检测器对诸如旋转，平移，光照改变和附加噪声的变换是不变的。然而，它们不适用于处理缩放问题。给定同一场景的但尺度不同的两幅图像，我们想要确定是否可以检测到相同的兴趣点。因此，在尺度改变下，建立能够可靠地提取显著特征的多尺度检测器是有必要的。接下来我们会讨论单尺度和多尺度检测器以及仿射不变检测器的细节。</p>
<h3 id="单尺度检测器">3.1 单尺度检测器</h3>
<h4 id="moravecs-检测器">3.1.1 Moravec’s 检测器</h4>
<p>Moravec’s
检测器【37】对寻找图像中完全不同的区域感兴趣，这可以用于记录连续图像帧。它被用于角点检测算法，其中角点是那些低自相似性的点。
这个检测器测试给定图像的每一个像素来确定是否是一个角点。它考虑以某个像素为中心的局部图像块，然后确定它与相邻图像块的相似度。这个相似度是使用中心图像块核其它图像块的平方差之和（SSD）来确定的。基于
SSD 的值，我们需要考虑以下几种情况：</p>
<ul>
<li>如果像素在均匀强度的区域内，那么相邻的块会看起来相似或者发生很小的变化。</li>
<li>如果像素在边上，那么在平行方向的相邻块只有很小的改变，与边垂直的方向会有很大的变化。</li>
<li>如果像素在一个任意方向都会发生很大变化的位置，那么没有相邻块会与其相似，当任意平移都会发生很大改变时，也就检测到了一个角点。</li>
</ul>
<p>块与其邻居（水平，垂直和两个对角线）之间最小的 SSD
被用于角的一个度量。一个角或者兴趣点当 SSD
达到一个局部最大值时被检测到。下面的步骤可以用于实现 Moravec’s
检测器：</p>
<ol type="1">
<li><p>输入：灰度图像，窗口大小，阈值 <span
class="math inline">\(T\)</span></p></li>
<li><p>对图像中的每一个像素 <span
class="math inline">\((x,y)\)</span>，以及平移量 <span
class="math inline">\((u,v)\)</span>，计算强度变化 <span
class="math inline">\(V\)</span>，如下 <span class="math display">\[
V_{u,v}(x,y) = \sum_{\forall a,b \in window } [I(x+u+a,y+v+b) -
I(x+a,y+b)]^2
\]</span></p></li>
<li><p>通过计算角测度 <span class="math inline">\(C(x,y)\)</span>
为每一个像素 <span class="math inline">\((x,y)\)</span> 构建对应的角图
<span class="math display">\[
C(x,y) = min(V_{u,v}(x,y))
\]</span></p></li>
<li><p>对所有角图中所有小于 T 的值归 0</p></li>
<li><p>使用非最大值抑制寻找局部最大值。剩下所有的非零值为角点。</p></li>
</ol>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201115201625703.png" alt="image-20201115201625703" style="zoom:60%;" /></p>
<p>为了执行非最大值抑制，需要按梯度方向扫描一幅图像，这个方向是与边方向是垂直的。所有不是局部最大值的像素都会被抑制为
0。正如 <strong><em>Fig.3</em></strong> 所描述的，p 和 r 是在 q
梯度方向上的两个相邻点。如果像素 q 的值比 p，q
任一个小，则抑制。Moravec’s
检测器的一个优势为可以检测出大量的角点。然而，<u>它不是各向同性的。强度改变值仅仅在一些离散的位移上（例如，8
个理论方向）并且不再这 8
个相邻方向上的边会被分配到一个相对大的角测度。</u>因此，它不是旋转不变的<a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>，这也导致了可重用率低。</p>
<h4 id="harris-检测器">3.1.2 Harris 检测器</h4>
<p>Harris 和 Stephens【38】发展了一种结合角和边检测器的方法以解决
Moravec’s
检测器中的限制。通过获取所有方向上的自相关改变量（例如，强度改变），这使得检测器在检测和重用率上变得可取。这个基于自相关矩阵的检测器是应用最广泛的技术。这个用于检测图像特征以及描述局部结构的
2*2 对称自相关矩阵如下表示<a href="#fn5" class="footnote-ref"
id="fnref5" role="doc-noteref"><sup>5</sup></a>： <span
class="math display">\[
M(x,y) = \sum_{x,y} w(u,v) \times
\left[
\begin{matrix}
I_x^2(u,v) &amp; I_xI_y(u,v) \\
I_xI_y(u,v) &amp; I_y^2(u,v)
\end{matrix}
\right]
\]</span></p>
<p>其中 <span class="math inline">\(I_x,I_y\)</span> 分别是在 x 和 y
方向上的局部图像微分，<span class="math inline">\(w(u,v)\)</span> 表示以
<span class="math inline">\((x,y)\)</span> 为中心的区域 <span
class="math inline">\((u,v)\)</span>
中的加权窗口。如果一个圆形窗口，例如高斯函数，那么这个响应将是各向同性的，并且中心部分会有更高的权重。为了寻找兴趣点，将为每一个像素计算矩阵
M
的特征值。如果两个特征值都很大就代表这里存在着角点。特征值和检测点的分类关系描述在
<strong><em>Fig.4</em></strong> 中。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201115224916303.png" alt="image-20201115224916303" style="zoom:67%;" /></p>
<p>通过为每一个像素 <span class="math inline">\((x,y)\)</span>
计算角测度 <span class="math inline">\(C(x,y)\)</span> 构建响应图，<span
class="math inline">\(C(x,y)\)</span> 计算公式如下： <span
class="math display">\[
C(x,y)=det(M) - K(trace(M))^2
\]</span> 其中 <span class="math display">\[
\begin{align}
det(M) &amp;= \lambda_1 \times \lambda_2 \\
trace(M) &amp;= \lambda_1 + \lambda_2
\end{align}
\]</span> K 是一个调节参数，<span
class="math inline">\(\lambda_1,\lambda_2\)</span>
是自相关矩阵的特征值。特征值计算的开销是昂贵的，因为涉及到平方根的计算。因此，Harris
建议使用这个角测度，它将两个特征值合并在一个计算中。非最大值抑制用于寻找局部最大值，最后角测度图中保留的非零点就是寻找到的角点。<a
href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a></p>
<h4 id="susan-检测器">3.1.3 SUSAN 检测器</h4>
<p>Simith 和 Brady
【39】介绍了一中不使用图像微分的角点计算方法，是一种通用的低层次的图像处理技术，称为
SUSAN（Smallest Univalue Segment Assimilating Nucleus）<a href="#fn7"
class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>。它不仅是一个角检测器还可以用于边缘检测核图像降噪。<u>通过在每一个像素上放置一个固定半径的圆形掩膜来检测角点</u>。中心像素就代表着核，掩膜下的其它像素会与核相比较来检查是否与核有相似的强度值。<u>与核亮度十分相似的像素归为一组，被称为
USAN （Univalve Segment Assimilating Nucleus）。当一个位置的 USAN
中的像素个数达到一个局部最小值并且低于特别的阈值
T，这个位置就是角点</u>。为了检测角点，同一掩膜下的两个像素的相似比较函数
<span class="math inline">\(C(r,r_0)\)</span> 如下表示： <span
class="math display">\[
C(r,r_0) =
\left\{
\begin{align}
1&amp;, &amp;\text{if　}\vert I(r)-I(r_0) \vert \le T \\
0&amp;, &amp; otherwise
\end{align}
\right.
\]</span> 并且 USAN 的区域大小为： <span class="math display">\[
n(r_0) = \sum_{r \in c(r_0)} C(r,r_0)
\]</span> 其中 <span class="math inline">\(r_0\)</span> 和 <span
class="math inline">\(r\)</span> 分别是掩膜下核与其它点的坐标。SUSAN
角点检测器的性能主要依赖于相似比较函数 <span
class="math inline">\(C(r,r_0)\)</span>，它不能免疫某些影响图像的因素（例如，强亮度波动和噪声）。</p>
<p>SUSAN 检测器有如下几个优势：</p>
<ol type="1">
<li>不需要使用微分，因此不需要额外的降噪或者任何昂贵的计算</li>
<li>高可重用率</li>
<li>平移以及旋转不变</li>
</ol>
<p>不幸的是，<u>它对尺度和其它变换不是不变的，并且固定的阈值不使用于一般情况</u>。这个检测器需要一个可适应的阈值，并且掩膜的形状需要改变。</p>
<h4 id="fast-检测器7">3.1.4 FAST 检测器<a href="#fn8"
class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a></h4>
<p>FAST（Features from Accelerated Segment Test）最初是由 Rosten 和
Drummondn
【40，41】提出的角点检测器。在这个检测方案中，通过对每个像素使用分段检测来确定候选点，该方法将围绕候选点的
16 个像素作为计算基础。如果在以 r 为半径的 Bresenham 圆上有一组包含 n
个连续像素，且这些像素全部比候选像素（表示为 <span
class="math inline">\(I_p\)</span> ）与阈值 t
相加还亮，或者比与阈值相减还暗，那么 p
就被归为角点。有一种高速的检测方法来排除大量的非角点，这种快速检测方法仅检查
1，5，9，13 四个像素。一个角点必须满足至少有三个测试像素比 <span
class="math inline">\(I_p+t\)</span> 亮或者比 <span
class="math inline">\(I_p - t\)</span>
暗，快速检测方法剩下的点则使用原来的检测方法。<strong><em>Fig.5</em></strong>
描述了这个过程，其中放大的方块为角点检测使用的像素。像素 p
为候选角的中心。使用虚线描绘的弧中有 12 个连续像素比 p
亮了一个阈值。使用 <span class="math inline">\(r=3,n=9\)</span>
的圆可以带来最好的结果。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201116000143758.png" alt="image-20201116000143758" style="zoom:65%;" /></p>
<p>尽管高速测试可以有很好的性能，但还是受到了在【41】中提及的几个限制和不足。使用机器学习方法可以改善这些限制和不足。决策树算法（ID3）是一种著名的用于学习像素分类的方法，可以对上述算法有很大的加速。因为第一阶段测试会在兴趣点周围产生很多响应，所以需要额外执行非最大值抑制。这使得特征定位更加准确。这个步骤的角测度公式如下：
<span class="math display">\[
C(x,y) = max(
\sum_{j\in S_{bright}}\vert I_{p\rightarrow j} - I_p \vert - t,
\sum_{j\in S_{dark}}\vert I_p - I_{p\rightarrow j} \vert - t
)
\]</span> 其中 <span class="math inline">\(I_{p\rightarrow j}\)</span>
表示位于 Bresenham
圆上的像素。用这个方法，处理时间依然是短，因为第二个阶段测试仅仅用于通过第一阶段测试的那一小部分像素。</p>
<p>换句话说，整个处理分为两个阶段。<u>首先，对给定 n
以及合适的阈值的分段测试的角点检测在一组图像（最好是取自目标应用域）上执行。圆上的
16 个像素被分为比中心暗，相似或者亮。然后，在这 16 个位置使用 ID3
算法来得到最大信息增益</u><a href="#fn9" class="footnote-ref"
id="fnref9" role="doc-noteref"><sup>9</sup></a>。
非最大值抑制应用于连续弧中像素与中心像素之间的绝对差值之和。注意到使用
ID3
算法执行的角点检测与使用分段检测器会有轻微的不同，因为决策树模型依赖于训练数据，这些模型不能覆盖所有的角点。<u>与现存的许多检测器相比，FAST
角点检测器的高速表现使其十分适合实时视频处理应用</u>。然而，<u>它不是尺度不变的，并且对噪声敏感</u>，它还依赖于阈值，选择一个合适的阈值是一个相当重要的工作。</p>
<h4 id="hessian-检测器10">3.1.5 Hessian 检测器<a href="#fn10"
class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a></h4>
<p>Hessian 斑点检测器【42，43】是以一个关于图像强度 <span
class="math inline">\(I(x,y)\)</span> 的 <span
class="math inline">\(2\times 2\)</span> 的二阶微分矩阵，这个矩阵称为
Hesian 矩阵。这个矩阵可以用于局部图像结构，并且其形式如下： <span
class="math display">\[
H(x,y,\sigma) =
\left[
\begin{matrix}
I_{xx}(x,y,\sigma) &amp; I_{xy}(x,y,\sigma) \\
I_{xy}(x,y,\sigma) &amp; I_{yy}(x,y,\sigma)
\end{matrix}
\right]
\]</span></p>
<p>其中 <span class="math inline">\(I_{xx},I_{xy},I_{yy}\)</span>
是二阶图像微分使用标准差为 <span class="math inline">\(\sigma\)</span>
的高斯函数计算，它寻找在两个正交方向上高响应的点。也就是说，检测器寻找那些满足
Hessian 矩阵行列式达到局部最大值的点： <span class="math display">\[
\text{det}(H) = I_{xx}I_{yy}-I_{xy}^2
\]</span>
通过选择具有最大行列式的带你，这个方法长结构不友好，因为长结构在一个方向上只有很小的二阶微分（即，信号改变）。使用
<span class="math inline">\(3\times 3\)</span>
的窗口对图像执行非最大值抑制，保持那些比周围 8
个像素都大的像素不变，否则置为
0。然后，检测器返回那些保留下来的像素中大于预设阈值 T
的像素。最后保留下来的主要为角点和纹理改变强烈的区域。虽然 Hessian
矩阵用于描述点周围 8
个相邻点的局部结构，但它的行列式可以用于检测在两个方向上表现出信号变化的图像结构。与其它检测器（例如，拉普拉斯）相比，Hessian
矩阵的行列式仅在两个正交方向显著改变的局部图像模式上响应【44】。然而，在检测器中使用二阶微分使得对噪声敏感。另外，局部最大值经常存在于轮廓或者直边上，在这些位置信号仅在一个方向上发生改变【45】。因此，这些局部最大值是不稳定的，因为噪声和相邻模式的轻微改变都会产生影响。</p>
<h3 id="多尺度检测器">3.2 多尺度检测器</h3>
<h4 id="高斯拉普拉斯log">3.2.1 高斯拉普拉斯（LoG）</h4>
<p>高斯拉普拉斯（Laplacian-of-Gaussian，LoG）是一个二阶微分的线性组合且是一个常用的斑点检测器。给定一副图像
<span class="math inline">\(I(x.y)\)</span>
作为输入，图像的尺度空间表示为 <span
class="math inline">\(L(x,y,\sigma)\)</span>，通过图像和一系列不同高斯核卷积
<span class="math inline">\(G(x,y,\sigma)\)</span> 生成，其中 <span
class="math display">\[
L(x,y,\sigma) = G(x,y,\sigma)\bigotimes I(x,y) \\
G(x,y,\sigma) = \frac{1}{2\pi \sigma^2} e^{\frac{-(x^2+y^2)}{2\sigma^2}}
\]</span> 通过下式计算拉普拉斯操作 <span class="math display">\[
\nabla^2L(x,y,\sigma) = L_{xx}(x,y,\sigma) + L_{yy}(x,y,\sigma)
\]</span></p>
<p>拉普拉斯对暗斑点呈现正响应，对亮斑点则是负响应，斑点大小为 <span
class="math inline">\(\sqrt{2\sigma}\)</span>
时响应最强。然而，响应十分依赖于斑点结构的大小以及高斯平滑核的大小。高斯标准差用于控制模糊尺度。为了在图像域自动捕获不同大小的斑点，一种带有自动尺度选择的多尺度方法在【36】中提出，这种方法通过寻找如下式所示的<u>尺度归一化拉普拉斯</u>的尺度空间极值。
<span class="math display">\[
\nabla^2_{norm} L(x,y,\sigma) = \sigma^2(L_{xx}(x,y,\sigma) +
L_{yy}(x,y,\sigma))
\]</span>
它还可以检测那些在空间和尺度上同时是归一化拉普拉斯极值的点。LoG
操作符是循环对称的，因此它很自然地具有旋转不变性。LoG
很适合斑点检测，因为它的循环对称性质，但它也为例如角，边，脊，多节（multi-junctions）这类局部结构提供了很好的<u>特征尺度</u><a
href="#fn11" class="footnote-ref" id="fnref11"
role="doc-noteref"><sup>11</sup></a>估计。在这种情况下，LoG
可用于为给定的图像位置寻找特征尺度或直接检测尺度不变区域，通过寻找 LoG
函数的 3D（位置和尺度<a href="#fn12" class="footnote-ref" id="fnref12"
role="doc-noteref"><sup>12</sup></a>） 极值，如
<strong><em>Fig.6</em></strong>
所述。拉普拉斯的尺度选择性质可以在【46】中获取到细节。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201124171703461.png" alt="image-20201124171703461" style="zoom:80%;" /></p>
<h4 id="高斯差分dog">3.2.2 高斯差分（DoG）</h4>
<p>实际上，LoG
操作是十分耗时的。为了加速计算，Lowe【31】提出了一种基于局部三维极值的高效算法，极值是在使用高斯差分（Difference-of-Gaussian，DoG）构建的尺度空间金字塔中寻找的。这种方法应用于<em>尺度不变特征变换（SIFT）</em>算法。在这个背景下，DoG
给出了 LoG 的一种近似，并且用于从尺度空间极值中高效检测稳定特征。DoG
函数 <span class="math inline">\(D(x,y,\sigma)\)</span>
可以不使用卷积操作得出，通过高斯金字塔中由因子 k
分割的相邻尺度相减得到。 <span class="math display">\[
\begin{align}
D(x,y,\sigma) =&amp; (G(x,y,k\sigma)-G(x,y,\sigma)) \bigotimes I(x,y) \\
=&amp; L(x,y,k\sigma) - L(x,y,\sigma)
\end{align}
\]</span> 通过 DoG 提取的特征类型与 LoG 有一致的分类。DoG 区域检测器寻找
3D 尺度空间极值的过程如 <strong><em>Fig.7</em></strong> 所示。LoG 和 DoG
共有的<u>缺点为局部极值可以在相邻的直边轮廓中检测出，这种轮廓仅在一个方向上发生信号改变，使得它们稳定性下降，并对噪声和微小的改变敏感</u>【45】。</p>
<figure>
<img
src="\assets\Note\Image%20Features%20Detection%20Description%20and%20Matching.assets\image-20201124174117634.png"
alt="image-20201124174117634" />
<figcaption aria-hidden="true">image-20201124174117634</figcaption>
</figure>
<h4 id="harris-laplace13">3.2.3 Harris-Laplace<a href="#fn13"
class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a></h4>
<p>Harris-Laplace 是由 Mikolajczyk 和
Schmid【45】提出的尺度不变的角点检测器。<u>它依赖于 Harris
角点检测器和高斯尺度空间的组合</u>。尽管 Harris
角点具有旋转不变性和光照不变性，但不是尺度不变的因此，对该检测器中使用的二阶矩矩阵进行了修正，使其与图像分辨率无关。Harris-Laplace
中的尺度适应的二阶矩矩阵表示如下： <span class="math display">\[
M(x,y,\sigma_1,\sigma_D) = \sigma^2_D g(\sigma_1)
\left[
\begin{matrix}
I^2_{x}(x,y,\sigma_D) &amp; I_{x}I_y(x,y,\sigma_D) \\
I_{x}I_y(x,y,\sigma_D) &amp; I^2_{y}(x,y,\sigma_D)
\end{matrix}
\right]
\]</span> 其中 <span class="math inline">\(I_x,I_y\)</span> 为使用尺度为
<span class="math inline">\(\sigma_D\)</span>
的高斯核在分别在它们方向上做的图像微分。参数 <span
class="math inline">\(\sigma_1\)</span> 决定了当前尺度，Harris
角点在这个尺度下的高斯尺度空间内检测。换句话说，微分尺度 <span
class="math inline">\(\sigma_D\)</span>
决定了用于计算微分的高斯核大小。然而，积分尺度 <span
class="math inline">\(\sigma_1\)</span>
用于控制某一相邻区域内的微分加权平均。多尺度 Harris
角点度量是使用上式矩阵的行列式和迹计算的，如下式： <span
class="math display">\[
C(x,y,\sigma_1,\sigma_D) = \text{det} [M(x,y,\sigma_1,\sigma_D)]-\alpha
\cdot \text{trace}^2[M(x,y,\sigma_1,\sigma_D)]
\]</span> 常量 <span class="math inline">\(\alpha\)</span> 的值在 0.04
和 0.06 之间。在每一层尺度空间表示中，通过检测点 <span
class="math inline">\((x,y)\)</span> 8
邻域的局部最大值来提取兴趣点。然后，使用阈值来过滤那些极值比较小的角点，因为它们在任一观测条件下都不稳定
<span class="math display">\[
C(x,y.\sigma_1,\sigma_D) &gt; Threshold_{Harris}
\]</span> 另外，LoG
也可以用于寻找所有尺度上的极大值。其中，只有那些达到拉普拉斯最大值或者其响应大于阈值的点才可以接受<a
href="#fn14" class="footnote-ref" id="fnref14"
role="doc-noteref"><sup>14</sup></a>。 <span class="math display">\[
\sigma_1^2\vert L_{xx}(x,y,\sigma_1) + L_{yy}(x,y,\sigma_1) \vert &gt;
Threshold_{Laplacian}
\]</span> Harris-Laplace
提供了一组具有代表性的点，这些点在图像以及尺度维度都是具有特征的。与多尺度
Harris 相比，Harris-Laplace
减少了很多不必要的兴趣点。这些兴趣点在尺度，旋转，光照以及附加噪声具有不变性。
此外，兴趣点是高可重用的。然而，Harris-Laplace 检测器与 LoG 和 DoG
检测器相比，返回更少的点。它也不适用于仿射变换。</p>
<h4 id="hessian-laplace">3.2.4 Hessian-Laplace</h4>
<p>和 Harris-Laplace 相似，基于 Hessian
矩阵的检测器也可以用相同的方法构造一个具有尺度不变性的检测器，名为
Hessian-Laplace。首先，我们使用 Laplacian 或者它的近似表示 DoG
来构造尺度空间。然后使用 Hessian
矩阵的行列式提取尺度不变类斑点特征。Hessian-Laplace
检测器获取的大量特征覆盖了整幅图像，和 Harris-Laplace
相比可重用性略低。此外，由于空间和尺度定位中使用的滤波器的相似性，提取的位置更适合于基于二阶高斯微分的尺度估计。Bay
et al. 【32】宣称基于 Hessian 的检测器比基于 Harris
的更稳定。类似得，使用 DoG 代替 LoG 来加速计算，Hessian
行列式使用积分图像技术来近似【29】以达到 Fast Hessian 检测器【32】。</p>
<h4 id="gabor-wavelet-检测器">3.2.5 Gabor-Wavelet 检测器</h4>
<p>最近，Yussof 和 Hitam【47】提出一种基于 Gabor 小波<a href="#fn15"
class="footnote-ref" id="fnref15"
role="doc-noteref"><sup>15</sup></a>的多尺度兴趣点检测器。Gabor
小波是受高斯包络函数限制的平面波形状的生物激励卷积核，其核类似于哺乳动物简单皮层细胞的二维感受场谱的响应。Gabor
小波使用经过高斯包络函数调制的复平面波。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201125112807047.png" alt="image-20201125112807047" style="zoom:39%;" /></p>
<p>其中 <span class="math inline">\(K_{u,v} = K_ve^{i\Phi
u},z=(x,y)\)</span>，u 和 v 决定了Gabor 小波的方向和尺度，<span
class="math inline">\(K_v = K_{max}/f^v\)</span> 并且 <span
class="math inline">\(\Phi_u = \pi u/8\)</span>，<span
class="math inline">\(K_{max}\)</span> 是最大频率，<span
class="math inline">\(f = \sqrt{2}\)</span>
为频率域内核间距因子。通过下面的卷积计算图像 <span
class="math inline">\(I\)</span> 与 <span
class="math inline">\(\psi\)</span> 之间的响应 <span
class="math display">\[
G = I \bigotimes \psi
\]</span>
这个卷积的系数表示局部图像区域的信息，这应该比独立的像素更有效。Gabor
小波的优势是可以同时在空间和空间频率域上提供最佳分辨率。另外，Gabor
小波可以增强低层次的特征，例如峰，谷，脊。因此，通过组合图像多方向的响应，它可以从不同尺度的图像中提取特征点。兴趣点在多个尺度上提取，并结合均匀间隔的方向。作者证明了
Gabor
小波检测器提取的特征点对不同几何变换都具有高准确度以及高适应性。</p>
<h3 id="仿射不变检测器">3.3 仿射不变检测器</h3>
<p>到现在为止讨论的特征检测器展示了平移、旋转和均匀尺度的不变性，并认为局部图像结构的位置和尺度不受仿射变换的影响。因此，它们可以处理一部分富含挑战性的反射不变性问题，同时记住尺度在每个方向上是可以不同的。这反过来使得尺度不变检测器不能处理显著的仿射变换。因此，建立一个对透视变换具有鲁棒性的检测器需要仿射变换不变性。一个仿射不变检测器可以视作是尺度不变检测器的一般版本。最近，一些特征检测器拓展为可以处理仿射变换不变特征。举个例子，Schaffalitzky
和 Zisserman 【48】通过仿射归一化拓展 Harris-Laplace 检测器。Mikolajczyk
和 Schmid
【45】介绍了一种尺度以及仿射不变兴趣点检测方法。他们的算法同时适应了点邻域的位置，尺度，形状来获取仿射不变点。其中，Harris
检测器使用适用于仿射变换并基于二阶矩矩阵估计点邻域的形状。这是通过如下由
Lindberg 和 Garding【49】得出的迭代估计方案：</p>
<ol type="1">
<li>使用尺度不变 Harris-Laplace 检测器明确初始区域点。</li>
<li>对每一个初始点，使用仿射形状自适应将区域归一化以满足仿射不变。</li>
<li>迭代估计仿射区域，选择合适的积分尺度，微分尺度和空间定位兴趣点。</li>
<li>使用这些尺度以及空间定位来更新仿射区域。</li>
<li>重复第三步直到满足停止条件。</li>
</ol>
<p>类似于 Harris-affine，同样的想法可以用于基于 Hessian
的检测器，以实现名为 Hessian-affine
的仿射不变检测器。对于单幅图像。Hessian-affine 通常比 Harris-affine
得到更多可靠的区域。性能的改变依赖于分析的场景类型。再者，Hessian-affine
对纹理场景有很好的响应，纹理场景中有很多类似角的部分。然而，对一些类似建筑的结构化场景，Hessian-affine
处理得很好。Mikolajczyk 和 Schmid
对几种最先进的仿射检测器进行了深入的分析【50】。</p>
<p>由于篇幅限制，还有几种没有被讨论过的特征检测器，例如，Fast Hessian 或
the Determinant of Hessian (DoH) 【32】
，MSER【51，52】。关于这些检测器更详细的讨论见【44，45，53】。</p>
<h2 id="图像特征描述">4 图像特征描述</h2>
<p>一旦在位置 <span class="math inline">\(p(x,y)\)</span>，尺度 <span
class="math inline">\(s\)</span>，以及角度 <span
class="math inline">\(\theta\)</span> 检测到一组兴趣点，它们在 <span
class="math inline">\(p\)</span>
邻域的内容或者图像结构就需要编码为合适的描述符以达到有识别度的匹配并对局部图像变形不敏感。这种描述符需要和
<span class="math inline">\(\theta\)</span> 对齐并和尺度 <span
class="math inline">\(s\)</span>
成比例。文献中有大量的图像特征描述符，最常用的是在接下来的章节中要讨论的几种。</p>
<h3 id="尺度不变特征变换sift">4.1 尺度不变特征变换（SIFT）</h3>
<p>lowe【31】提出了尺度不变特征变换算法（scale-invariant feature
transform ，SIFT），其使用 DoG
操作在图像中检测到大量的兴趣点。这些点通过 DoG
函数的局部极值选择。在每一个兴趣点可以提取一个特征向量。在多个尺度上，在兴趣点周围的邻域上，利用局部图像属性来估计图像的局部方向，以提供相对于旋转的不变性。接下来，为每一个检测到的点基于特定特征尺度的局部图像信息计算一个描述符。通过建立兴趣点周围区域的梯度方向直方图，SIFT
描述符寻找最高的方向值并且其它大于最值 80%
的值，并使用这些方向作为这个关键点的主方向。</p>
<p>SIFT 算法的描述阶段从采样关键点周围 <span
class="math inline">\(16\times 16\)</span>
区域的梯度值与方向开始，使用它的尺度作为高斯模糊的等级。然后，将原区域划分为
<span class="math inline">\(4\times 4\)</span>
的子区域，并为每个子区域创建一组包含 8 个方向的方向直方图。<span
class="math inline">\(\sigma\)</span>
大小为区域一半的高斯加权函数为每一个采样点赋予一个权值，位于区域中心的梯度有较高的权值，这些梯度受位置变化的影响较小。描述符由所有方向直方图组成的向量构成。因为有
<span class="math inline">\(4\times 4\)</span> 个直方图，每一个都包含 8
个 bin，所以每个关键点的特征向量有 <span class="math inline">\(4\times
4\times 8 = 128\)</span>
个元素。最后，特征向量归一化为单位长度以获取光照仿射变化的不变性。然而，相机饱和度或其它类似的影响造成非的线性光照改变会使得某些梯度发生大的改变。这些改变可以通过将特征向量最大值
0.2 以上的值阈值化<a href="#fn16" class="footnote-ref" id="fnref16"
role="doc-noteref"><sup>16</sup></a>处理减少，并再次归一化。<strong><em>Fig.8</em></strong>
为 SIFT
算法的图形表示，其中梯度方向和大小在每一个像素处计算并使用高斯分布加权（如图中的覆盖圆）。然后为每一个子区域计算加权的梯度方向直方图。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201126082806529.png" alt="image-20201126082806529" style="zoom:70%;" /></p>
<p>标准 SIFT
描述符表示在几个方面是值得注意的：<u>这种表示是精心设计的，以避免由于边界效应和位置的平滑变化而产生的问题，方向和尺度不会引起特征向量的根本变化；它十分紧凑，使用
128
元素的向量表示像素块；但对仿射变换不是显著不变的，这种表示对由透视效果引起的变形具有惊人的弹性</u>。这些特征在不同尺度，选择和光照下与其它竞争算法的匹配性能中得到了证明。在另一个方面，标准
SIFT 特征向量的组成是复杂的并且 SIFT 具体设计背后的选择不明确导致 SIFT
公共的高维问题，这影响了计算描述符所需的时间（十分慢）。作为 SIFT
的拓展，Ke 和 Sukthankar【54】提出了 PCA-SIFT 来减少原始 SIFT
描述符的高维性。<strong>PCA-SIFT</strong> 使用主成分分析（Principal
Components
Analysis，PCA）技术对关键点周围的梯度图像块归一化。它在给定的尺度下提取
<span class="math inline">\(41\times 41\)</span>
的块并计算竖直和水平两个方向的图像梯度，然后将两个方向的梯度连接以创建特征向量。因此，它的特征向量长度为
<span class="math inline">\(2\times 39 \times 39 =
3042\)</span>。梯度图像向量投影到事先计算的特征空间中，最后得到 36
维的特征向量。然后将向量归一化为单位大小以减少光照改变的影响。此外，Morel
和 Yu【55】证明了 SIFT
对除了六参数的仿射变换外的四参数的缩放，选择和平移是完全不变的。因此，它们介绍了
<strong>affine-SIFT（ASIFT）</strong>通过不同的相机轴方向参数，也就是
SIFT 遗留下来的经纬度角，模拟可获得的所有图像视图。</p>
<h3 id="梯度位置方向直方图gloh">4.2 梯度位置方向直方图（GLOH）</h3>
<p>梯度位置方向直方图（Gradient location-orientation histogram，GLOH）由
Mikolajczyk 和 Schmid 【50】提出，也是 SIFT 描述符的拓展。GLOH 与 SIFT
描述符非常相似，它只将 SIFT
使用的笛卡尔位置网格替换为对数-极坐标网格，并应用 PCA
来减小描述符的大小。GLOH
使用对数-极坐标位置网格将径向分为三个（半径设置为
6，11，15），角度方向分为 8 个，如 <strong><em>Fig.9</em></strong>
所示最后有 17 个子块。GLOH 描述符将梯度方向分为 16
个条目并以此建立了一组直方图，所以每个兴趣点的特征向量有 <span
class="math inline">\(17\times 16 = 272\)</span> 个元素。通过计算 PCA
协方差矩阵将这个 272 维描述符降为 128 维，并选择最高的 128
维特征用于描述。基于在【50】中的实验评估，<u>GLOH 优于原始 SIFT
描述符，并给出了最佳的性能，尤其是在光照改变的情况下。此外，和 SIFT
描述符相比，GLOH
获取的特征更具有区分度，但也需要更昂贵的计算开销</u>。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201126112550328.png" alt="image-20201126112550328" style="zoom:67%;" /></p>
<h3 id="加速鲁棒特征描述符surf">4.3 加速鲁棒特征描述符（SURF）</h3>
<p>加速鲁棒特征（Speeded-Up Robust Features，SURF）检测-描述符由 Bay
等人发展【32】以作为 SIFT 的有效替代。与SIFT
相比它更加快且更具鲁棒性。对于兴趣点检测阶段，并不依赖理想高斯微分，而是基于简单的
2D 核滤波器。其中，它使用基于 Hessian
矩阵行列式的尺度不变斑点检测器来进行尺度选择和定位。<u>它基础的思想为用一个高效的方式来近似高斯二阶微分，通过一组盒滤波器创建的积分图像</u>。<strong><em>Fig.10</em></strong>
描绘了这个 <span class="math inline">\(9\times 9\)</span>
的盒滤波器，它是 <span class="math inline">\(\sigma = 1.2\)</span>
的高斯函数的近似，并且代表了斑点响应映射的最低尺度。这些近似表示为 <span
class="math inline">\(D_{xx},D_{yy},D_{xy}\)</span>。因此，Hessian
行列式的近似表示为： <span class="math display">\[
\text{det}(H_{approx}) = D_{xx}D_{yy} - (wD_{xy})^2
\]</span> 其中 <span class="math inline">\(w\)</span>
是滤波器响应的相对权重，用于平衡 Hessian 行列式表达式。近似的 Hessian
行列式表示了图像中的斑点响应大小。这些响应存储在斑点响应映射图中，使用二次插值寻找并细化局部最大值，如
DoG。最后，在 <span class="math inline">\(3\times 3\times 3\)</span>
的邻域内做非极大值抑制来获取稳定的兴趣点和尺度值。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201127130822757.png" alt="image-20201127130822757" style="zoom:67%;" /></p>
<p>SURF
描述符首先以检测到的兴趣点为中心建立一个方形区域，并确定其主方向。这个窗口的大小为
<span class="math inline">\(20s\)</span>，其中 s
为其兴趣点对应的尺度。然后，这个兴趣区域进一步分为 <span
class="math inline">\(4\times 4\)</span>
个更小的子区域并为每一个子区域在如图 <strong><em>Fig.11</em></strong>
<span class="math inline">\(5\times 5\)</span>
大小的采样点上计算竖直和水平（分别表示为 <span
class="math inline">\(d_x,d_y\)</span> ）两个方向上的 Harr
小波响应。这些响应使用以兴趣点为中心的高斯窗口加权以增加对几何畸变和位置错误的鲁棒性。对每一个子区域小波响应
<span class="math inline">\(d_x,d_y\)</span> 求和并添加到特征向量 <span
class="math inline">\(v\)</span> ，其中 <span class="math display">\[
v = (\sum d_x,\sum \vert d_x\vert,\sum d_y,\sum \vert d_y \vert)
\]</span> 为所有 <span class="math inline">\(4\times 4\)</span>
的子区域计算这个，就得到一个 <span class="math inline">\(4\times 4\times
4 = 64\)</span>
维的特征描述符。最后，对这个特征描述符归一化以减少光照影响。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201127131158056.png" alt="image-20201127131158056" style="zoom:60%;" /></p>
<p>和 SIFT 相比 SURF 描述符主要的优势在于处理速度，因为它使用 64
维特征向量来描述局部特征，而 SIFT 使用的是 128 维。然而，<u>SIFT
描述符更适于描述受平移，选择，缩放和其它光照变化影响的图像</u>。尽管
SURF 展示了它在很多计算机视觉应用上的潜力，但它也有许多缺陷。<u>在比较
2D 和 3D
目标时，当旋转幅度大或视角差距大时它将失效。此外，如【56】解释的那样，SURF
并不是完全仿射不变的</u>。</p>
<h3 id="local-binary-pattern-lbp">4.4 Local Binary Pattern (LBP)</h3>
<p>LBP
【57，58】表征了纹理的空间结构并展示了灰度单一变换的不变性特点。它通过将相邻像素和中心像素比较以编码排序关系，也就是说通过将每一个像素值和其相邻像素比较以创建一个基于顺序的特征。特别地，将那些比中心像素具有更大特征响应的相邻像素标记为
“1”，否则标记为
“0”。这些同时进行的比较的结果由一个二进制串记录。然后，从公共比率为 2
的几何序列得到的权重，根据串的索引分配给每一个比特。因此，带有权值的二进制串就可以转换为一个十进制值索引（即，LBP
特征响应）。也就是说，这个描述符将邻域上的结果描述了为一个二进制数（二元模式）。其标准模式下，强度为
<span class="math inline">\(g(c)\)</span> 的像素 <span
class="math inline">\(c\)</span> 的标记按下式确定 <span
class="math display">\[
S(g_p - g_c) =
\left \{
\begin{align}
1,&amp; &amp;\text{if　} g_p \ge g_c \\
0,&amp; &amp;\text{if　} g_p &lt; g_c
\end{align}
\right.
\]</span> 其中像素 <span class="math inline">\(p\)</span> 属于 <span
class="math inline">\(3\times 3\)</span> 大小的邻域，灰度为 <span
class="math inline">\(g_p(p=0,1,\dots,7)\)</span> 。然后，像素邻域的 LBP
通过对阈值 <span class="math inline">\(S(g_p-g_c)\)</span> 按 <span
class="math inline">\(2^k\)</span> 加权相加获得，如下： <span
class="math display">\[
LBP = \sum_{k=0}^7 S(g_p-g_c).2^k
\]</span> 在为每一个像素计算其标记之后，就可以生成一个 256 bin
的直方图，作为这个纹理的特征描述符。<strong><em>Fig.12</em></strong>
展示了在 <span class="math inline">\(3\times 3\)</span> 邻域内计算 LBP
以及基础区域的方向描述符的例子。此外，LBP 描述符的一般形式为：</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201128003446585.png" alt="image-20201128003446585" style="zoom:55%;" /></p>
<p>其中 <span class="math inline">\(n_c\)</span>
对应着局部邻域中心像素的灰度级，<span class="math inline">\(n_i\)</span>
是半径为 R 的圆上的 N 等分像素的灰度级。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201128003803784.png" alt="image-20201128003803784" style="zoom:60%;" /></p>
<p>因为像素之间的关系随距离增加而减少，所以许多的纹理信息可以从局部邻域中获得。因此，半径
R 一般都比较小。在实际应用中，邻域间的差分符号被解释为 N
位二进制数，使得有如 <strong><em>Fig.13</em></strong> 所示的 <span
class="math inline">\(2^N\)</span>
个不同的二元模式。二元模式被称为均匀模式，其中每位最多包含两个从 “0” 到
“1” 的转换。例如，“11000011” 和 “00001110” 是两个二元模式，但 “00100100”
和 “01001110” 就不是二元模式。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201129111111162.png" alt="image-20201129111111162" style="zoom:60%;" /></p>
<p>已经提出了几种不同的 LBP，包括中心对称 LBP（the center-symmetric
local binary patterns，CS-LBP），局部三元模式（the local ternary
pattern，LTP），基于 CS-LBP 的中心对称 LTP（CS-LTP），以及正交对称
LTP（orthogonal symmetric local ternary pattern，OS-LTP）【60】。不像
LBP，CS-LBP 描述符比较中心对称对之间的灰度差分（见 Fig.13）。实际上，LBP
有容忍光照改变和计算简单的优势。不幸的是，LBP
特征是离散模式的索引而不是数值特征，因此它很难与其它区分度高的特征结合在一个紧凑的描述符中【61】。此外，它产生更高维的特征并对平坦区域的高斯噪声敏感。</p>
<h3 id="binary-robust-independent-elementary-features-brief">4.5 Binary
Robust Independent Elementary Features (BRIEF)</h3>
<p>BRIEF
是一个低比特率描述符，用于随机森林和随机蕨类分类器的图像匹配【62】。它属于
LBP 和 BRISK
那样的二元描述族，它仅执行简单的二元比较测试和使用汉明距离<a
href="#fn17" class="footnote-ref" id="fnref17"
role="doc-noteref"><sup>17</sup></a>而不是欧几里得距离或者马氏距离。简单来说，为了建立二元描述符，有必要的仅仅是比较被检测兴趣点周围的两个像素的强度。这使得以一个非常小的计算开销便可以获得具有代表形的描述符。此外，二元描述符匹配仅需要计算汉明距离，而汉明距离通过现代架构的
XOR 原语实现快速计算。</p>
<p>BRIEF
算法依赖于相对小的图像强度差分测试来将图像块表示为二进制串。更特别的是，对大小为
<span class="math inline">\(S \times S\)</span>
的图像块的二元描述符通过连接以下测试结果获得： <span
class="math display">\[
\tau =
\left\{
\begin{align}
1,&amp; &amp;\text{if　} I(P_j) &gt; I(P_i) \\
0,&amp; &amp;\text{otherwise}
\end{align}
\right.
\]</span> 其中 <span class="math inline">\(I(p_i)\)</span> 表示为 <span
class="math inline">\(p_i\)</span> 处的（平滑）像素强度，并且所有 <span
class="math inline">\(p_i\)</span>
位置的选择唯一定义了一组二进制测试。采样点来自于均值为 0 ，方差为 <span
class="math inline">\(\frac{1}{25} S^2\)</span>
的各向同性的高斯分布。为了增加这个描述子的鲁棒性，图像块使用方差为
2，大小为 <span class="math inline">\(9\times 9\)</span>
的高斯核进行预平滑。BRIEF
描述符需要设置两个参数：二元像素对数量和二进制阈值。</p>
<p>作者的实验显示了仅仅 256 位，甚至 128
位便足以获取十分好的匹配结果。因此，BRIEF
在计算以及内存存储方面都是高效的。不幸的是 BRIEF 描述符对大于 35°
的旋转不具鲁棒性，因此，它并不提供旋转不变性。</p>
<h3 id="其它特征描述符">4.6 其它特征描述符</h3>
<p>大量的描述符在文献中提出，并且之中的许多已经被证明在计算机视觉应用中是有效的。举个例子，基于颜色的局部特征是由
Weijer 和 Schmidt 【63】提出的基于颜色信息的四个颜色描述符。Gabor
表示或者其变化【64，65】在某种意义上是最优的，在最小化空间和频率的二维联合不确定性上。Zernike
矩【66，67】和 Steerable 滤波器【68】也用于特征提取和描述。</p>
<p>受到 Weber’s Law
的启发，根据局部强度变化和中心像素强度值为每个像素计算一个密集的描述符，这个方法为在【28】中提出的
Weber Local Descriptor（WLD）。WLD 描述符采用了 SIFT
使用梯度和其方向直方图的优势，以及 LBP
的计算效率和较小支持区域的优势。和 LBP 描述符相比，WLD
首先计算显著微模式（即，差分激励），然后在这些显著模式以及当前点的梯度方向上建立统计数据。</p>
<p>两种基于测量图像可视实体相似度从兴趣区域提取特征的方法在【69】中提出。这些方法的思路为将两个著名的方法结合起来，即
SIFT 描述符和 Local
Self-Similarities（LSS）。基于笛卡尔位置网格提取了两个名为 Local
Self-Similarities（LSS，C）和 Fast Local
Self-Similarities（FLSS，C）的特征，这两个特征是基于对数-极坐标位置网格（LSS，LP）的
Local Self-Similarities 的改进版本。LSS 和 FLSS 作为局部特征应用于 SIFT
算法。LSS和FLSS描述符在每个单元中使用基于分布的直方图表示而不是而不是在自然（LSS，LP）描述符中的对数-极坐标位置网格中选择每个桶中的最大相关值。因此，它们得到更具鲁棒性的几何变换不变性和好的光度变换不变性。一个基于二阶梯度直方图的局部图像描述符在【70】中提出，名为
HSOG，用于捕捉神经邻域的曲率相关几何特性。Dalal 和
Triggs【71】展示了梯度方向直方图（HOG）描述符，结合了 SIFT 的性质以及
GLOH 描述符。HOG 和 SIFT 的主要差别为
HOG描述符是在具有重叠局部对比归一化的均匀间隔单元的密集网格上计算的。</p>
<p>Fan
等人在另一个方向提出了一种兴趣区域描述方法，这种方法在多个可使用区域中基于强度顺序汇聚局部特征。通过强度顺序汇聚不仅对选择和单调强度改变不变，而且将序数信息编码为描述符。通过汇聚两种不同的局部特征，可以得到一种基于梯度，一种基于强度的描述符，即
Multisupport Region Order-Based Gradient Histogram (MROGH) 和 the
Multisupport Region Rotation and Intensity Monotonic Invariant
Descriptor
(MRRID)。前一种结合了强度顺序信息和梯度，然而后一种完全基于强度顺序，这使得它对大的光照改变部分不变。</p>
<p>尽管最近提出了大量的图像特征描述符，其中的几个是专门为某些场景应用设计的，如目标识别，形状检索或者
LADAR
数据处理【73】。此外，这些描述符的作者在为某些特别任务收集的有限数量基准数据集上评估描述符性能。因此，为特别的应用邻域选择一个合适的描述符是困难的。在这方面，最近一些研究对几种描述符做了比较：兴趣区域描述符【50】，二进制描述符【74】，局部颜色描述符【75】，和
3D
描述符【76，77】。事实上，声称描述图像特征是一个已经被解决的问题是过于大胆和乐观的。另一方面，鉴于上述描述符在几种应用程序中的成功，声称为一般现实情况设计描述符几乎是不可能的说法太过悲观了。最后，为了将描述符算法设计为可以通用还有大量的工作要做。我们主张进一步研究如何使用由三维数据和颜色信息捕获的新模式。对于实时应用，未来研究的进一步是在如
GPU 的并行处理单元上实现算法。</p>
<h2 id="特征匹配">5 特征匹配</h2>
<p>特征匹配或者一般而言的图像匹配，作为很多计算机视觉应用的一部分，如图像配准，相机标定和目标识别，建立同一场景/目标的两幅图像之间的对应关系。一种常见的图像匹配方法包括从图像数据中检测一组与图像描述符相联系的兴趣点。一旦特征和它的描述符从两幅或多幅图像中提取出来，下一步便是如
<strong><em>Fig.14</em></strong>
那样在这些图像之间建立基础的特征匹配。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202112550367.png" alt="image-20201202112550367" style="zoom:67%;" /></p>
<p>为了不失一般性，图像匹配的问题可以表述如下，假设 <span
class="math inline">\(p\)</span>
是由检测器检测到的点与一个描述符相联系<a href="#fn18"
class="footnote-ref" id="fnref18"
role="doc-noteref"><sup>18</sup></a></p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202000243428.png" alt="image-20201202000243428" style="zoom:60%;" /></p>
<p>其中，对于所有的 <span class="math inline">\(K\)</span>，第 <span
class="math inline">\(k\)</span> 个描述符的特征向量为：</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202000306500.png" alt="image-20201202000306500" style="zoom:60%;" /></p>
<p>兴趣点 <span class="math inline">\((p,q)\)</span> 匹配仅当 <span
class="math inline">\((\text{i})\)</span> <span
class="math inline">\(p\)</span> 为 <span
class="math inline">\(q\)</span>
与第一幅图像中所有点的最佳匹配并且反过来 <span
class="math inline">\((\text{ii})\)</span> <span
class="math inline">\(q\)</span> 是 <span
class="math inline">\(p\)</span>
与第二幅图像所有点的最佳匹配。在这个条件下，设计一个高效算法来尽可能快的执行匹配是非常重要的。欧氏范数中图像描述符特征空间中的最近邻匹配可用于基于向量的特征匹配。然而，实际上最优最近邻匹配算法及其参数依赖于数据集的特征。此外，为了抑制那些被认为模棱两可的一致关系的候选匹配，图像描述符之间的最近距离和次近距离之间的比值需要小于一个阈值。特别的是，在高维特征匹配中，这两个算法是最高效的：随机
K-d 森林和 the fast library for approximate nearest neighbors
(FLANN)【78】。</p>
<p>在另一方面，这些算法并不适用与二进制特征（例如，FREAK 或者
BRISK）。二进制特征匹配使用的是汉明距离，通过 按位 XOR
操作计算，并对结果进行位计数。这里涉及到的操作都可以很快的执行。匹配大型数据库的经典方案为使用比线性搜索快几个数量级的近似匹配来提到原先的线性搜索。也就是说，以返回最近邻的近似点作为代价，但是经常与真实的最近邻点十分相近。为了执行二进制特征匹配，需要使用其它的方法如【80-82】。</p>
<p>一般地，基于兴趣点的匹配方法的性能依赖于潜在兴趣点的性质以及与之相联系的图像描述符【83】。因此，适合图像内容的检测器和描述符应该被用于应用中。举个例子，如果一副包含细菌细胞的图像，那么就需要斑点检测器而不是角点检测器，但对于城市的鸟瞰图，角点检测器更适于人造结构。此外，选择一个可以解决图像退化问题的检测器和描述符是十分重要的。例如，如果没有尺度改变，则不处理尺度变换的检测器更受推崇；反之，如果一副包含很大变形，例如尺度和旋转，那么具有更高计算力的
SURF
特征检测器和描述符更适用于这个情况。至于更高的准确度，建议同时使用几种检测器和描述符。在特征匹配邻域，必须注意到二进制描述符（例如，FREAK
或
BRISK）一般具有更快的速度且一般用于寻找图像间点的一致性关系，但是它们和基于向量的描述符相比准确度更低【74】。数据分析显示，类似
RANSAC
的鲁棒性方法可以用于在估计几何变换或者基础矩阵时，筛选匹配特征中的外点，这对图像配置和目标识别应用中的特征匹配十分有用。</p>
<h2 id="性能评估">6 性能评估</h2>
<h3 id="基准数据集">6.1 基准数据集</h3>
<p>在互联网上有多种多样的数据集可以作为研究者的基准。一个流行并广泛用于检测器和描述符性能评估的为标准
Oxford
数据集【84】。这个数据集包含了不同几何和光度变换（视角改变，尺度改变，图像旋转，图像模糊，光照变换以及
JPEG
压缩）以及不同场景类型的（结构和纹理场景）数据集。在光照改变的情况下，通过改变相机孔径来改变光照。然而对于旋转，尺度改变，视角改变和模糊，有两种不同的场景类型。一种为结构场景，包含独特边缘边界的同类区域（例如涂鸦，建筑）。另一种则包含不同形式的重复纹理。因此，图像变换和场景类型造成的影响可以单独分析。每一个数据集包含
6 个几何和光度变形图像，其中第一张图像和其余 5
张相比是渐变的。<strong><em>Fig.15</em></strong> 为从 Oxford
数据集中抽取的几张图像。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202224948702.png" alt="image-20201202224948702" style="zoom:67%;" /></p>
<h3 id="评估标准">6.2 评估标准</h3>
<p>为了判断两张图像特征是否匹配（即，属于是否属于同一特征），Mikolajczyk
等人【44】提出基于重复率标准的评估方法，通过比较检测到的区域和真实区域之间的重叠大小。重复率可以被认为是最重要的评估标准，在评估特征检测器的稳定性上。它测量探测器在图像中提取相同特征点的能力，而不考虑成像条件。重复率标准表示了检测器某个检测器对于某一场景是否足够好。在这个评估方法中，两个兴趣区域
A 和 B 是一致的，当重叠错误率 <span
class="math inline">\(\epsilon\)</span> 足够小时，如
<strong>Fig.16</strong> 所示。这个重复错误率表示了在一个单应性变换 H
下两个区域一致性的好坏。它由两个区域的交集和并集的比率定义：</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202230218642.png" alt="image-20201202230218642" style="zoom:67%;" /></p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202225919982.png" alt="image-20201202225919982" style="zoom:67%;" /></p>
<p>这个方法计算了两个区域的并集和交集的全部像素数量。此外，一个匹配是正确的，当图像上两个对应区域的错误率小于
区域并的 50%，也就是 <span class="math inline">\(\epsilon &lt;
0.5\)</span> 。重叠错误率的计算是基于 H
的，这个单应性变换矩阵是由区域定义的。因此，为了评估特征检测器的性能，对给定一对图像的重复率分数计算为区域与区域的对应数量和这对图像中较少的区域数量的比值。</p>
<p>另一方面，区域描述符的性能由匹配标准度量，即，描述符表示一个场景区域的好坏。这是基于由图像对得到的正确和错误匹配的数量决定的。这通过比较真实的对应区域数量和正确匹配的区域数量计算。匹配为描述符空间中最邻近的【50】。在这个情况下，两个兴趣区域成匹配对，如果它们描述符
<span class="math inline">\(D_A,D_B\)</span>
之间的欧几里得距离小于一个阈值 <span class="math inline">\(\tau\)</span>
。最后的结果使用召回率（recall）和 1-准确度（1-precision）
表示。每一个参考图像的描述符与变换之后的描述符相比较并计算正确和错误匹配的数量。</p>
<p><img src="\assets\Note\Image Features Detection Description and Matching.assets\image-20201202232054828.png" alt="image-20201202232054828" style="zoom:60%;" /></p>
<p>其中，No.correspondences
为两幅图像的匹配区域的数量。然而，召回率是同一场景的两幅图像之间正确匹配的区域数量对于一致区域数量。一个理想描述符的对任意准确率其召回率为
1。为了获取其曲线，需要改变阈值 <span
class="math inline">\(\tau\)</span>。特别地，召回率随着阈值的增长而增长，因为图像变换引入的噪声和区域检测器中相似描述符间距离的增加。一个慢增长曲线表明描述符会受到图像噪声的影响。如果不同描述符的曲线的斜率差异很大，然后，对于所研究的图像变换或场景类型，这些描述符的显著性和鲁棒性是不同的【50】。</p>
<h2 id="总结">7 总结</h2>
<p>这篇文章的目标是为新研究者在图像特征检测和提取研究领域提供一简洁明了的，简短的介绍。介绍了检测和提取图像特征的基本符号和数学概念，描述了完美特征检测器的特性。之前介绍了各种现存的检测兴趣点的算法。也讨论了使用最频繁的描述算法
SIFT，SURF，LBP，WLD，……并且它们的优缺点也着重强调了。此外，它解释了一些特征匹配方法。最后，文章还介绍了它们算法中用于评估性能的技术。</p>
<hr />
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><p>Yap, T., Jiang, X., Kot, A.C.: Two-dimensional polar harmonic
transforms for invariant image representation. IEEE Trans. Pattern Anal.
Mach. Intell. 32(7), 1259–1270 (2010)</p></li>
<li><p>Liu, S., Bai, X.: Discriminative features for image
classification and retrieval. Pattern Recogn. Lett. 33(6), 744–751
(2012)</p></li>
<li><p>Rahmani, R., Goldman, S., Zhang, H., Cholleti, S., Fritts, J.:
Localized content-based image retrieval. IEEE Trans. Pattern Anal. Mach.
Intell. 30(11), 1902–1912 (2008)</p></li>
<li><p>Stöttinger, J., Hanbury, A., Sebe, N., Gevers, T.: Sparse color
interest points for image retrieval and object categorization. IEEE
Trans. Image Process. 21(5), 2681–2691 (2012)</p></li>
<li><p>Wang, J., Li, Y., Zhang, Y., Wang, C., Xie, H., Chen, G., Gao,
X.: Bag-of-features based medical image retrieval via multiple
assignment and visual words weighting. IEEE Trans. Med. Imaging 30(11),
1996–2011 (2011)</p></li>
<li><p>Andreopoulos, A., Tsotsos, J.: 50 years of object recognition:
directions forward. Comput. Vis. Image Underst. 117(8), 827–891
(2013)</p></li>
<li><p>Dollár, P., Wojek, C., Schiele, B., Perona, P.: Pedestrian
detection: an evaluation of the state of the art. IEEE Trans. Pattern
Anal. Mach. Intell. 34(4), 743–761 (2012)</p></li>
<li><p>Felsberg, M., Larsson, F., Wiklund, J., Wadströmer, N., Ahlberg,
J.: Online learning of correspondences between images. IEEE Trans.
Pattern Anal. Mach. Intell. 35(1), 118–129 (2013)</p></li>
<li><p>Miksik, O., Mikolajczyk, K.: Evaluation of local detectors and
descriptors for fast feature matching. In: International Conference on
Pattern Recognition (ICPR 2012), pp. 2681–2684. Tsukuba, Japan, 11–15
Nov 2012</p></li>
<li><p>Kim, B., Yoo, H., Sohn, K.: Exact order based feature descriptor
for illumination robust image matching. Pattern Recogn. 46(12),
3268–3278 (2013)</p></li>
<li><p>Moreels, P., Perona, P.: Evaluation of features detectors and
descriptors based on 3D objects. Int. J. Comput. Vis. 73(3), 263–284
(2007)</p></li>
<li><p>Takacs, G., Chandrasekhar, V., Tsai, S., Chen, D., Grzeszczuk,
R., Girod, B.: Rotation-invariant fast features for large-scale
recognition and real-time tracking. Sign. Process. Image Commun. 28(4),
334–344 (2013)</p></li>
<li><p>Tang, S., Andriluka, M., Schiele, B.: Detection and tracking of
occluded people. Int. J. Comput. Vis. 110(1), 58–69 (2014)</p></li>
<li><p>Rincón, J.M., Makris, D., Uru ˇnuela, C., Nebel, J.C.: Tracking
human position and lower body parts using Kalman and particle filters
constrained by human biomechanics. IEEE Trans. Syst. Man Cybern. Part B
41(1), 26–37 (2011)</p></li>
<li><p>Lazebnik, S., Schmid, C., Ponce, J.: A sparse texture
representation using local affine regions. IEEE Trans. Pattern Anal.
Mach. Intell. 27(8), 1265–1278 (2005)</p></li>
<li><p>Liu, L., Fieguth, P.: Texture classification from random
features. IEEE Trans. Pattern Anal. Mach. Intell. 34(3), 574–586
(2012)</p></li>
<li><p>Murillo, A., Guerrero, J., Sagues, C.: SURF features for
efficient robot localization with omnidirectional images. In:
International Conference on Robotics and Automation, pp. 3901–3907.
Rome, Italy, 10–14 Apr, 2007</p></li>
<li><p>Valgren, C., Lilienthal, A.J.: SIFT, SURF &amp; seasons:
appearance-based long-term localization in outdoor environments. Rob.
Auton. Syst. 58(2), 149–156 (2010)</p></li>
<li><p>Campos, F.M., Correia, L., Calado, J.M.F.: Robot visual
localization through local feature fusion: an evaluation of multiple
classifiers combination approaches. J. Intell. Rob. Syst. 77(2), 377–390
(2015)</p></li>
<li><p>Farajzadeh, N., Faez, K., Pan, G.: Study on the performance of
moments as invariant descriptors for practical face recognition systems.
IET Comput. Vis. 4(4), 272–285 (2010)</p></li>
<li><p>Mian, A., Bennamoun, M., Owens, R.: Keypoint detection and local
feature matching for textured 3D face recognition. Int. J. Comput. Vis.
79(1), 1–12 (2008)</p></li>
<li><p>Jain, A.K., Ross, A.A., Nandakumar, K.: Introduction to
Biometrics, 1st edn. Springer (2011)</p></li>
<li><p>Burghardt, T., Damen, D., Mayol-Cuevas, W., Mirmehdi, M.:
Correspondence, matching and recognition. Int. J. Comput. Vis. 113(3),
161–162 (2015)</p></li>
<li><p>Bouchiha, R., Besbes, K.: Comparison of local descriptors for
automatic remote sensing image registration. SIViP 9(2), 463–469
(2015)</p></li>
<li><p>Zhao, Q., Feng, W., Wan, L., Zhang, J.: SPHORB: a fast and robust
binary feature on the sphere. Int. J. Comput. Vis. 113(2), 143–159
(2015)</p></li>
<li><p>Zhang, S., Tian, Q., Huang, Q., Gao, W., Rui, Y.: USB: ultrashort
binary descriptor for fast visual matching and retrieval. IEEE Trans.
Image Process. 23(8), 3671–3683 (2014)</p></li>
<li><p>Tuytelaars, T., Mikolajczyk, K.: Local invariant feature
detectors: a survey. Found. Trends Comput. Graph. Vis. 3(3), 177–280
(2007)</p></li>
<li><p>Chen, J., Shan, S., He, C., Zhao, G., Pietikäinen, M., Chen, X.,
Gao, W.: WLD: a robust local image descriptor. IEEE Trans. Pattern Anal.
Mach. Intell. 32(9), 1705–1720 (2010)</p></li>
<li><p>Viola, P., Jones, M.J.: Robust real-time face detection. Int. J.
Comput. Vis. 57(2), 137–154 (2004)</p></li>
<li><p>Janan, F., Brady, M.: Shape description and matching using
integral invariants on eccentricity transformed images. Int. J. Comput.
Vis. 113(2), 92–112 (2015)</p></li>
<li><p>Lowe, D.G.: Distinctive image features from scale-invariant
keypoints. Int. J. Comput. Vis. 60(2), 91–110 (2004)</p></li>
<li><p>Bay, H., Ess, A., Tuytelaars, T., Gool, L.: Speeded-up robust
features (SURF). Comput. Vis. Image Underst. 110(3), 346–359
(2008)</p></li>
<li><p>Oliva, A., Torralba, A.: Modeling the shape of the scene: a
holistic representation of the spatial envelope. Int. J. Comput. Vis.
42(3), 145–175 (2001)</p></li>
<li><p>Bianco, S., Mazzini, D., Pau, D., Schettini, R.: Local detectors
and compact descriptors for visual search: a quantitative comparison.
Digital Signal Process. 44, 1–13 (2015)</p></li>
<li><p>Jégou, H., Perronnin, F., Douze, M., Sánchez, J., Pérez, P.,
Schmid, C.: Aggregating local descriptors into a compact codes. IEEE
Trans. Pattern Anal. Mach. Intell. 34(9), 1704–1716 (2012)</p></li>
<li><p>Lindeberg, T.: Feature detection with automatic scale selection.
Int. J. Comput. Vis. 30(2), 79–116 (1998)</p></li>
<li><p>Moravec, H.P.: Towards automatic visual obstacle avoidance. In:
5th International Joint Conference on Artificial Intelligence, pp.
584–594 (1977)</p></li>
<li><p>Harris, C., Stephens, M.: A combined corner and edge detector.
In: The Fourth Alvey Vision Conference, pp. 147–151. Manchester, UK
(1988)</p></li>
<li><p>Smith, S.M., Brady, J.M.: A new approach to low level image
processing. Int. J. Comput. Vis. 23(1), 45–78 (1997)</p></li>
<li><p>Rosten, E., Drummond, T.: Fusing points and lines for high
performance tracking. In: International Conference on Computer Vision
(ICCV’05), pp. 1508–1515. Beijing, China, 17–21 Oct 2005</p></li>
<li><p>Rosten, E., Drummond, T.: Machine learning for high speed corner
detection. In: 9th European Conference on Computer Vision (ECCV’06), pp.
430–443. Graz, Austria, 7–13 May 2006</p></li>
<li><p>Beaudet, P.R.: Rotationally invariant image operators. In:
International Joint Conference on Pattern Recognition, pp. 579–583
(1978)</p></li>
<li><p>Lakemond, R., Sridharan, S., Fookes, C.: Hessian-based affine
adaptation of salient local image features. J. Math. Imaging Vis. 44(2),
150–167 (2012)</p></li>
<li><p>Mikolajczyk, K., Tuytelaars, T., Schmid, C., Zisserman, A.,
Matas, J., Schaffalitzky, F., Kadir, T., Gool, L.: A comparison of
affine region detectors. Int. J. Comput. Vis. 65(1/2), 43–72
(2005)</p></li>
<li><p>Mikolajczyk, K., Schmid, C.: Scale &amp; affine invariant
interest point detectors. Int. J. Comput. Vis. 60(1), 63–86
(2004)</p></li>
<li><p>Lindeberg, T.: Scale selection properties of generalized
scale-space interest point detectors. J. Math. Imaging Vis. 46(2),
177–210 (2013)</p></li>
<li><p>Yussof, W., Hitam, M.: Invariant Gabor-based interest points
detector under geometric transformation. Digital Signal Process. 25,
190–197 (2014)</p></li>
<li><p>Schaffalitzky, F., Zisserman, A.: Multi-view matching for
unordered image sets. In: European Conference on Computer Vision (ECCV),
pp. 414–431. Copenhagen, Denmark, 28–31 May 2002</p></li>
<li><p>Lindeberg, T., Gårding, J.: Shape-adapted smoothing in estimation
of 3-D shape cues from affine deformations of local 2-D brightness
structure. Image Vis. Comput. 15(6), 415–434 (1997)</p></li>
<li><p>Mikolajczyk, K., Schmid, C.: A performance evaluation of local
descriptors. IEEE Trans. Pattern Anal. Mach. Intell. 27(10), 1615–1630
(2005)</p></li>
<li><p>Matas, J., Chum, O., Urban, M., Pajdla, T.: Robust wide baseline
stereo from maximally stable extremal regions. In. In British Machine
Vision Conference (BMV), pp. 384–393 (2002)</p></li>
<li><p>Matas, J., Ondrej, C., Urban, M., Pajdla, T.: Robust
wide-baseline stereo from maximally stable extremal regions. Image Vis.
Comput. 22(10), 761–767 (2004)</p></li>
<li><p>Li, J., Allinson, N.: A comprehensive review of current local
features for computer vision. Neurocomputing 71(10–12), 1771–1787
(2008)</p></li>
<li><p>Ke, Y., Sukthankar, R.: PCA-SIFT: a more distinctive
representation for local image descriptors. In: IEEE Conference on
Computer Vision and Pattern Recognition (CVPR’04), pp. 506–513.
Washington, DC, USA, 27 June–2 July 2004</p></li>
<li><p>Morel, J., Yu, G.: ASIFT: a new framework for fully affine
invariant image comparison. SIAM J. Imaging Sci. 2(2), 438–469
(2009)</p></li>
<li><p>Pang, Y., Li, W., Yuan, Y., Pan, J.: Fully affine invariant SURF
for image matching. Neurocomputing 85, 6–10 (2012)</p></li>
<li><p>Ojala, T., Pietikäinen, M., Mäenpää, M.: Multiresolution
gray-scale and rotation invariant texture classification with local
binary patterns. IEEE Trans. Pattern Anal. Mach. Intell. 24(7), 971–987
(2002)</p></li>
<li><p>Heikkiläa, M., Pietikäinen, M., Schmid, C.: Description of
interest regions with local binary patterns. Pattern Recogn. 42(3),
425–436 (2009)</p></li>
<li><p>Tian, H., Fang, Y., Zhao, Y., Lin, W., Ni, R., Zhu, Z.: Salient
region detection by fusing bottomup and top-down features extracted from
a single image. IEEE Trans. Image Process. 23(10), 4389–4398
(2014)</p></li>
<li><p>Huang, M., Mu, Z., Zeng, H., Huang, S.: Local image region
description using orthogonal symmetric local ternary pattern. Pattern
Recogn. Lett. 54(1), 56–62 (2015)</p></li>
<li><p>Hong, X., Zhao, G., Pietikäinen, M., Chen, X.: Combining LBP
difference and feature correlation for texture description. IEEE Trans.
Image Process. 23(6), 2557–2568 (2014)</p></li>
<li><p>Calonder, M., Lepetit, V., Özuysal, M., Trzcinski, T., Strecha,
C., Fua, P.: BRIEF: computing a local binary descriptor very fast. IEEE
Trans. Pattern Anal. Mach. Intell. 34(7), 1281–1298 (2012)</p></li>
<li><p>Van De Weijer, J., Schmid, C.: Coloring local feature extraction.
In: European Conference on Computer Vision (ECCV), pp. 334–348. Graz,
Austria, 7–13 May 2006</p></li>
<li><p>Subrahmanyam, M., Gonde, A.B., Maheshwari, R.P.: Color and
texture features for image indexing and retrieval. In: IEEE
International Advance Computing Conference (IACC), pp.1411–1416.
Patiala, India, 6–7 Mar 2009</p></li>
<li><p>Zhang, Y., Tian, T., Tian, J., Gong, J., Ming, D.: A novel
biologically inspired local feature descriptor. Biol. Cybern. 108(3),
275–290 (2014)</p></li>
<li><p>Chen, Z., Sun, S.: A Zernike moment phase-based descriptor for
local image representation and matching. IEEE Trans. Image Process.
19(1), 205–219 (2010)</p></li>
<li><p>Chen, B., Shu, H., Zhang, H., Coatrieux, G., Luo, L., Coatrieux,
J.: Combined invariants to similarity transformation and to blur using
orthogonal Zernike moments. IEEE Trans. Image Process. 20(2), 345–360
(2011)</p></li>
<li><p>Freeman, W., Adelson, E.: The design and use of steerable
filters. IEEE Trans. Pattern Anal. Mach. Intell. 13(9), 891–906
(1991)</p></li>
<li><p>Liu, J., Zeng, G., Fan, J.: Fast local self-similarity for
describing interest regions. Pattern Recogn. Lett. 33(9), 1224–1235
(2012)</p></li>
<li><p>Huang, D., Chao, Z., Yunhong, W., Liming, C.: HSOG: a novel local
image descriptor based on histograms of the second-order gradients. IEEE
Trans. Image Process. 23(11), 4680–4695 (2014)</p></li>
<li><p>Dalal, N., Triggs, B.: Histograms of oriented gradients for human
detection. In: IEEE Conference on Computer Vision and Pattern
Recognition (CVPR’05), pp. 886–893. San Diego, CA, USA, 20–26 June
2005</p></li>
<li><p>Fan, B., Wu, F., Hu, Z.: Rotationally invariant descriptors using
intensity order pooling. IEEE Trans. Pattern Anal. Mach. Intell. 34(10),
2031–2045 (2012)</p></li>
<li><p>Al-Temeemy, A.A., Spencer, J.W.: Invariant chromatic descriptor
for LADAR data processing. Mach. Vis. Appl. 26(5), 649–660
(2015)</p></li>
<li><p>Figat, J., Kornuta, T., Kasprzak, W.: Performance evaluation of
binary descriptors of local features. Lect. Notes Comput. Sci. (LNCS)
8671, 187–194 (2014)</p></li>
<li><p>Burghouts, G., Geusebroek, J.M.: Performance evaluation of local
color invariantss. Comput. Vis. Image Underst. 113(1), 48–62
(2009)</p></li>
<li><p>Moreels, P., Perona, P.: Evaluation of features detectors and
descriptors based on 3D objects. Int. J. Comput. Vis. 73(2), 263–284
(2007)</p></li>
<li><p>Guo, Y., Bennamoun, M., Sohel, F., Lu, M., Wan, J., Kwok, N.M.: A
comprehensive performance evaluation of 3D local feature descriptors.
Int. J. Comput. Vis. First online, 1–24 (2015)</p></li>
<li><p>Muja, M., Lowe, D.G.: Scalable nearest neighbor algorithms for
high dimensional data. IEEE Trans. Pattern Anal. Mach. Intell. 36(11),
2227–2240 (2014)</p></li>
<li><p>Szeliski, R.: Computer Vision: Algorithms and Applications.
Springer, USA (2011)</p></li>
<li><p>Muja, M., David G. Lowe: Fast matching of binary features. In:
IEEE Conference on Computer Vision and Pattern Recognition (CVPR’12),
pp. 404–410. Toronto, ON, USA, 28–30 May 2012</p></li>
<li><p>Nister, D., Stewenius, H.: Scalable recognition with a vocabulary
tree. In: IEEE Conference on Computer Vision and Pattern Recognition
(CVPR’06), pp. 2161–2168. Washington, DC, USA, 17–22 June 2006</p></li>
<li><p>Yan, C.C., Xie, H., Zhang, B., Ma, Y., Dai, Q., Liu, Y.: Fast
approximate matching of binary codes with distinctive bits. Frontiers
Comput. Sci. 9(5), 741–750 (2015)</p></li>
<li><p>Lindeberg, T.: Image matching using generalized scale-space
interest points. J. Math. Imaging Vis. 52(1), 3–36 (2015)</p></li>
<li><p>The oxford data set is available at (last visit, Oct. 2015) <a
href="http://www.robots.ox.ac.uk/~vgg/data/affine/">http://www.robots.ox.ac.uk/~vgg/data/affine/</a></p></li>
</ol>
<hr />
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li
id="fn1"><p>研究在两个相机位置产生的两幅图像的之间存在的特殊几何关系<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn2"><p>即仿射不变性包含了尺度不变，仿射会改变不同方向的尺度，即不均匀地缩放，尺度不变是均匀地缩放<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn3"><p>四边形变为平行四边形的变换，仿射变换其实就是一个线性变换和一个平移<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn4"><p>这里使用8个方向作为改变依据，但旋转会改变这8个离散方向所代表的原有方向<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn5"><p>这里原文有点错误（或者他想表达的是卷积操作），可参考http://dept.me.umn.edu/courses/me5286/vision/Notes/2015/ME5286-Lecture8.pdf<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn6"><p>具有旋转不变性，部分光照变化不变性（兴趣点数量会发生改变），不具备尺度不变性，因为依然单尺度的<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>翻译为最小核值相似区或者最小同值分割吸收核<a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>参考 https://www.cnblogs.com/ronny/p/4078710.html<a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>也就是首先对一组测试图像使用完整的 FAST 算法，然后使用
ID3
得到16像素中亮，暗，相似像素数量和是否是角点的关系，之后就可以直接判断
16 像素中这三种像素的数量直接判断角点<a href="#fnref9"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>海森矩阵参考
https://blog.csdn.net/u013921430/article/details/79770458<a
href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>具有最大 LoG 响应的尺度<a href="#fnref11"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn12"><p>位置代表的是图像空间，尺度代表的是尺度空间，尺度为1维，图像为2维，组成3维<a
href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>可参考<a
href="https://www.cnblogs.com/ronny/p/4009425.html">Harris角点 -
☆Ronny丶 - 博客园 (cnblogs.com)</a><a href="#fnref13"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn14"><p>这里也就是说需要在尺度空间获得最大值，尺度不变性需要同时满足尺度空间
LoG 最大响应以及图像空间极值条件<a href="#fnref14" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>这个是真不懂 <a
href="https://www.cnblogs.com/wxl845235800/p/10711858.html">小波变换——哈尔小波，Haar
- ostartech - 博客园 (cnblogs.com)</a>，<a
href="https://blog.csdn.net/baidu_27643275/article/details/84826773">【小波变换】小波变换入门----haar小波-筱-CSDN博客-haar小波</a><a
href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>即值大于最大值 0.2 的值截断为最大值的 0.2<a
href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>两个字之间对应位不同的数量<a href="#fnref17"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>感觉这里是某一个点的一组描述符<a href="#fnref18"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>特征检测</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>图像的前向和后向映射</title>
    <url>/2021/02/16/2021-02-16-Forward-BackwardMapping/</url>
    <content><![CDATA[<p>图像变换中总是伴随着映射，原图中的点到新图中的点之间的映射。从原图映射到新图上，由于坐标的不连续，就有新图上某点的像素确定的问题。也就是像素坐标是整数，但是映射之后的坐标不一定是整数，就需要确定它周围的坐标的像素值。图像像素的映射有前向映射和后向映射。</p>
<p>后向映射比较好理解，新图映射到原图上某点，然后通过它周围的像素确定这个点的像素值，一般可以有最邻近，双线性，双三次插值等。双线性比较简单且好用。</p>
<p>前向映射到新图中的浮点数位置，直接取整会有空洞产生，一种合适的方法就是按双线性的思路，把这个点的像素按权值分配到四个周围整数点。直接这样累加会导致像素重叠，所以还需要最后对分配到某个像素的所有像素值及其对应权值归一化。</p>
<span id="more"></span>
<p>详细可参考：<a
href="https://blog.csdn.net/glorydream2015/article/details/44873703">图像变换——向前映射和向后映射_薇洛的打火机-CSDN博客</a></p>
<h2 id="代码实现">代码实现</h2>
<p>这里给出了完整的 matlab
代码实现，根据实验结果可以知道，这里的前向映射耗费的时间比后向大，计算过程比较复杂，但在某些场景下，前向仍然会比后向方便，所以在此记录：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">filename = <span class="string">&#x27;./test.JPG&#x27;</span>;</span><br><span class="line">img = double(imread(filename));</span><br><span class="line"><span class="comment">% 旋转的角度</span></span><br><span class="line">theta = <span class="number">0.67</span>*<span class="built_in">pi</span>;</span><br><span class="line"><span class="comment">% 绕原点旋转矩阵</span></span><br><span class="line">T1 = [<span class="built_in">cos</span>(theta) <span class="built_in">sin</span>(theta) <span class="number">0</span>;</span><br><span class="line">      -<span class="built_in">sin</span>(theta) <span class="built_in">cos</span>(theta) <span class="number">0</span>;</span><br><span class="line">      <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">imgsize = <span class="built_in">size</span>(img);</span><br><span class="line">w = imgsize(<span class="number">2</span>);</span><br><span class="line">h = imgsize(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% matlab 坐标从 1 开始有点烦</span></span><br><span class="line">bound = [<span class="number">1</span> <span class="number">1</span>+w <span class="number">1</span>+w <span class="number">1</span>;</span><br><span class="line">         <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>+h <span class="number">1</span>+h;</span><br><span class="line">         <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">%  获取变换后图片的大小和左上角顶点在原坐标系的坐标</span></span><br><span class="line">boundWarp = T1 * bound;</span><br><span class="line"><span class="comment">% 正无穷方向取整,避免越界,这里加1稳妥一点</span></span><br><span class="line">newW = <span class="built_in">ceil</span>(<span class="built_in">max</span>(boundWarp(<span class="number">1</span>,:)) - <span class="built_in">min</span>(boundWarp(<span class="number">1</span>,:))) + <span class="number">1</span>;</span><br><span class="line">newH = <span class="built_in">ceil</span>(<span class="built_in">max</span>(boundWarp(<span class="number">2</span>,:)) - <span class="built_in">min</span>(boundWarp(<span class="number">2</span>,:))) + <span class="number">1</span>;</span><br><span class="line">vex = [<span class="built_in">min</span>(boundWarp(<span class="number">1</span>,:)) <span class="built_in">min</span>(boundWarp(<span class="number">2</span>,:))];</span><br><span class="line"><span class="comment">% 平移到新图坐标系的矩阵为</span></span><br><span class="line">T2 = [<span class="number">1</span> <span class="number">0</span> -vex(<span class="number">1</span>)+<span class="number">1</span>;<span class="number">0</span> <span class="number">1</span> -vex(<span class="number">2</span>)+<span class="number">1</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% 最后的变换为</span></span><br><span class="line">T = T2*T1;</span><br><span class="line"><span class="comment">% 变换后的图片矩阵</span></span><br><span class="line">imgsize2 = imgsize;</span><br><span class="line">imgsize2([<span class="number">1</span> <span class="number">2</span>]) = [newH newW];</span><br><span class="line"><span class="comment">% 上面这样利于单通道/多通道的情况</span></span><br><span class="line">img2 = <span class="built_in">zeros</span>(imgsize2);</span><br><span class="line">img3 = img2;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 前向映射</span></span><br><span class="line">tic</span><br><span class="line"><span class="comment">% tempTrans(i,j) 为矩阵,存储分配到这个像素的原图像素值以及其权值</span></span><br><span class="line"><span class="comment">% 用于记录每一个点所分配的权重</span></span><br><span class="line">tempTrans = cell(imgsize2([<span class="number">1</span> <span class="number">2</span>]));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:imgsize(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:imgsize(<span class="number">2</span>)</span><br><span class="line">        coord = T*[<span class="built_in">j</span>;<span class="built_in">i</span>;<span class="number">1</span>];</span><br><span class="line">        x = coord(<span class="number">1</span>); y = coord(<span class="number">2</span>);</span><br><span class="line">        s = <span class="built_in">fix</span>(coord(<span class="number">1</span>)); t = <span class="built_in">fix</span>(coord(<span class="number">2</span>));</span><br><span class="line">        k = [s+<span class="number">1</span>-x x-s t+<span class="number">1</span>-y y-t];</span><br><span class="line">        p = img(<span class="built_in">i</span>,<span class="built_in">j</span>,:); p = p(:);</span><br><span class="line">        <span class="comment">% 双线性插值的方法分配</span></span><br><span class="line">        tempTrans&#123;t, s&#125;(:, <span class="keyword">end</span>+<span class="number">1</span>) = [p;k(<span class="number">1</span>)*k(<span class="number">3</span>)];</span><br><span class="line">        tempTrans&#123;t, s+<span class="number">1</span>&#125;(:, <span class="keyword">end</span>+<span class="number">1</span>) = [p;k(<span class="number">2</span>)*k(<span class="number">3</span>)];</span><br><span class="line">        tempTrans&#123;t+<span class="number">1</span>, s&#125;(:, <span class="keyword">end</span>+<span class="number">1</span>) = [p;k(<span class="number">1</span>)*k(<span class="number">4</span>)];</span><br><span class="line">        tempTrans&#123;t+<span class="number">1</span>, s+<span class="number">1</span>&#125;(:, <span class="keyword">end</span>+<span class="number">1</span>) = [p;k(<span class="number">2</span>)*k(<span class="number">4</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 归一化,否则会造成某些地方很突兀(叠加)</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:imgsize2(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:imgsize2(<span class="number">2</span>)</span><br><span class="line">        temp = tempTrans&#123;<span class="built_in">i</span>,<span class="built_in">j</span>&#125;;</span><br><span class="line">        len = <span class="built_in">size</span>(temp,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> len == <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">% 归一化数据,也就是重新分配权值</span></span><br><span class="line">        sum_w = sum(temp(<span class="keyword">end</span>,:));</span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">1</span>:len</span><br><span class="line">            img2(<span class="built_in">i</span>,<span class="built_in">j</span>,:) = img2(<span class="built_in">i</span>,<span class="built_in">j</span>,:) + <span class="built_in">reshape</span>(temp(<span class="keyword">end</span>, k)/sum_w * temp(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>,k), <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fprintf(<span class="string">&quot;前向映射耗费的总时间:&quot;</span>);</span><br><span class="line">toc</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">imshow(uint8(img2));</span><br><span class="line">title(<span class="string">&quot;Forward Mapping&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 后向映射</span></span><br><span class="line">tic</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:imgsize2(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:imgsize2(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% 逆映射回去,得到坐标</span></span><br><span class="line">        coord = T\[<span class="built_in">j</span>;<span class="built_in">i</span>;<span class="number">1</span>];</span><br><span class="line">        img3(<span class="built_in">i</span>, <span class="built_in">j</span>, :) = backward(img, coord);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fprintf(<span class="string">&quot;后向映射耗费的总时间:&quot;</span>);</span><br><span class="line">toc</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">imshow(uint8(img3));</span><br><span class="line">title(<span class="string">&quot;Backward Mapping&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 后向映射到原图,获取对应的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pixel_value</span> = <span class="title">backward</span><span class="params">(srcimg, srccoord)</span></span></span><br><span class="line">    x = srccoord(<span class="number">1</span>);</span><br><span class="line">    y = srccoord(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">% 不再原图上的点返回黑色</span></span><br><span class="line">    pixel_value = <span class="number">0</span>;</span><br><span class="line">    [r, c, ~] = <span class="built_in">size</span>(srcimg);</span><br><span class="line">    <span class="comment">% 坐标在图像外的返回 0 </span></span><br><span class="line">    <span class="keyword">if</span> x &gt; c || y &gt; r || x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 现在坐标已经在图像内部、或者边界，然后处理边界（图像右和下）避免插值时数组边界访问异常</span></span><br><span class="line">    <span class="keyword">if</span> x == c || y == r</span><br><span class="line">        pixel_value = srcimg(x, y, :);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 此时依据四个点做双线性插值 首先对坐标向零取整</span></span><br><span class="line">    s = <span class="built_in">fix</span>(srccoord(<span class="number">1</span>));</span><br><span class="line">    t = <span class="built_in">fix</span>(srccoord(<span class="number">2</span>));</span><br><span class="line">    k = [s+<span class="number">1</span>-x x-s t+<span class="number">1</span>-y y-t];</span><br><span class="line">    pixel_value = k(<span class="number">1</span>)*k(<span class="number">3</span>)*srcimg(t,s,:) + k(<span class="number">2</span>)*k(<span class="number">3</span>)*srcimg(t, s+<span class="number">1</span>,:) +  ...</span><br><span class="line">                  k(<span class="number">1</span>)*k(<span class="number">4</span>)*srcimg(t+<span class="number">1</span>,s,:) + k(<span class="number">2</span>)*k(<span class="number">4</span>)*srcimg(t+<span class="number">1</span>,s+<span class="number">1</span>,:);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>原图为：</p>
<p><img src="/assets/ArticleImg/2021/forward-backward-maping.jpg" /></p>
<p>实现结果如下：</p>
<p><img
src="/assets/ArticleImg/2021/forward-backward-maping2.jpg" /></p>
<p>代码输出：</p>
<p>前向映射耗费的总时间:历时 12.063921 秒。 后向映射耗费的总时间:历时
4.419853 秒。</p>
<h2 id="补存在的问题">【补】存在的问题</h2>
<p>这样子看起来效果比较好，但是当加入缩放因子时，前向映射仍然会产生空隙，因为这里双线性只将映射到浮点位置的像素分配到四个周围像素。但是，当缩放加入后，会有的像素映射不到，解决办法就是增加分配的核大小，由原来的
2*2 改为更大，但不能有一个通用的方法。所以，一般还是使用后向映射。</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>DIP</category>
      </categories>
      <tags>
        <tag>matltb</tag>
      </tags>
  </entry>
  <entry>
    <title>马氏距离与协方差矩阵</title>
    <url>/2021/11/09/2021-11-08-%E9%A9%AC%E6%B0%8F%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p>一些介绍马氏距离比较好的文章：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/46626607">马氏距离(Mahalanobis
Distance) - 知乎 (zhihu.com)</a></li>
<li><a
href="https://zhuanlan.zhihu.com/p/268416888">理解向量空间变化：马氏距离
- 知乎 (zhihu.com)</a></li>
<li><a
href="https://www.zhihu.com/question/35211238/answer/80138882">如何理解马氏距离，多维Mahalanobis距离是否要用到“互相关张量”来进行描述？
- 快使用双截棍巴拉的回答 - 知乎</a></li>
<li><a
href="https://blog.csdn.net/Kevin_cc98/article/details/73742037">欧式距离、标准化欧式距离、马氏距离、余弦距离_一只飞鱼的博客-CSDN博客_欧式距离</a></li>
</ul>
<p>这里主要做一个补充</p>
<span id="more"></span>
<hr />
<p><strong>欧氏距离</strong>：直接反映距离的一个度量，适用于独立同分布的数据</p>
<p>对于独立但不同分布的数据，一般对每一个维度数据做归一化处理以消除分布的影响，比如对
<span class="math inline">\(x_i\)</span> 做 <span
class="math inline">\(x_i = \frac{x_i - u_i}{\sigma_i}\)</span> ，其中
<span class="math inline">\(u_i,\sigma_i\)</span> 分别是数据 <span
class="math inline">\(x_i\)</span>
的均值和方差，这就可以将每一个维度的数据归一化为同分布。（假设各维度数据分布类型是一致的）这也称为
<strong>归一化欧氏距离</strong>（或标准化欧氏距离）</p>
<p>但它没有考虑不同维度间数据之间的关系，这就是马氏距离做的事情：先消除各维度之间的线性关系，使得各个维度独立，然后将每个维度数据归一化，最后计算欧式距离。</p>
<p><strong>马氏距离</strong> 表达式如下： <span class="math display">\[
\begin{align}
D_M &amp;= [(\pmb{x-u})^T\Sigma^{-1}(\pmb{x-u})]^{\frac{1}{2}} \\
D_M &amp;= [(\pmb{x-y})^T\Sigma^{-1}(\pmb{x-y})]^{\frac{1}{2}}
\end{align}
\]</span></p>
<p>其中 <span class="math inline">\(\pmb{u}\)</span> 为均值向量</p>
<hr />
<p><strong>协方差</strong> 反映的 数据集 <span class="math inline">\(X
\in R_{n\times m}\)</span> 表示数据有 <span
class="math inline">\(n\)</span> 个维度，<span
class="math inline">\(m\)</span> 个样本，可以表示如下： <span
class="math display">\[
\Sigma = \frac{1}{m-1}\Sigma_{j=1}^{m} (\pmb{x}_j -
\overline{\pmb{x}})(\pmb{x}_j - \overline{\pmb{x}})^T
\]</span> <span class="math inline">\(\pmb{x}_j\)</span> 为第 <span
class="math inline">\(i\)</span> 列，即第 <span
class="math inline">\(i\)</span> 个样本，具体推导见：<a
href="https://www.cnblogs.com/terencezhou/p/6235974.html">协方差与协方差矩阵
- 苦力笨笨 - 博客园 (cnblogs.com)</a></p>
<hr />
<p>前面提到马氏距离是先对各维度独立化，然后归一化（标准化），最后计算欧式距离</p>
<p>其中，独立化代表旋转，标准化代表缩放（消除量纲、尺度影响）。下面是对它为什么可以做到旋转缩放的理解：</p>
<p>协方差矩阵为 <strong>实对称矩阵</strong>，它必定可以对角化： <span
class="math display">\[
\Sigma = R S R^T
\]</span> 其中 <span class="math inline">\(R\)</span>
为正交阵（单位正交阵），正交阵的含义就是一个旋转操作而对角阵 <span
class="math inline">\(S\)</span> 代表了缩放操作，有： <span
class="math display">\[
\begin{align}
(RSR^T)^{-1} &amp;= R^{-T}S^{-1} R^{-1}\\
&amp;= R S^{-\frac{1}{2}} S^{-\frac{1}{2}}R^T
\end{align}
\]</span> 代入马氏距离表达式有： <span class="math display">\[
\begin{align}
D_M &amp;= [(\pmb{x-u})^T\Sigma^{-1}(\pmb{x-u})]^{\frac{1}{2}} \\
&amp;= [(\pmb{x-u})^T(RSR^T)^{-1}(\pmb{x-u})]^{\frac{1}{2}} \\
&amp;= [(\pmb{x-u})^TR S^{-\frac{1}{2}}
S^{-\frac{1}{2}}R^T(\pmb{x-u})]^{\frac{1}{2}} \\
&amp;= [(S^{-\frac{1}{2}}R^T\pmb y)^T(S^{-\frac{1}{2}}R^T\pmb
y)]^\frac{1}{2} \\
&amp;= [(S^{-\frac{1}{2}}R^{-1}\pmb y)^T(S^{-\frac{1}{2}}R^{-1}\pmb
y)]^\frac{1}{2}
\end{align}
\]</span> 其中 <span class="math inline">\(\pmb y = \pmb{x-u}\)</span>
考虑： <span class="math display">\[
\begin{align}
\pmb z &amp;= S^{-\frac{1}{2}}R^{-1} \pmb y \\
\pmb y &amp;= RS ^{\frac{1}{2}} \pmb z
\end{align}
\]</span></p>
<p>其中 <span class="math inline">\(\pmb z\)</span>
为旋转缩放后，各维度独立、归一化后的数据，<span
class="math inline">\(\pmb y\)</span>
为原始维度空间的数据。这样原始维度空间独立化和标准化就十分清楚了，<span
class="math inline">\(\Sigma ^{-1}\)</span>
就是独立、归一化数据变换到原始数据的逆。</p>
<p>对角阵 <span class="math inline">\(S^{\frac{1}{2}}\)</span>
就是维度独立化后的数据的标准差矩阵，取逆就是数据归一化操作。</p>
<hr />
<p>注意上面认为协方差矩阵是可逆的，马氏距离只对线性空间有效，协方差是线性关系的刻画，可能是因为期望的计算本身就是一个线性操作。</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>协方差矩阵</tag>
        <tag>马氏距离</tag>
      </tags>
  </entry>
  <entry>
    <title>Valder Fields</title>
    <url>/2021/07/15/2021-07-15-Valder-Fields/</url>
    <content><![CDATA[<p>很现实，很慵懒，不能逃避，只能面对</p>
<p><img src="/assets/ArticleImg/2021/1909137-60cabd4bdafc7b95" /></p>
<span id="more"></span>
<h2 id="歌词">歌词</h2>
<p><strong>I was found on the ground by the fountain at Valder Fields
and was almost dry.</strong><br />
人们在valder fields的喷泉旁发现了几乎快被太阳晒干的我</p>
<p><strong>Lying in the sun after I had tried</strong><br />
在尝试无果后躺在烈日之下</p>
<p><strong>Lying in the sun by the side</strong><br />
和阳光肩并肩地躺在一起</p>
<p><strong>We had agreed that the council would end at three hours
over-time</strong><br />
我们曾经达成协议，议会将在3小时后结束</p>
<p><strong>Shoelaces were tied at the traffic lights,</strong><br />
在交通灯前我系好鞋带</p>
<p><strong>I was running late. </strong> 却还是迟到了</p>
<p><strong>(I) could apply for another one I guess. </strong><br />
我想我能够申请加入另一个公司的</p>
<p><strong>If department stores are best.</strong><br />
如果百货商店是最好的</p>
<p><strong>They said there would be delays, only temporary
pay</strong><br />
但是那里总会有拖欠,而且只有暂时的薪水</p>
<p><strong>She was found on the ground in a gown made at Valder Fields
and was sound asleep (on the) stairs above the door to the man who cried
when he said that he loved his life.</strong><br />
人们发现身穿 在valder fields定做的晚礼服 的她躺在门外的台阶上
对着一个说到他热爱他的生活就会哭的男人 沉沉地睡着。</p>
<p><strong>We had agreed that the council should take his keys to the
bedroom door</strong><br />
我们已经达成协议，在会议上拿走了他房门的钥匙。</p>
<p><strong>(In )case he slept outside and was found in two days</strong>
<strong>In Valder Fields with a mountain view.</strong><br />
所以他只能露宿在外，并且在两天后被人发现和valder
fields的山景睡在一起。</p>
]]></content>
      <categories>
        <category>Life Record</category>
      </categories>
      <tags>
        <tag>Songs</tag>
      </tags>
  </entry>
  <entry>
    <title>本科毕业小结</title>
    <url>/2021/06/27/2021-6-27-%E6%9C%AC%E7%A7%91%E5%9B%9B%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="小结">小结</h2>
<p>晃眼四年已过<br />
仔细想想<br />
仿佛昨天还在青广翻着行李箱<br />
急急忙忙找着报到需要的证件</p>
<span id="more"></span>
<p>最后一个到宿舍的我<br />
被选了一个最黑暗的角落<br />
新的宿舍<br />
新的朋友</p>
<p>看着你们都拿了珠峰班的报名表<br />
便也想去凑凑热闹<br />
结果稀里糊涂得还被选上了<br />
记得笔试分数不高<br />
一向比较内向的我<br />
却在面试上吹起了牛</p>
<p>还记得说过<br />
『我现在这张白纸<br />
一定会变成一张蒙娜丽莎』<br />
现在想来<br />
稍稍有些羞耻了<br />
却不知何时可以兑现</p>
<p>珠峰班确确实实给我打下了比较好的基础<br />
忙忙碌碌的大一<br />
和晒得乌漆嘛黑的军训</p>
<p>大二有幸去了杭州计算机大会<br />
算是长了个见识<br />
也去了浙大计算机学院<br />
确实和我们不一样</p>
<p>大三被退班<br />
确实技不如人<br />
但还是比较开心的<br />
不用换宿舍<br />
更不用换人</p>
<p>20年疫情<br />
还有了线上上课的经历<br />
没有什么特别的爱好<br />
普普通通的我<br />
稀里糊涂的四年<br />
也算还是过得明白</p>
<p>朋友比较少<br />
差不多就是一个202<br />
但也是足够足够<br />
你们都是很好的人<br />
很庆幸能和你们呆满这四年</p>
<p>四年其实并无太多遗憾<br />
该做的，该学的<br />
也算是都做了<br />
明明是喜欢闲着的我<br />
却总是忙忙碌碌</p>
<p>谁曾想<br />
喜欢家里蹲的我<br />
当初也有每周骑行游成都的壮志<br />
虽然只持续了<br />
一个月，四个周</p>
<p>四年的回忆还有很多<br />
未来的路也还很长<br />
我们都背负了很多很多<br />
把过去放在心里<br />
把眼光放在未来<br />
不要害怕<br />
我们一直都在<br />
带着初心<br />
活成自己想活的样子</p>
<p>自从厌倦于追寻<br />
我已学会一觅即中；<br />
自从一股逆风袭来<br />
我已能抵御八面来风，驾舟而行</p>
<h2 id="毕业登记表自我鉴定">毕业登记表自我鉴定</h2>
<p>不觉到了说再见的年龄，回首四年，却并无太多遗憾。<br />
怀揣着梦想与期望，四年的沉浮，初心依在，稚气依在。<br />
遇见了，面对了，尝试了，<br />
笑着拥抱成功，也笑着经历失败。<br />
有刻苦，也有松懈；有不解，却也不失豁然开朗。<br />
付出时间与精力，收获更优秀的自己，更幸福的未来。<br />
远赴千里，陌生的人，陌生的环境，早已不知去向。<br />
朋友圈虽小，但也是足够。这有欢声，也有笑语。<br />
学习与娱乐，工作与生活，平衡与打破，总归是兼得了。<br />
有着一个好的开始，也有着一个满意的结束。<br />
自从厌倦于追寻，我已学会一觅即中；<br />
自从一股逆风袭来，我已能抵御八面来风，驾舟而行。</p>
<h2 id="最后的离别说说">最后的离别说说</h2>
<p>终于还是到了该说再见的时候<br />
宿舍开始变得空荡 陪伴了四年的钥匙也已不在<br />
慢慢长大<br />
不觉变得容易伤感<br />
男人的离别<br />
不需要眼泪<br />
或许分别千里<br />
但情义却总是在的<br />
仅祝各位<br />
不忘初心<br />
活出自己想活的模样<br />
有缘无缘<br />
都江湖再会啦</p>
<h2 id="毕业设计致谢">毕业设计致谢</h2>
<p>几个月的本科毕业设计匆匆结束，大学四年的学习与生活也要悄悄地说再见。毕业设计的顺利完成离不开老师以及同学的帮助。</p>
<p>首先，感谢我的导师，李征教授。老师给我的论文的题目以及设计思路提供了很多意见，对我的每一个问题都耐心并详细地回复，几乎每一个问题您都会用电话与我沟通，再次感谢您愿意耗费时间对我耐心地指导。遇到您这样热心、和蔼、负责的老师，我是幸运的。还要感谢罗运学长，研三需要处理的事情很多，但你依然为我解答问题，给我推荐论文，让我逐渐清晰了自己的算法设计。</p>
<p>此外，还要感谢这四年来陪伴我的室友。我真的好幸运能够遇到你们这几个宝藏，和你们一起学习是有动力的，和你们一起生活是有趣的，有你们的日子不会是枯燥的，谢谢你们让我依然是我。都说分别为了更好的重逢，但下一次重逢又会是何时。祝福我们都有一个美好的未来，活成自己想活的模样，最重要的是，身体一定要健健康康的。【写这段的时候还真哭了好一会】</p>
<p>另外还要感谢几年来每一个教导过我的老师，一起学习的同学。滴水成河，聚沙成塔，你们给我夯实了基础，给我的学习提供了很大的帮助。</p>
<p>感谢我的父母，把我养大成人很不容易吧，你们辛苦了，儿子会让你们感到骄傲的。希望你们身体健康，每天都可以开开心心的。</p>
<p>对四年本科挥手告别，学着拥抱三年研究生生活吧，一切的一切都为了更好的生活，更优秀的自己，加油。</p>
]]></content>
      <categories>
        <category>Life Record</category>
      </categories>
  </entry>
  <entry>
    <title> SFM 性能评估</title>
    <url>/2021/07/01/2021-07-01-EvaluatingSFM/</url>
    <content><![CDATA[<blockquote>
<p>原文：<a href="https://www.mdpi.com/2313-433X/4/8/98">Evaluating The
Performance Of Structure From Motion Pipelines</a></p>
</blockquote>
<p><strong>摘要：</strong>运动中恢复结构是一个通过一组图片集实现三维重建的管线。一个经典的
SFM
管线将多个步骤组合在一起，每一个步骤处理不同的问题。并且每一个步骤可以使用不同的算法，因此可以建立许多不同的
SFM 算法。为不同的人物选择合适的 SFM
算法是一个很重要的问题。在这篇文章中，我们根据重建不同场景的能力，对较新的
SFM
管线做了比较。我们还提出了一个评估程序，使用高级设备获取的真实场景图像以及真实的合成数据集对
SFM 管线进行评估。最后，我们为 Blender
创建了一个插件来为合成数据集创建以及 SFM
管线评估提供支持。合成数据集的使用使得我们容易地获取大量并且不同的数据集，理论上和真实图像无限接近。我们的评估程序不仅考虑了重建误差，还考虑了用于重建的相机姿态误差。</p>
<p><strong>关键词：</strong> SFM，三维重建，Blender，评估</p>
<span id="more"></span>
<h2 id="引言">1. 引言</h2>
<p>三维重建是一个可以获得目标场景或者物体的几何以及外观的步骤。三维重建在许多领域都有应用。三维重建算法有主动和被动之分，其中主动方法需要特殊的设备来捕获几何信息，而被动方法仅仅需要光学成像设备。被动式算法如下图所示，给定一组从不同观察位置的图片集，以稀疏点云的形式为每一幅图像恢复其相机姿态以及场景三维结构。在生成了稀疏重建后，就可以进入稠密图生成阶段（Multi-View-Stereo
MVS)。</p>
<p>增量 SFM 管线如下图所示：</p>
<figure>
<img
src="/assets/ArticleImg/2021/EvaluatingSFM.assets/image-20210630190215822.png"
alt="image-20210630190215822" />
<figcaption aria-hidden="true">image-20210630190215822</figcaption>
</figure>
<p>每个阶段有不同的算法选择，所以选择合适的 SFM 管线需要技巧。</p>
<h2 id="回顾-sfm">2. 回顾 SFM</h2>
<p>完整的增量型 SFM 管线已经在 Fig2
中给出了，它由两部分组成，对应搜索和迭代增量重建。第一阶段的输出称之为场景图或者视图表示了经过几何验证的图像之间的关系。</p>
<h3 id="sfm-组件">2.1 SFM 组件</h3>
<ol type="1">
<li><strong>特征检测：</strong>检测图像的特征点，可以使用不同的算法，选择的算法会影响特征鲁棒性以及下一阶段匹配效率。</li>
<li><strong>特征匹配：</strong>这步将第一步获得的图像特征匹配，这阶段的输出是具有重叠图像对之间的对应匹配点集。</li>
<li><strong>几何验证</strong>：这个阶段是必要的，之前阶段的匹配不能保证匹配到的点是真正的场景匹配点，具有离群点。找到两个图像之间的可以匹配到足够多匹配点的几何变换是必要的。获得到了这个变换说明这两个图像经过了几何验证。对于不同的图像集，用于描述它们几何关系的方法也是不同的。单应矩阵用于描述两个平面之间的关系，而对极几何可以通过本质矩阵、基础矩阵描述相机的变化。由于离群值的存在，所以可以使用
RANSAC 算法估计。</li>
<li><strong>重建初始化</strong>：增量重建的初始化是一个十分重要的步骤。从匹配点比较稠密的图像开始为良好的重建效果提供坚实的基础。重建总是从几幅图片开始，所以光束法平差获取不到足够的信息，就可能导致累计误差和坏的重建结果。重建初始化从几何验证最佳的一对匹配图像开始，这对图像中的匹配点作为最初的重建点云，并用于建立初始的两个相机的位置姿态。</li>
<li><strong>图像注册：</strong>这个阶段添加新图像并获取这副图像的相机姿态，新记录的图像还不会向点云增加新的点，需要在三角化阶段完成。</li>
<li><strong>三角化：</strong>之前新注册的图像可能观察到更多的新的点，如果这些点至少被之前处理过的一副图像观察到，那么就可以添加到重建点云中。三角化处理就是用于定义需要添加到点云中新点的三维坐标，由此可以获得一个更稠密的点云。对极几何相关。</li>
<li><strong>光束法平差</strong>：相机姿态估计和三角化都会产生误差，所以尽可能的降低累计误差是很重要的。BA
使用的算法是 Levenbery-Marquardt(LM) 算法，也被称为 Damped
Least-Squares。这个阶段会产生很高的计算开销，并且为每一幅添加到重建的图像计算，所以一般为局部执行（例如，仅给一小部分联系最紧密的计算）。全局
BA 仅当重建点云误差增长超过一定百分比时使用。</li>
</ol>
<h3 id="增量-sfm-管线">2.2 增量 SFM 管线</h3>
<p>文章主要介绍的几个方法：COLMAP, Theia, OpenMVG, VisualDFM, Bundler,
and MVE</p>
<figure>
<img
src="/assets/ArticleImg/2021/EvaluatingSFM.assets/image-20210630205406445.png"
alt="image-20210630205406445" />
<figcaption aria-hidden="true">image-20210630205406445</figcaption>
</figure>
<h2 id="sfm-评估方法">3. SFM 评估方法</h2>
<p>需要将重建结构和地面实况做比较，其中地面实况需要知道几何关系以及每个图像对应的相机位置。评估方法有四个阶段：</p>
<ol type="1">
<li><p>对准和注册 Alignment and registration</p>
<p>因为重建和地面实况用的是不同的参考坐标系（Reference Coordinate
Systems，RCSs），两个坐标系的对齐可以使用一个刚体变换矩阵
T。这部步骤包含两个部分，第一阶段为粗糙对齐，第二阶段为精准对准</p></li>
<li><p>稀疏点云评估 Evaluation of sparse point cloud</p>
<p>这个阶段考虑重建点云和地表几何的距离，如果地面实况已稠密图的形式给定，它们之间的距离可以使用欧氏距离给定，如果以曲面形式给出，那么距离就是重建点和离它最近三角平面上最近的点的距离。这个步骤可以使用八叉树数据结构优化加速。需要忽略掉那些不是主要成分的点。</p></li>
<li><p>相机姿态评估 Evaluation of camera pose</p>
<p>有位置评估和方向评估</p></li>
<li><p>稠密点云评估 Evaluation of dense point cloud</p>
<p>MVS 阶段，和稀疏点云评估类似</p></li>
</ol>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
      </categories>
      <tags>
        <tag>论文研读</tag>
        <tag>SFM</tag>
        <tag>三维重建</tag>
      </tags>
  </entry>
  <entry>
    <title>当代中国社会各阶级（阶层）分析【转】</title>
    <url>/2022/03/06/2022-03-06-%E5%BD%93%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%A4%BE%E4%BC%9A%E5%90%84%E9%98%B6%E7%BA%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>当代中国社会各阶级（阶层）分析？ - <a
href="https://www.zhihu.com/question/264465874/answer/2362337359">Hac棱镜的回答
- 知乎</a></p>
</blockquote>
<p>1925年冬 ，毛选首卷首篇落成 ，中国社会各阶级的分析
。落笔如刀，将当时中国社会一分为六，寥寥数千字，写尽四万万人。疏忽百年，斯人长逝，时移事迁，请以新作，再论当下之中国。</p>
<span id="more"></span>
<p>官僚集团和官僚资产阶级统摄全国，可支配一切国家资源，其直属资源，亦有相当分量。</p>
<p>本世纪初，以土地资源最值得注意。国家如房屋，此阶级之所作所为，尽力维持栋梁不倒，内克诸难，外御风雨，偶窃一砖一木，以饱私囊。数十年来，自央至地，树大根深，枝繁叶茂，壁垒森严，世袭成风，以官僭国，以家擅官。当下中国，内有诸事繁冗，外有群狼环伺，此阶级能否战胜自身，将决定未来之国运。天下之事系于诸公之手，天下之望亦归于诸公。</p>
<p>大资产阶级，中国之财，半入其手。</p>
<p>改开之初，国内资本极度稀缺。故各地政府，均采取亲资本政策，各处关节，多有扶持，其中秘辛，不便详述。时至今日，气候已成，各行各业，举足轻重。更以两股势力最为反动，一曰金融，二曰买办。金融家不务实业，专务投机。本应借贷周转，以助百业，然时至今日，喧宾夺主。民谚云：实业不如投资，投资不如投机。其利润丰厚，天下皆知，其反动本质，亦为万民所诟。金融蚕食实业，前车之鉴不远。若任由其肆意蔓延，后果殊难预料。</p>
<p>买办亦如此，或有人发问，当下之中国，仍有身在中华，心在海外，为外国资本驱使之人吗？恐怕为数不少，然与百年前不同。当时，买办占据中国第一等的位置，狗仗人势，肆意盘剥。而当今买办低于官僚。无论官民，皆深恨买办，故其行为愈发隐蔽，伪装手段愈发高明。其反动性不言自明，无需论述。美国及其附庸国，现已充当此等人东窗事发之退路，也正因此，其行为愈发肆无忌惮，无法无天。</p>
<p>此外，金融与买办常相勾结，你中有我，我中有你，更加稳固，更加反动。</p>
<p>大资产阶级之中，第二反动的是互联网资产阶级：</p>
<p>互联网资产阶级，其所依仗者，唯万千用户本身。流量资源、网络社区、数据资产完全源于用户。用户使用其产品，既是接受其服务，又是为其添砖加瓦，包括现在的你我。故你我既是其用户，又是其工人。若实业资本剥削工人之剩余价值，互联网资本则剥削每个用户之剩余价值。如果此类资本继续做大，渗透每个国民，将会剥削每个国民之剩余价值。</p>
<p>或有人问，我于网络之中，分文未花，故我从未受其剥削。持此论调者，如此天真，竟不知网络时代，流量即金钱。正因有海量免费玩家之存在，才有愿付费之人，正因有亿万用户，才有每年亿万广告收入，而广告终将从用户身上收回成本。蛛网绵密，无人可逃，你我每次点击，皆为一丝一粟，供其锦衣玉食。且网络流量之深层价值，何止于广告收入？操控舆论，垄断信息，炮制新闻，扶植网红，收集数据，贩卖隐私，渗透各行各业，处处争利于民。甚至瓜果菜蔬，亦不放过。另有更深一层，互联网资本恶化产业结构，压制实业发展。试想今时今日，经营实业，岂能与网络无涉？互联网资本又岂能不分一杯羹？或提供平台，或直接控股，大平台之于小商户，如同大地主之于佃户。其收租行为，已与金融资本无异。实业利润愈发压缩，环境愈发艰难。时至今日，互联网及其数据，已具备基础设施之价值，生产要素之功能。国之命脉，流于私人之手。后果何如，殊难预料。</p>
<p>大资产阶级其余部分，可称为<a
href="https://www.zhihu.com/search?q=实业资产阶级&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">实业资产阶级</a>。1925年，名曰民族资产阶级，毛主席将其划为中产。然当今之世，其中部分幸运者，已上升至大资产阶级，彻底失去革命性。然而其两面性依然未改，一面防范外资，憎恨买办，一面剥削无产，严加防备。其右翼较为反动，不恨买办，只恨自己不是买办，不恨金融，只恨自己无力染指金融。其左翼较为进步，爱国立场坚定，尽力合法经营，或有良善者，对其员工待遇保障，亦有所照顾。在国际竞争中，与中国人民统一战线，为中国经济亦做出较大贡献。当下其形象整体正面，其作用依然关键，若其守法合规，诚信经营，短期之内，与广大人民尚可合作。然无论如何，其资产阶级本质不变，若停止剥削，旬月之内则举步维艰，在资产阶级内部，恐无立锥之地。无论其主观愿望如何，道德水平如何，法律意识如何，阶级利益所在，必须参与剥削。以上种种大资产阶级，有一共通之处，即对资产阶级法权视若性命，甚至试图染指政治，保障此类权利，与众目睽睽之下拉帮结伙，以壮声势。官资群三者，于此处多番博弈，此处略过不谈。大资产阶级与官僚资产阶级区别在于，官资直接掌控权力，大资不能。</p>
<p>中产阶级</p>
<p>此类人可细分为二，其中一类可以三字概括之：小老板。孜孜以求者，唯有阶级上升。其内部又分为二，部分人等，与地方官僚颇有来往。且与大资相比，中产对官僚更为恐惧，更为依顺，因其人微位卑，并无资格与官僚博弈，唯有依附官僚，争当鹰犬，方有跻身大资之希望。另有部分人等，并无官僚荫蔽，只得依附其他大资，于上下游<a
href="https://www.zhihu.com/search?q=产业链&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">产业链</a>中，占一席之地。现有条件下，自知上升可能不大，于是转移目标，为子孙谋，惟愿财富地位，代代相传。诸如法式浪漫，意式优雅，英式风情之最大受众，即是此阶级之子孙，因其迫切需求与人民群众拉开差距，然而又无法真正地位超然如大资，思之令人发笑。</p>
<p>此为中产之上层。</p>
<p>另有一部分，分布于各行各业，常为高级人才，比如大教授，大医生，大律师，企业高管，文体明星，其业内地位，举足轻重。一方面以其专业知识，为上位者提供服务，常与人民对立，为人民群众所不齿。另一方面，却是人民之奋斗榜样。其所在阶层，为常人以个人奋斗可达到的最高水平，亦是大多数人社交圈层中可接触的最高阶级。其教育程度较高，审美上佳，言行体面。其中文体明星，更值注意，虽属中产，收入更高，还可利用知名度投资变现，且此类人与大资产阶级联姻之可能性，远超医生律师等知识中产，这亦是因为大资产阶级需借用其知名度以做宣传。故而文体明星，算是中产下层中，较有上升希望的。另外，此阶层国际流动性最强。其资产与技能，为各国普遍欢迎。且个人去留不至于对国家有太大影响，又不若官资、大资与一国政治多有渊源，中产上层与国内人脉深层绑定。故中产下层加入外籍较为常见。</p>
<p>此为中产之下层。</p>
<p>中产阶级上下层之界限，非收入之多寡，而在于上升潜力，前者即小老板群体，若有靠山扶持，市场搏杀胜出者，或有跻身大资之可能，后者即行业人才，几乎没有，除少数时运亨通，长袖善舞者，始终要依附于上位者，扮演高级幕僚。事实上，无论何种中产，其核心仅有依附二字。中产阶级与大资产阶级区别在于，大资可以影响行业走向，中产不能。</p>
<p>小资产阶级，如小知识分子，企业中层，个体户，小商人，所谓脑力无产者，多归于此类。</p>
<p>此类人借中国经济腾飞之东风，脱贫致富，接受教育，成为脑力工作者，免于饥寒。由于中国经济日益发展，教育日益完善，此类人数量空前膨胀，当下舆论中，颇有其一席之地。</p>
<p>其右翼所梦寐以求者，唯跻身中产而已，小教授欲为大教授，小律师欲为大律师，个体户欲为中小企业家。或有人野心更大，然真正认为自己可以连跨两级，由小而中，由中而大者，并不多见。其生活作风，喜模仿中产阶级，然经济所限，难以进入奢侈之门，于是退而求其次，发明一词“轻奢”，以消费定义自身，是此阶级最为明显的特征。对其最高称赞，即是专业、内行、有派头，因为此等夸赞，实质上是在肯定其具有上升至中产的能力，他们自然心花怒放，笑逐颜开。右翼小资经过多年奋斗积累，其能力、资历未必不如中产，然人脉寥寥，无枝可依，往往终生郁郁，难以上升。此阶层国际流动性位居第二，原因与中产下层相若。然其整体条件不如中产，故受各国欢迎程度稍逊。</p>
<p>小资左翼，多为小资群体中，对阶层爬升不抱希望者，以家境尚可之学生为主。正常情况下，其毕业以后，走入社会，生活压力陡增，往往不能以自身能力，维持在校生活水平，然其父母尚可助其一臂之力，还不至堕入底层。自知此生无望通过现有秩序升至中产，颇具<a
href="https://www.zhihu.com/search?q=犬儒主义&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">犬儒主义</a>色彩。另有一部分，对资本剥削、社会不公颇为痛恨，对底层人民，劳苦大众抱有同情。热衷扮演无产阶级，但真正使其体验无产者生活，却又未必经受得起，故其主要阵地在于网络，立场较为激进，观点尚不成熟，但自身教育水平尚可，输出观点意见的能力较强，排行第一，也不为过。</p>
<p>小资左翼与右翼，区别在于是否仍对升至中产抱有希望，进而导致其立场左右分野。阶级流动畅通，更亲资本，阶级流通不畅，更亲底层。近年来，有颇多右翼转为左翼，皆因承平日久，<a
href="https://www.zhihu.com/search?q=阶级固化&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">阶级固化</a>，上升通道日渐关闭，上升希望日渐渺茫。此类转换，是中国第三值得注意之转换。</p>
<p>此处需额外解释，百年前，毛主席将自耕农归为小资，是因当时乱世，农民能自有土地已属不易，故可归为小资。然经历土改，耕者有其田，自耕农的经济状况却难与小资比肩。土地虽为生产资料，然务农收入过低，以至于自耕农生活贫苦，不如无土地之工人。这导致农民工群体一时涌现，农民转工人，成为无产阶级，此类转换，应为阶层上升。由此可见，真正留在农村务农的农民阶级，比工人无产阶级更为贫苦，而非小资或半无产中的分支。</p>
<p>小资与中产区别在于，中产与上层有着千丝万缕的联系，小资没有。</p>
<p>半无产阶级，如小摊贩，小店员，小职工，小手工业者，在城市中艰难立足。从此阶级往下，再无切蛋糕的权力，只能等待分配。实际上，已经失去决定自身收入多寡的权力。此阶级由于自身原因，对上升至小资，不抱希望。其中亦有部分人，将希望寄托于子女，颇有<a
href="https://www.zhihu.com/search?q=苦大仇深&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">苦大仇深</a>之感，会对子女说，我这辈子就这样了，你要好好地奋斗出人头地云云。</p>
<p>半无产阶级内部，分为两层。上层有稳定工作收入，如企业小职员，小店员，虽工资颇低且几无上升空间，然每日两点一线，上班下班，糊口有余，消费不足。对所谓小资情调颇为反感，认为那些都是不本分的坏东西，会带坏好人家的孩子，若发现其子女对其感兴趣，往往大发雷霆，严加斥责。亦有少数人对其持包容态度，然可注意的是，中产小资的家常便饭，放在半无产中已经可以冠以“开明”二字，此皆是因为经济窘迫限制文化选择，故其整体上比较保守。此保守亦源于其生活，虽对上司时有不满，但生活尚有着落，又不像左翼小资，接受大量的印刷品与网络思潮。其观察社会，主要通过自己的双眼，对身边张三李四，家长里短比较在意，常用其比照自身生活，对书本理论无太大兴趣。或有人将其称为小市民。大多数学生毕业后，将会进入该层次，常有人自称热血已凉，皆因当家方知柴米贵，剪去长发丢掉吉他，体现为从左翼小资的激进，转为半无产上层的保守。此阶级转变，是中国第二值得注意的转变。</p>
<p>半无产阶级下层，无稳定工作，如小摊贩，小手工业者，或于农贸市场叫卖，或于街边兜售小吃，或做些缝缝补补的小手工业。收入较低且不稳定，然而总算有些小生意，小本钱，小手艺，时常因生意难以为继，只好外出打工，故称半无产阶级。对子女教育重视程度更低于以上阶级，常让未成年子女帮衬家里的生意，从此阶层往下，已经出现被迫失学，并非由于分数不够，而因无钱上学，或不愿上学。好在义务教育普及较完善，此处失学，指初中以上。</p>
<p>半无产阶级上下层，主要区别在于是否有稳定工作。</p>
<p>半无产与小资之间的区别在于，小资有一定上升空间，半无产很难。</p>
<p>无产阶级，可细分为城市无产阶级和农民工。</p>
<p>其上层为城市无产阶级，如血汗工厂工人，建筑工人一类。其工作已被许多人士，视作所谓低端工种，时常受到歧视，虽然不宣于口，然行为上的排斥已不少见。此阶层经济困窘，上升无望，省吃俭用，且无抗风险能力。但好在，其于城市中尚有一容身之所，故可享受部分城市资源。</p>
<p>无产阶级下层为进城农民工，此群体为数不少，2020年统计，有近三亿农民工，占中国总人口两成以上。其中约有一亿六千万为进城农民工，其原生家庭分散于各地农村，进城者从事最苦最累的工作，且常以临时工，合同工身份，收入很低，且随时可为他人所替代，时常更换工作甚至工种。毕竟其技术门槛较低，工种调换亦是常事。我等日常用品，很多出于其手，诸多廉价服务，亦由其提供。小时工、计件工等松散雇佣关系也较为常见。然而其经济地位低，无法获得与自身工作相匹之报酬，时常处于城市鄙视链底端，好在国家规定，不得拖欠工资。其子女常常留守农村，教育医疗与城市相差甚远。其与20世纪工业无产阶级亦有区别，集中性大幅降低，虽在务工期间暂时集中，然不久以后，终归要各回各家，组织结构原子化，难以团结维权。或从事重体力或高危劳动，收入超过半无产阶级甚至底层小资，但需吃苦、出力、冒险，忍常人所不能忍。部分人农忙时期回家务农，闲时进城务工，但总体务工收入远超务农，农民工身份先于农民身份，故可归类为无产。</p>
<p>此外亦有一亿两千余万本地农民工，虽由务农转为务工，然而仍居住于本地老家。或在乡镇工厂，或从事服务业，其收入较外出农民工更低，而较纯农民收入更高，然而守家在地，可以就近照顾老人子女，如今疫情期间，跨省市出行多有不便，此类群体，人数有上升趋势。农民转为农民工，为当今中国第一值得注意之转换。中国农民工，或是人类历史上质量最高的工人群体。得益于义务教育，劳动力素质较高。其家庭背靠<a
href="https://www.zhihu.com/search?q=小农经济&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">小农经济</a>，只身外出务工，家人子女留在故乡。用工发达省份提取劳动力，故乡承担劳动力培养成本，价格岂能不低？竞争力岂能不强？中国资本崛起，非惟工人群体之贡献，亦因无数农民，压低用工成本。</p>
<p>无产阶级上下层的区别在于是否在城市有自住房和户口。无城市户口农民工，区别在于进城务工或本地就业。</p>
<p>无产与半无产区别在于，半无产尚有一定本钱，在微末生意和打工之间有转换余地，无产几乎没有。</p>
<p>农民阶级，约有2.5亿。中国的农业土地上，滴落的是他们的汗水。中国的餐桌上，亦是他们的劳动。然而自身年收入极低。2020年，农村人口人均可支配收入约17000元，然其中包含进城务工收入，故纯农业人口年收入不过数千，或有地区可种植经济作物，年收入过万。此外，农业人口老龄化非常普遍，约有三分之一超过55岁，皆因年轻人纷纷进城务工。其舆论话语权远小于人口占比，子女教育资源也远不如城市人口，虽有助农补贴，但其生活状态之贫苦有目共睹。以我国人均耕地面积论，欲以纯务农致富，绝无可能。国欲富农，必以农业为中心，发展周边产业。事关2.5亿人，体量极大，意义极大，难度极大，具体路径仍待相关专家探索，但以我国之高效执行力，此事仍可办成。</p>
<p>农民阶级内部区别，主要取决于其省份，地区，受纬度影响极大，地方政策，种植作物，农业经济模式各处区别较大，难以详述。</p>
<p>农民与无产阶级的区别在于，无产有工资性收入，而农民必须务农。</p>
<p>流氓无产者，多为底层失业人口。常游走于法律边缘，引发社会案件，为数不多，破坏性极大，处于经济和道德的双重鄙视链底层。国家需妥善引导处置，在其成为流氓无产者之前，提供可以糊口的工作，而非一次性的扶贫手段。当然，国家自有其难处，但此事至关重要，否则将影响社会治安。流氓无产者亦分为两类，一类依附于某些组织，为上层阶级所驱使。一类完全</p>
<p>以上可做为全文。</p>
<p>以下为个人对阶级社会的理解。附于文后，浅见漫谈，不成体统。</p>
<p>阶级社会的核心诉求就是稳定，包括阶级内稳定，与阶级间稳定。</p>
<p>阶级内稳定很好理解，防止有人背叛阶级。只有最擅长维护本阶级利益的人，才能留在这个阶级。一只无形的大手抓住了我们每个人的脖子，无论是达官显贵还是<a
href="https://www.zhihu.com/search?q=贩夫走卒&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">贩夫走卒</a>，任何个人层面的努力都无法改变现状。就算把<a
href="https://www.zhihu.com/search?q=丁义珍&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">丁义珍</a>绳之以法，新来的李达康还是要维护这个现有体系，就算严惩那些黑心资本家，换了个良心企业家也还是要追求资本增殖。当利益冲突加剧，争夺和维护利益的手段也逐渐地突破下限。谁更没底线，谁践踏的规则越多，谁的武器弹药就越充足。蛋糕越来越少，温情脉脉的面纱怕是要被撕的粉碎了。</p>
<p>阶级间稳定是一个社会成熟的标志。只有动荡期，才会有着极快的阶级流动。而锁死阶级流动，有三大法宝。收益鸿沟，利益均沾，养寇自重。</p>
<p>首先是收益鸿沟。</p>
<p>阶级社会从高至低，其所依赖的核心资源分别为权力、资本、教育、劳动，那么就让这四种资源的收益依次降低，而且相邻两层的差距越大越好。个体层面的努力，在资源收益率的鸿沟面前，极其渺小。底层劳动者一年的工资，比不上教授开几场讲座的津贴；教授一年的收入，比不上资本家的存款的利息。于是低欲望社会显现，大家在交流怎么躺着更舒服。对于我国来说，显然还是体制内最舒服，名校博士涌向公务员教师等行业，求稳的同时开发副业。此外，一手锁死阶层流动，另一手大力扶贫。底层群众的温饱问题得到了国家的解决，创造了人类历史上，规模最大的脱贫成就。有些人还吃不饱，你有什么资格抱怨吃不好。让那些抱怨没有上升机会的人，失去了道德上的正确性，变成了贪得无厌和无病呻吟。有人说对国家未来充满希望，对自己却毫无希望。你担心的难道是自己被饿死吗？是因为你没有上升空间，因为阶级流动被锁死了。</p>
<p>其次是利益均沾。</p>
<p>我们每个人都在用行为自发的维护阶级社会，因为我们每个人都从中获利。我们享受便宜的快递，购买廉价的农产品，一个电话就能以很低的价格找来一个水管工。在这个体系中，我们每个普通人都是受益者，又都是受害者，每个人都是剥削者的帮凶，又在持续地被剥削。当我们家里停电了的时候，我们能拒绝一个廉价的电工吗？即便我们明知这个电工正在受到某个电力公司的剥削。哪怕是一个较为贫困的农民工，他也在穿着血汗工厂里的廉价衬衫。我们为了改善他的生活，提高了农民工收入，那就是让衬衫变得廉价，让衬衫工人的劳动变得廉价。除非我们同时提高衬衫的价格，顺带着提高大米、猪肉、水果，提高各行各业的劳动者的收入。这就代表着要让少数真正的剥削者出让利益。但他们是永远不会出让自己利益的，他们只会把一部分底层人的利益，转移给另一部分的底层。谁哭了给谁奶吃，谁露头就砸谁。</p>
<p>最后一大法宝是养寇自重。让政府也不得不在资本面前让步。某个资本家在国家面前当然是渺小的，但是整个资产阶级却已经对政府有所牵制。国内阶级矛盾和国际产业链竞争，两大社会主要矛盾，只能优先顾及其一。现在全球竞争是以国家和区域国家联盟为单位的资本竞争。我们在比谁的资本更强大，更能在产业链中占据优势地位，谁就更能剥削外国，获取垄断利润。所以全世界都必须竭尽全力，先剥削本国无产者把本国资本做大，再参与国际竞争。在国际竞争为主旋律的时代里，是无法缓和国内剥削的。甚至内部剥削越严重，本国商品越有价格优势，外部竞争力越强。政府必然亲资本，默许劳工权益受损。甚至政府补贴，降低商品出口价格以增强国际竞争力。尤其是在民族资本的幼年期和成长期。贫富差距怎能不大？资产阶级地位怎能不稳？网上流传甚广的一个说法马恩牌，实际上就是这个道理。社会管理者希望提取一切力量参与国际竞争，但普罗大众面临着真实的阶级矛盾，不希望自己的财富被提取。在相当长的时间里，国家对国际竞争的重视，超过国内矛盾。在这个问题上没必要评价，我只是把内外难两全的逻辑揭示出来。事实上，各国资产阶级甚至达成了某种默契，他们以互相养寇自重的方式，实现了全世界资产阶级的大联合。即便这种养寇自重不是他们的本意，他们是真的想吞掉对方，但各国资产阶级客观上确实形成了这样亦敌亦友的局面。</p>
<p>当国家之间进行资本竞争时，那么结局一定是比烂，比谁更擅长剥削，强势方剥削全世界，弱势方剥削本国，核心目的就是壮大资本。你炒石油我炒房，你印钞票我坏账，由人民群众给资本输血。战败国无产阶级的处境将会极其悲惨。因为战败国资产阶级剥削国内的力度不比胜者更小，却没能在国际竞争中占优，反而被外国资本吃干抹净，充当了外国资本剥削本国人民的中间人。他们不是主动当买办，是真的竞争不过，却又和买办无异，我称其为被动型买办，因为这是个赢者通吃的时代，大鱼既吃小鱼，又吃虾米。如果小资本输了，就要把之前的剥削成果交给大资本。程度轻的，会因为胜利者的垄断而支付过量成本，你想生产手机，你就要买我的芯片，成本转嫁给工人和消费者。程度重的，战败国资产阶级要把几十年的剥削成果，以国家经济崩溃的形式交给胜利者。这种国家我们不是没见过，有多少国家被国际资本割了韭菜，几十年积累的财富洗劫一空，内部矛盾激烈爆发。大量的失业人口涌上街头，犯罪率飙升，社会文明倒退，字面意义上的男盗女娼。物质和精神文明完全被击垮。最终，只能出一个政治强人稳住局面。如果天时地利人和俱备，那么就可以重建国家，稳步发展。如果不能，那么他将建立一个摇摇欲坠的国家，全世界都在担心他去世以后，他的国家怎么办。如果政治强人都找不到，或者这个国家的禀赋不足以自强，就只能从历史里翻出来一种保守传统<a
href="https://www.zhihu.com/search?q=原教旨&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">原教旨</a>的精神文明来重新整合内部，利用<a
href="https://www.zhihu.com/search?q=传统文化&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">传统文化</a>天然的政治正确性收拾残局、维持族群认同。没想到吧，千年古经被翻出来，是因为现代化失败，本质上是因为你的资本竞争力不够，是国际韭菜而非镰刀，导致社会资源匮乏，社会凝聚力下降。而传统意识形态和它衍生的分配制度，本身就是建构在生产力不发达的年代，恰好适配资本竞争失败后的国家。举个例子，大米不够吃了，搬出来老祖宗说过的话，某某类人不能吃饭只能喝稀粥，因为你禁止人吃白米饭，总要有个说法，而老祖宗生活的年代，确实没那么多大米，这就对上了。那些有资格吃白米饭的人，会成为复古政权的基本盘，局面就稳住了。在外人看来，这些国家仿佛回到中世纪了，是开历史倒车。但其实是因为新时代没有载你的船，现代化容不下你的位置，你被迫回到那个传统保守科技水平很低的时代，彻底放弃与发达国家的资本竞争，老老实实的做一个资源国或者劳动力国。把你的油田矿产都交给国际资本，国际资本给你的统治阶层付钱，没有人民群众的份。相比较之下，本国资本还能给你留口汤，外国资本直接杀鸡取卵。无产阶级除了祖国一无所有，即便明知政府更亲资本，也必须依附它。但随着竞争烈度增加，必须加大力度提取民财民力，比如说需要国家财政给一些运营不善的企业托底，以及补贴那些还没能形成国际竞争力的企业。这不是少数国家的行为，全世界都发生过，是全球资本竞争的必然。</p>
<p>怎么把比烂变成比好，有人尝试过。跳出资本竞争，转变成意识形态竞争，真正找到一个属于广大人民的意识形态。比谁更擅长造福本国无产者，而不是比谁更擅长剥削本国无产者。如果我们面对的选择题，是本国资本和外国资本二选一，结局自然是养寇自重和比烂。而先驱者理想中的选择，是在资本主义和社会主义中二选一。因为有了人民群众的参与，不存在少数利益集团养寇自重的可能。双方斗争形势，就是比谁的人民生活的更好，来证明自身意识形态的优越性
。同时这也是弱势国家翻盘的路径。苏联搞意识形态竞争的时候，他可以和美国分庭抗礼，当他搞资本竞争，搞<a
href="https://www.zhihu.com/search?q=私有化&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">私有化</a>的戈尔巴乔夫改革，绝对竞争不过美国。所以老一辈革命家说，马克思主义救中国，就是看透了这一点。弱势国家想通过资本竞争后来居上，大概率是要失败的。那么你的国内资本家，不是主动买办就是被动买办，因为你竞争不过，不愿做买办就要被封杀。而且还面临着剧烈的内部阶级矛盾，让资产阶级更加倾向于向外求援沦为买办。国民党起初也是想要救国的，但最终还是沦为买办，就是这样的逻辑。马克思主义救中国的原因，绝不仅仅是历史实践证明了这一切，大家依次登上舞台，我党胜利了，于是我们就是对的。这种论调有点异味你们细品一下。</p>
<p>但以上种种，又是缥缈的空谈。能和资本主义一战的意识形态里，真正成气候的至今为止只有<a
href="https://www.zhihu.com/search?q=马列主义&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2362337359%7D">马列主义</a>。而马列主义理论发展逐渐陷入停滞，没有新理论来回答新问题，逐渐演变成背课文念老经。先锋队变质的问题怎么办？共产主义和民族主义的冲突怎么办？公有制演变成官有制怎么办？一种社会形态，维持它的是少数人的忠诚和信念，那么他得到的只能是敬意和眼泪。</p>
<p>但资本主义的自我更新却没有停下，他通过产业转移，把血汗工厂转移到国外，并用收益的一小部分安抚了发达国家的无产者。而对于产业接收国，能被国际资本剥削已经是一种幸运，在工厂里受剥削，也比在土地里捡麦穗要好。也在宏观上提高了这些国家的生产力。只要这样的落后国家和地区依然存在，资本主义就依然在创造增量，在推动生产力发展。它的历史使命还没有完成，自然不会灭亡。反过来说，资本家有意识的让各地区发展不平衡，他的微观本意仅仅是在落后地区得到廉价的资源和劳动力，以及破坏各国无产者的共情，而宏观上导致资本主义还有开发生产力的功能，还在做大蛋糕。</p>
<p>发达国家的部分工人被资本招安，落后国家的工人在感激资本到来，只有处于中间的人，才痛切感受到资本主义的压榨。这就是全球资本竞争的必然结果，堪称当今中国种种社会问题的总根源。黄金时代结束了，无论怎样粉饰，竞争已经代替了合作成为世界的主旋律。这甚至不能当做一件坏事。这意味着中国经历了百年的奋斗，终于有资格向人类历史上最强大的超级大国发起挑战。但反过来说，何尝不是美国经历了三百年的奋斗，终于有资格站在有数千年历史的中国面前呢？我们即将见证历史，我们即将怀念那些不必见证历史的日子。</p>
]]></content>
      <categories>
        <category>道法自然</category>
      </categories>
      <tags>
        <tag>文章分享</tag>
        <tag>阶级</tag>
      </tags>
  </entry>
  <entry>
    <title>SFM Learner 2017</title>
    <url>/2023/01/29/2023-01-29-SFMLearner/</url>
    <content><![CDATA[<h1 id="sfm-learner-2017">SFM Learner 2017</h1>
<blockquote>
<p>Zhou T, Brown M, Snavely N, et al. Unsupervised learning of depth and
ego-motion from video</p>
</blockquote>
<p>为单目深度估计与相机姿态估计提出完全无监督的学习框架；</p>
<p>单视图深度估计与多视图位姿分别构建网络，将图像变换到目标视图上以构建损失，并根据此损失训练网络</p>
<span id="more"></span>
<h2 id="方法">方法</h2>
<p>从无标签视频序列中联合训练单视图深度 CNN 和相机位姿估计
CNN。这两个模型合并训练但可分开独立使用，模型适用于刚体场景。</p>
<h3 id="将视图合成作为监督">将视图合成作为监督</h3>
<p>深度和位姿估计 CNNs
监督信号主要为新合成的视图：给定一副图像，合成该图像在另外一个视角的图像，合成过程由后一节提出的完全可微
CNN 实现。</p>
<p><span class="math inline">\(&lt;I_1,\cdots,I_N&gt;\)</span>
为训练中使用的图像序列，其中 <span class="math inline">\(I_t\)</span>
为目标视图，并假设源图像为 <span class="math inline">\(I_s(1\le s\le
N,s\neq t)\)</span> ，那么视图合成的优化目标为： <span
class="math display">\[
\mathcal{L}_{vs} = \sum_s \sum_p \vert I_t(p)-\hat I_s(p) \vert
\]</span> 其中 <span class="math inline">\(p\)</span>
表示图像中每一个像素，<span class="math inline">\(\hat I_s(p)\)</span>
由 <span class="math inline">\(I_s(p)\)</span> 根据预测的深度图 <span
class="math inline">\(\hat D_t\)</span> 以及 <span
class="math inline">\(4 \times 4\)</span> 的相机变换矩阵 <span
class="math inline">\(\hat T_{t\rightarrow s}\)</span>
扭曲得到。这篇文章的视图合成监督信号不需要已知的相机位姿，因为相机位姿估计是整个网络框架的一部分，同样要被优化。
<img
src="/assets/ArticleImg/2023/SFMLearner.assets/image-20230104154158338.png"
alt="image-20230104154158338" /></p>
<p>这个步骤其实就是将 <span class="math inline">\(I_s\)</span> 扭曲为
<span class="math inline">\(I_t\)</span>
并计算光度误差，为了使网络能够训练，即误差传递，所以扭曲变换需要是可微的，即下面的可微渲染。</p>
<h3 id="基于深度图的可微渲染">基于深度图的可微渲染</h3>
<p>根据目标视图 <span class="math inline">\(I_t\)</span> 的深度图 <span
class="math inline">\(\hat D_t\)</span>
以及位姿估计网络得到的目标视图到源视图的变换矩阵 <span
class="math inline">\(\hat T_{t\rightarrow s}\)</span>，可以将 <span
class="math inline">\(I_s\)</span> 变换为 <span
class="math inline">\(I_t\)</span>，令 <span
class="math inline">\(p_t\)</span> 为目标视图 <span
class="math inline">\(I_t\)</span> 上的像素坐标，它在源视图 <span
class="math inline">\(I_s\)</span> 对应像素的坐标为： <span
class="math display">\[
p_s \sim K\hat T_{t\rightarrow s}\hat D_t(p_t)K^{-1}p_t
\]</span> 这里得到的 <span class="math inline">\(p_s\)</span>
的连续的，为了获得 <span class="math inline">\(I_s(p_s)\)</span>
则需要对其进行采样即插值得到 <span class="math inline">\(\hat
I_s(p_t)\)</span>。文章中用的是双线性插值表示如下： <span
class="math display">\[
\hat I_s(p_t) = I_s(p_s) = \sum_{i\in\{t,b\},j\in\{l,r\}}
w^{ij}I_s(p_s^{ij})
\]</span> 其中 <span class="math inline">\(w^{ij}\)</span>
是线性插值的权重，满足 <span class="math inline">\(\sum_{ij} w^{ij} =
1\)</span></p>
<p>具体微分步骤见论文 <em>M. Jaderberg, K. Simonyan, A. Zisserman, et
al. Spatial transformer networks. 2015</em></p>
<figure>
<img
src="/assets/ArticleImg/2023/SFMLearner.assets/image-20230104154601758.png"
alt="image-20230104154601758" />
<figcaption aria-hidden="true">image-20230104154601758</figcaption>
</figure>
<h3 id="模型限制">模型限制</h3>
<p>视图合成中的优化目标隐含表示：</p>
<ol type="1">
<li>目标场景是静态的，没有移动物体</li>
<li>目标视图与源视图之间没有遮挡</li>
<li>物体表面满足 Lambertian
反射，即理想漫反射模型，以使得光度误差有意义</li>
</ol>
<p>为了使得网络更具鲁棒性，文章额外训练了一个 explainability prediction
network，该网络将深度和位姿联合起来，为每一个目标-源像素对输出一个权重
<span class="math inline">\(\hat
E_s\)</span>，基于此，视图合成误差表示为： <span class="math display">\[
\mathcal{L}_{vs} = \sum_s \sum_p \hat E_s(p)\vert I_t(p)-\hat I_s(p)
\vert
\]</span> 直接对上式训练会导致 <span class="math inline">\(\hat
E_s\)</span> 总是预测为 0，介于此，增加 <span class="math inline">\(\hat
E_s\)</span> 的正则化项 <span
class="math inline">\(\mathcal{L}_{reg}(\hat E_s)\)</span>，<span
class="math inline">\(\mathcal{L}_{reg}(\hat E_s)\)</span> 为 <span
class="math inline">\(\hat E_s\)</span> 与 <span
class="math inline">\(\mathbf 1\)</span> 的交叉熵，以此让网络倾向于将
<span class="math inline">\(\hat E_s\)</span>
预测为非零值，因为在理想条件下目标视图于源视图像素是能一一对应的，即
<span class="math inline">\(\hat E_s\)</span> 全部为 1。</p>
<h3 id="克服梯度局限性">克服梯度局限性</h3>
<p><span class="math inline">\(\mathcal{L}_{vs}\)</span> 的梯度主要由
<span class="math inline">\(I_t(p)\)</span> 与 <span
class="math inline">\(I_s(p_s)\)</span>
周围四个像素的差提供，在缺少纹理的环境中以及预测误差较大的情况下将抑制训练，为此有两个策略来解决：</p>
<ol type="1">
<li>使用 encoder-decoder
网络结构，使得深度网络具有一定瓶颈以隐式约束输出达到全局平滑，并促使梯度从有意义的区域向四周传播</li>
<li>显示地增加多尺度和平滑误差以允许梯度从更大的区域获得</li>
</ol>
<p>文章中使用第 2 种策略，因为它对架构不敏感。</p>
<p>针对平滑，最小化深度图二阶梯度的 L1
范式，【对深度图平滑是否可以平滑相机位姿预测结果】</p>
<p>最后的误差表示为： <span class="math display">\[
\mathcal L_{final} = \sum _{l} \mathcal L_{vs}^l + \lambda_s \mathcal
L_{smooth}^l + \lambda_e \sum_s \mathcal L_{reg}(\hat E_s^l)
\]</span> 其中 <span class="math inline">\(l\)</span> 表示尺度，<span
class="math inline">\(\lambda_s,\lambda_e\)</span>
分别为平滑和正则误差的权重。</p>
<h3 id="网络结构">网络结构</h3>
<p>网络的具体信息可查看官方代码</p>
<h4 id="单视图深度">单视图深度</h4>
<p>使用 encoder-decoder 架构并具有跳跃连接和多尺度的
DispNet，文章尝试了将多个视图传入网络，但并没有提高网络效果。</p>
<figure>
<img
src="/assets/ArticleImg/2023/SFMLearner.assets/image-20230105100715540.png"
alt="image-20230105100715540" />
<figcaption aria-hidden="true">image-20230105100715540</figcaption>
</figure>
<h4 id="位姿">位姿</h4>
<p>位姿网络的输入是目标视图和所有源视图沿着颜色通道的拼接。输出目标视图与所有源视图的相对位姿</p>
<figure>
<img
src="/assets/ArticleImg/2023/SFMLearner.assets/image-20230105100735094.png"
alt="image-20230105100735094" />
<figcaption aria-hidden="true">image-20230105100735094</figcaption>
</figure>
<h4 id="可解释掩模">可解释掩模</h4>
<p>上图前五层位姿网络和可解释掩模网络是共用的，上图红色部分是可解释掩模网络的。</p>
<h3 id="讨论">讨论</h3>
<p>方法存在的问题：</p>
<ol type="1">
<li>没有显示处理遮挡和物体运动</li>
<li>需要知道相机内参，不能完全随便拿一段视频训练</li>
<li>使用深度图表示三维，未来可以使用体素表示</li>
</ol>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
        <category>三维视觉与SLAM</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>slam</tag>
      </tags>
  </entry>
  <entry>
    <title>非线性优化的流形和局部参数化</title>
    <url>/2022/05/26/2022-05-26-optimization-in-manifold/</url>
    <content><![CDATA[<p>非线性优化普遍的解决思路是使用非线性最小二乘，非线性最小二乘可参考前一篇文章<a
href="https://weijun-lin.top/2022/03/13/2022-03-13-%20%E7%9B%B8%E6%9C%BA%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1%E4%B8%8E%E7%82%B9%E4%BA%91%E4%BC%98%E5%8C%96/#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98">“相机位姿估计”</a>。在很多优化过程中，如果优化变量本身具有一定的约束，这样的优化将变得十分复杂，所以如果能将约束问题转换为无约束的这可以带来极大的便利。在高翔博士的《SLAM
十四讲》中，其中的 BA
优化便利用李群李代数构造旋转矩阵的无约束优化问题，这在博客<a
href="https://weijun-lin.top/2022/03/13/2022-03-13-%20%E7%9B%B8%E6%9C%BA%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1%E4%B8%8E%E7%82%B9%E4%BA%91%E4%BC%98%E5%8C%96/#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98">“相机位姿估计”</a>中也比较详细介绍了。这里记录一下对流形优化新的思考。</p>
<span id="more"></span>
<p>非线性最小二乘一般使用库 <a href="ceres-solver.org">Ceres Solver</a>
构建，它提供了将变量转换到其流形上的方法，称之为局部参数化（<a
href="%5BModeling%20Non-linear%20Least%20Squares%20—%20Ceres%20Solver%20(ceres-solver.org)%5D(http://ceres-solver.org/nnls_modeling.html#_CPPv4N5ceres21LocalParameterizationE)">Local
Parameterization</a>），这个参数化过程便是其所在切空间到其流形的映射表示。</p>
<h2 id="流形的不严谨介绍">流形的不严谨介绍</h2>
<p>流形是一个空间，它表示了变量的本质，其所在的真实空间。比如三维空间的一条曲线，这条曲线所在的空间是三维的，即它嵌入在三维空间中，但实际上它是一条曲线，曲线只有一个自由度，即我们可以将曲线参数化表达为：</p>
<p><span class="math display">\[
l =
\left\{
\begin{align}
x(t) \\
y(t) \\
z(t)
\end{align}
\right.
\]</span></p>
<p>很清楚的看到表达一条曲线其实只需要一个变量，即它本质上是一维的。这个一维空间便是它的流形空间，它流形是一维的。类似的，三维空间中的曲面，是一个二维流形。流形只能嵌入到比它维数更大的空间中。流形的维度和其变量所在的切空间有关，切空间是指变量某个取值处的切向量。拿曲线来说，三维空间曲线某点的切空间就是其切线，对于曲面则是其切平面。切空间满足欧式空间的性质，在切空间的改变量需要投影回流形，完成迭代更新。</p>
<h2 id="流形上的优化">流形上的优化</h2>
<p>之所以要将变量参数化到其流形上，是为了构建无约束的优化。在非线性优化中，比如经典的高斯牛顿法，本质上都是构建迭代：
<span class="math display">\[
x_{k+1} = x_k + \Delta x_k
\]</span></p>
<p>而这个迭代在变量自身有约束的情况下不一定成立，即更新后 <span
class="math inline">\(x_{k+1}\)</span> 不满足约束条件，比如约束 x
在某一条曲线上，当它执行简单的加法更新后它并不一定会在曲线上，但转移到流形上则不一样了。<strong>流形上的优化（局部参数化）可以理解为将
<span class="math inline">\(\Delta x_k\)</span> 转变为 <span
class="math inline">\(x_k\)</span>
切空间上的改变量，更新变量后投影回原空间得到 <span
class="math inline">\(x_{k+1}\)</span></strong>。Ceres
中的局部参数化也就是这个过程，其本质是重载了优化迭代中的“加法”，可以表示为：
<span class="math display">\[
\boxplus (x,\Delta)
\]</span> 在欧式空间中，<span class="math inline">\(\boxplus (x,\Delta)
= x + \Delta\)</span>，在李代数中 <span class="math inline">\(\boxplus
(x,\Delta) = \exp(\Delta)x\)</span>，<span
class="math inline">\(\Delta\)</span> 是其切空间上的改变量，<span
class="math inline">\(\exp(\Delta) x\)</span>
将其，然后更投影回流形并更新 <span
class="math inline">\(x\)</span>。这里李群通过矩阵乘法更新。</p>
<p>通过与高斯牛顿法比较，改变量变成了切空间上的量，所以需要对这个改变量（扰动）求导，这也就李导数中的扰动求导，即对扰动求导。</p>
<h2 id="方向向量求导">方向向量求导</h2>
<p>这里给一个具体例子，方向向量的局部参数化和对扰动求导，方向向量指的是表示一个指向的向量，为单位向量。三维空间内的方向向量只有两个自由度，它构成的集合是球心在原点的单位球。方向向量
<span class="math inline">\(n\)</span> 的扰动求导可以表示为： <span
class="math display">\[
n + \epsilon_{3\times 1} = \exp_{so3}(T_{3\times 2}\delta_{2\times 1})n
\]</span> 扰动为 <span class="math inline">\(\delta\)</span>
是一个二维向量，是在其切空间上的改变量，<span
class="math inline">\(T_{3\times 2}\)</span> 为 <span
class="math inline">\(n\)</span> 的切空间，即切平面，通过 <span
class="math inline">\(T_{3\times 2}\delta_{2\times 1}\)</span>
重新映射到三维欧式空间，为切平面上改变量在三维空间的表示，最后通过 <span
class="math inline">\(\exp_{so3} \times n\)</span>
投影到流形（单位球）上，这里将 <span
class="math inline">\(T\delta\)</span> 理解为旋转向量。<span
class="math inline">\(n\)</span> 的改变量对扰动的求导可以表示为： <span
class="math display">\[
\begin{align}
\frac{\partial n}{\partial \delta}
&amp;= \frac{\partial \epsilon}{\partial \delta} \\
&amp;= \frac{ \exp_{so3}(T_{3\times 2}\delta)n - n}{\delta} \\
&amp;= \frac{I + (T_{3\times 2}\delta)^{\wedge}n - n}{\delta} \\
&amp;= \lim_{\delta\rightarrow 0}\frac{(T\delta)^{\wedge}n}{\delta} \\
&amp;= \frac{\partial (T\delta)^{\wedge}n}{\partial(T\delta)}
\frac{\partial T\delta}{\partial \delta} \\
&amp; = -n^{\wedge}T
\end{align}
\]</span></p>
<p>最后迭代更新为： <span class="math display">\[
n&#39; = \exp_{so3}(T_{3\times 2}\delta_{2\times 1})n
\]</span></p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>manifold</tag>
        <tag>非线性优化</tag>
      </tags>
  </entry>
  <entry>
    <title>三维重建算法综述-张彦雯 小结</title>
    <url>/2021/06/03/2021-06-03-%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%E7%BB%BC%E8%BF%B0_%E5%BC%A0%E5%BD%A6%E9%9B%AF/</url>
    <content><![CDATA[<blockquote>
<p>关键词：三维重建；图像；稀疏点云重建（SFM）；稠密点云重建（MVS）；评价指标</p>
<p><a
href="%5Bnxdxb.cnjournals.org/ch/reader/download_pdf.aspx?file_no=20200509&amp;year_id=2020&amp;quarter_id=5&amp;falg=1%5D(http://nxdxb.cnjournals.org/ch/reader/download_pdf.aspx?file_no=20200509&amp;year_id=2020&amp;quarter_id=5&amp;falg=1)">下载链接</a></p>
</blockquote>
<p>获取三维模型主要通过以下三种方式：</p>
<ol type="1">
<li><p>传统的几何建模技术</p>
<p>最为成熟，但周期长，操作复杂</p></li>
<li><p><strong>基于图像的三维重建</strong></p>
<p>基于多幅不同角度拍摄的图像，运用计算机视觉理论进行三维建模；也有基于单幅图像的，但不能用于大规模场景</p></li>
<li><p>基于点云的三维重建</p>
<p>利用三维扫描设备对目标进行扫描，以重建模型</p></li>
</ol>
<p>文章主要介绍基于多幅图像的三维重建算法，主要包括稀疏点云重建（Structure
From Motion，SFM）；稠密点云重建（Multi-View System，MVS）。其中 SFM
包括特征点检测与匹配（SIFT，SURF，FAST等）以及 SFM 重构两个部分。</p>
<p>SFM
重构大致分为三类：<strong>增量式重构、全局式重构、混合式重构</strong>。在
MVS 中，<strong>深度图</strong>的计算尤为重要。</p>
<span id="more"></span>
<h2 id="稀疏点云重建-sfm">稀疏点云重建 SFM</h2>
<p>SFM 通过相机的移动确定目标的空间和几何关系，特征点匹配后运用 SFM
重构算法，恢复出相机的参数，相机之间的相对位置关系以及场景的稀疏点云，最后捆绑调整优化相机位姿、相机参数、场景结构。</p>
<p>流程总结为：特征点检测、匹配，相机位姿（旋转矩阵 R，平移矩阵
T）初始值的求解，捆绑调整优化相机位姿、相机参数、场景结构。</p>
<figure>
<img
src="/assets/ArticleImg/2021/三维重建算法研究综述_张彦雯.assets/image-20210603112341838.png"
alt="image-20210603112341838" />
<figcaption aria-hidden="true">image-20210603112341838</figcaption>
</figure>
<p>SFM
重构为利用相机运动轨迹来估算相机参数，初步匹配生成的的特征点比较粗糙，所以常用几何约束删除匹配错误的特征点对。SFM
重构主要有<strong>增量式和全局式</strong>。</p>
<p><strong>增量式重构</strong>是从两张图像中恢复相机的旋转矩阵 R
和平移矩阵 T，然后添加图像，利用PnP 计算出第三幅图像的
R、T，通过三角化重建出更多的场景。噪声的干扰会造成结果漂移，所以需要使用
BA（Bundle
Adjustment，光束法平差）。每次添加图像完成三角化后都需要进行优化。</p>
<p>步骤为：初始化、PnP 解算，三角化，BA 算法优化。重要的步骤为 PnP
求解相机位姿，主要有 P3P，EPnP，DLT，UPnP，MRE。</p>
<p><strong>PnP</strong>：已知 n
个三维空间点坐标（相对于某个指定的坐标系A）及其二维投影位置的情况下，如何估计相机的位姿（即相机在坐标系A下的姿态）</p>
<p>增量式在对大规模场景重建时由于误差累积会造成场景漂移以及反复地捆绑调整花费大量时间。</p>
<p><strong>全局式重构</strong>采用的是将相机相对位姿均匀分布的方法，该方法在处
理大规模重建时，相机之间的相关性不同，会导致重 建效果差。</p>
<p><strong>混合式重构</strong>就是把前两者进行融合。</p>
<h2 id="稠密点云重建-mvs">稠密点云重建 MVS</h2>
<p>SFM 重建比较稀疏，需要 MVS 进行完善，MVS
的目的是通过最佳方法对不同图像上的同一个点进行匹配，增强重建场景的稠密性。MVS
的主要任务是通过一种最佳搜索的方法，匹配不同图像上的同一个点。也就是在极线上进行探测，寻找两张图片上的同一点，主要方法为逐像素判断，由此提出了一致性度量函数。</p>
<p>深度图是指将相机到场景中各点距离作为像素值的图像，是 MVS
的一大重点。主要方法如下：</p>
<ol type="1">
<li>几何法
<ul>
<li>Plane-Sweeping</li>
<li>PatchMatch</li>
</ul></li>
<li>几何与深度学习相结合的方法
<ul>
<li>双通道法</li>
<li>DeepMVS</li>
</ul></li>
<li>基于深度学习的方法
<ul>
<li>MVSNet</li>
<li>PointMVSNet</li>
</ul></li>
</ol>
<figure>
<img
src="/assets/ArticleImg/2021/三维重建算法研究综述_张彦雯.assets/image-20210603195114007.png"
alt="image-20210603195114007" />
<figcaption aria-hidden="true">image-20210603195114007</figcaption>
</figure>
<h2 id="评价指标">评价指标</h2>
<p>分为有真实模型和无真实模型两类。</p>
<p>无真实模型的评价是通过对比输入数据与重建之后的数据一致性程度来实施的，其方法有<strong>重建误差法，积分误差法</strong>。</p>
<p>有真实模型的评价通过重建之后的模型与真实模型进行对比来实施，主要有<strong>形状误差法，分解法，相位矩不变量法，多指标评价法</strong>等。</p>
<p>这些算法都有缺陷：</p>
<ol type="1">
<li>部分算法只能分析真实模型的场景</li>
<li>部分算法只能测量重建的精度，但是不能测量完整性，导致评价的结果存在偏差</li>
<li>大多算法只考虑到几何精度，并没有将纹理模型的视觉精度添加到评价指标中，在某些需要视觉精度的场景中应用意义不大。</li>
</ol>
<h2 id="总结">总结</h2>
<p>基于图像的三维重建不需要精密的测量一起，成本低，同时该方法计算出了相机的内外参数，使得重建效果更为精确，具有快速、简便、逼真的优点，能较好地实现现实事物的虚拟化，但仍然存在一些缺点：</p>
<ol type="1">
<li>物体细节特征不理想</li>
<li>不能用于实时变化的场景</li>
<li>将场景中的物体变成二维对象，用于难获得需要的信息</li>
<li>对照相机和摄影设备有一定要求</li>
</ol>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
        <category>三维视觉与SLAM</category>
      </categories>
      <tags>
        <tag>论文研读</tag>
        <tag>SFM</tag>
        <tag>三维重建</tag>
        <tag>MVS</tag>
      </tags>
  </entry>
  <entry>
    <title>【报告】相机位姿估计与点云优化</title>
    <url>/2022/03/13/2022-03-13-%20%E7%9B%B8%E6%9C%BA%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1%E4%B8%8E%E7%82%B9%E4%BA%91%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="一-研究问题">一、 研究问题</h2>
<p>在基于视觉的三维重建算法（如 Structure From Motion, SFM<a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>）以及同时定位与地图构建（Simultaneous
localization and mapping, SLAM<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a><a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>）等涉及立体视觉的理论研究中，需要通过相机成像模型及特征点匹配等理论恢复相机位姿以重构三维场景，即目标点云的生成。</p>
<p>相机的位姿估计指从若干给定的图像中恢复相机的运动（位姿），进而恢复目标的三维结构（点云）。相机运动（位姿）即相机的外部参数，是世界坐标系到相机坐标系的变换，包含旋转和平移，即欧式变换。相机成像模型如下：
<span class="math display">\[
ZP_{uv} = Z
\left[
\begin{matrix}
u \\
v \\
1
\end{matrix}
\right] =
K(RP_w+t) = KTP_w \tag{1.1}
\]</span></p>
<p>其中 <span class="math inline">\(Z\)</span> 为世界坐标系下目标点
<span class="math inline">\(P_w\)</span> 的 z 轴坐标，<span
class="math inline">\(K\)</span> 为相机内参，可通过张正友标定法<a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>确定，<span
class="math inline">\(R,t\)</span>
为世界坐标系到相机坐标系的变换，可以使用矩阵 <span
class="math inline">\(T\)</span> 表示，<span
class="math inline">\(P_{uv}\)</span> 代表像素坐标系，<span
class="math inline">\(u,v\)</span>
为像素坐标。这里目标为通过一些约束估计相机外参 <span
class="math inline">\(R,t\)</span>
。获取相机位姿后便可以进一步得到目标的三维点云。</p>
<span id="more"></span>
<h2 id="二-研究现状">二、 研究现状</h2>
<p>三维重建相关的算法中，许多通过图像信息恢复三维结构。图像信息主要由特征点表示，通过特征点可以构建图像间的联系，进一步可以得到目标的三维信息。特征点指的是图像中具有代表性的点，反映图像的局部特征。代表性的图像特征提取算法有：SIFT<a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>、SURF<a href="#fn6"
class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a>、ORB<a href="#fn7"
class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>
等。这一类算法提取的特征点具有很强的不变性，如尺度不变性、光照不变性、旋转不变性等，并高效地表达图像的局部特征。特征点包含关键点及对应的描述符，关键点指特征点在图像的具体坐标，描述符则体现关键点的局部特征，为不同图像中特征的匹配提供支持。特征匹配是确定图像间关联关系的重要步骤，但由于特征点一般数量众多，特征匹配带来的资源消耗也十分大，快速最邻近算法（FLANN）<a
href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a>为大规模匹配作了优化。</p>
<p>在单目视觉中通过图像间的像素坐标匹配建立运动关系，可将问题转换为利用两组
2D
匹配对估计相机位姿，这类问题可通过对极几何解决。对极几何本质上是三维空间目标点和两相机中心共面的约束，由本质矩阵和基础矩阵表达，这两个矩阵蕴含了相机的运动，可以使用八点法<a
href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>或者五点法<a href="#fn10"
class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a>求解 <span
class="math inline">\(R,t\)</span>。但本质矩阵（或基础矩阵）具有尺度等价性，从而它得到的
<span class="math inline">\(R,t\)</span>
也具有尺度等价性。旋转矩阵本身具有单位正交的约束，但分离得到的 <span
class="math inline">\(t\)</span>
具有尺度等价性，这是单目视觉的尺度不确定性的主要原因。得到两幅图像之间的运动之后可通过三角测量获得特征点的空间位置，估计目标点云，但仍然是尺度不确定的。</p>
<p>深度相机（RGB-D）通过红外结构光或“Time Of
Flight”原理获得目标深度信息，从而直接得到目标的 3D
信息，是尺度确定的。从而相机的运动可以从两组 3D
匹配点中恢复，可以使用迭代最近点（Iterative Closest Point，ICP）求解。但
RGB-D
相机存在测量范围窄，噪声大，易受日光干扰等问题，一般适用于室内。</p>
<p>双目相机也可得到深度信息。它由两个单目相机组成，这两个相机的距离称为基线，通过基线以及视差图计算每一个像素的空间位置。双目相机比
RGB-D
相机具有更好的适用性，但视差图的计算量是巨大的，所以双目相机的主要问题在于如何加速计算以节约资源。</p>
<p>当知道空间点的三维坐标以及它们在图片上的投影位置时估计相机位姿，这类问题称为
PnP（Perspective-n-Point）问题。其中空间点的三维坐标可以通过三角测量或者
RGB-D 相机得到。PnP
克服了对极约束中尺度的不确定，是一种主要的姿态估计方法。PnP
问题求解有许多方法，如利用三对点对求解的 P3P<a href="#fn11"
class="footnote-ref" id="fnref11"
role="doc-noteref"><sup>11</sup></a>，当目标为平面时还可以使用直接线性变换（DLT），还有
EPnP （Efficient PnP）<a href="#fn12" class="footnote-ref" id="fnref12"
role="doc-noteref"><sup>12</sup></a>等。这些方法对匹配点的精度要求十分高，但在实际情况中虽然可获得很大数量的匹配点对，但每个点对都存在一定误差，即存在噪声，而光束法平差（Bundle
Adjustment，BA）通过构建非线性最小二乘问题对位姿和点云优化，具有很好的鲁棒性，在匹配点数量众多的情况下效果很好，所以这里讨论
BA 的求解方法。</p>
<h2 id="三解决方案">三、解决方案</h2>
<p>光束法平差<a href="#fn13" class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a>，Bundle Adjustment
是使用非线性优化求估计位姿，以及优化空间点位置的方法。这一章节先介绍非线性优化的相关理论，然后通过相机成像模型构建重投影误差，从而建立优化函数。并使用李代数将问题转换为无约束优化问题。</p>
<h3 id="非线性最小二乘">3.1 非线性最小二乘</h3>
<p>经典的非线性最小二乘问题可以表达为： <span class="math display">\[
\min_{\pmb x} F(\pmb x) = \frac{1}{2} \vert\vert f(\pmb x)
\vert\vert_2^2 \tag{3.1.1}
\]</span> <span class="math inline">\(f(\pmb x)\)</span>
可以是向量函数，非线性最小二乘目标是找到 <span
class="math inline">\(\pmb x\)</span> 使得目标函数 <span
class="math inline">\(F(\pmb x)\)</span> 到达最小值。函数极值问题即求解
<span
class="math inline">\(\frac{dF(x)}{dx}=0\)</span>，满足这个条件的解可能是极大值、极小值或者是鞍点，这个方程的难解程度依赖于
<span class="math inline">\(f(\pmb x)\)</span>
本身的特点。此外，还可利用迭代求解：</p>
<ol type="1">
<li>确定初值 <span class="math inline">\(x_0\)</span></li>
<li>对于第 k 次迭代，搜寻一个增量 <span class="math inline">\(\Delta
x_k\)</span>，满足 <span class="math inline">\(\vert \vert f(x_k+\Delta
x_k) \vert \vert_2^2\)</span> 达到最小</li>
<li>迭代停机条件：当 <span class="math inline">\(\Delta x_k\)</span>
足够小时，停止</li>
<li>否则进行更新：<span class="math inline">\(x_{k+1} = x_k + \Delta
x_k\)</span>，并返回步骤 2</li>
</ol>
<p>在迭代过程中，不断更新 <span class="math inline">\(x\)</span>
使得函数值越来越小，即将求导问题转换为 <span
class="math inline">\(\Delta x_k\)</span>
的确定问题。但这里停机时候的解并不一定是全局最优的，这依赖于初值的确定，不好的初值可能使得迭代陷入局部最小值，所以对于此类非线性优化问题初值的选择十分重要。</p>
<p><span class="math inline">\(\Delta x_k\)</span>
的选择可以使用高斯牛顿法确定。将 <span class="math inline">\(f(\pmb
x)\)</span> 进行一阶泰勒展开，可得： <span class="math display">\[
f(x+\Delta x) \approx f(x) + J(x)\Delta x \tag{3.1.2}
\]</span> 其中 <span class="math inline">\(J(x)\)</span> 为 <span
class="math inline">\(f(x)\)</span> 关于 <span
class="math inline">\(x\)</span>
的雅可比矩阵，根据前面确定的迭代流程，给定 <span
class="math inline">\(x\)</span> 需要要找到 $x $ 使得 <span
class="math inline">\(\vert \vert f(x+\Delta x) \vert \vert_2^2\)</span>
达到最小，将式 3.1.2 带入 式 3.1.1 可得： <span class="math display">\[
\Delta \hat x = \arg \min_{\Delta x} \frac{1}{2} \vert \vert
f(x)+J(x)\Delta x \vert\vert_2^2 \tag{3.1.3}
\]</span> 这里 <span class="math inline">\(x\)</span> 是已知项，即 <span
class="math inline">\(x_k\)</span>
。所以这是一个线性最小二乘问题，易知该函数是一个凸函数，只需要对 <span
class="math inline">\(\Delta x\)</span> 求导，并令其等于 0 即可。可得：
<span class="math display">\[
J(x)^Tf(x) + J(x)^TJ(x) \Delta x = 0 \tag{3.1.4}
\]</span> 进一步可得： <span class="math display">\[
\begin{align}
H(x)\Delta x &amp;= g(x) \tag{3.1.5}\\
H(x) &amp;= J(x)^TJ(x) \\
g(x) &amp;= - J(x)^Tf(x)
\end{align}
\]</span> 高斯牛顿法的核心为求解式
3.1.5，线性方程组可以使用很多方式求解，对于不同的 <span
class="math inline">\(H(x)\)</span>
可以采取不同的求解方式，以提高求解速度。高斯牛顿法总结如下：</p>
<ol type="1">
<li>确定初值 <span class="math inline">\(x_0\)</span></li>
<li>对于第 k 次迭代，求解当前的雅可比矩阵 <span
class="math inline">\(J(x_k)\)</span> 并构建方程 <span
class="math inline">\(H(x_k)\Delta x_k = g(x_k)\)</span></li>
<li>迭代停机条件：当 <span class="math inline">\(\Delta x_k\)</span>
足够小时，停止</li>
<li>否则进行更新：<span class="math inline">\(x_{k+1} = x_k + \Delta
x_k\)</span>，并返回步骤 2</li>
</ol>
<p>高斯牛顿法存在步长可能过大的问题。一种改进为列文伯格-马夸尔特（Levenberg-Marquardt）<a
href="#fn14" class="footnote-ref" id="fnref14"
role="doc-noteref"><sup>14</sup></a>方法，它采用了动态步长，很大程度上改良了高斯牛顿法。</p>
<h3 id="李群李代数">3.2 李群李代数</h3>
<p>在 3.1
节介绍的为无约束非线性最小二乘算法，但在光束法平差中需要对旋转矩阵求导并更新，旋转矩阵具有内在的约束，需要保证其为单位正交阵。旋转矩阵没有加法定义，即两个旋转矩阵相加并不是旋转矩阵，定义在旋转矩阵上有意义的运算为乘法运算。</p>
<p>三维旋转矩阵构成特殊正交群 SO(3)，三维旋转加平移则构成特殊欧式群
SE(3)，定义如下： <span class="math display">\[
\begin{align}
\text{SO}(3) &amp;= \{R\in \mathbb R^{3\times 3}|RR^T=\pmb I,\det(R)=1
\} \tag{3.2.1}\\
\text{SE}(3) &amp;= \Big\{T=
\left[
\begin{matrix}
R &amp; t \\
\pmb 0^T &amp; 1
\end{matrix}
\right]
\in
\mathbb R^{4\times 4}|
R\in \text{SO(3)},
t\in \mathbb R^3
\Big\}
\tag{3.2.2}
\end{align}
\]</span> SO(3)、SE(3)
都属于李群，每一个李群都有对应的李代数，李代数描述了李群的局部性质，是其正切空间的表示。SO(3)、SE(3)
对应的李代数表示为 <span
class="math inline">\({\frak{so}}(3)\)</span>、<span
class="math inline">\({\frak{se}}(3)\)</span>，李群与李代数之间可以通过指数映射和对数映射相互转换。将旋转角度约束在
<span class="math inline">\(\pm \pi\)</span> 之内，此映射便为一个双射。
<span class="math display">\[
\begin{align}
R = {\rm exp}(\phi^{\wedge})&amp;,\phi^{\wedge} = \log(R) \tag{3.2.3}\\
T = \exp (\xi^{\wedge})&amp;,\xi^{\wedge} = \log (T) \tag{3.2.4}\\
\end{align}
\]</span> 其中： <span class="math display">\[
\begin{align}
\phi &amp;= [\phi_1 \quad \phi_2 \quad \phi_3]\in {\frak so}(3) \\
\phi^{\wedge} &amp;=
\left[
\begin{matrix}
0 &amp; -\phi _3 &amp; \phi_2 \\
\phi_3 &amp; 0 &amp; -\phi_1 \\
-\phi_2 &amp; \phi_1 &amp; 0
\end{matrix}
\right] \tag{3.2.5}\\
\xi &amp;= [\rho^T\quad \phi^T] \in {\frak se}(3) \tag{3.2.6}\\
\xi^{\wedge} &amp;=
\left[
\begin{matrix}
\phi^{\wedge} &amp; \rho \\
\pmb 0^T&amp; 0
\end{matrix}
\right] \tag{3.2.7}\\
\rho &amp;\in \mathbb R^3
\end{align}
\]</span> <span class="math inline">\({\frak so}(3)\)</span>
本质上是旋转向量组成的空间，旋转向量是无约束的。<span
class="math inline">\({\frak se}(3)\)</span> 则可以理解为平移向量和
<span class="math inline">\({\frak so}(3)\)</span>
的结合。将李群转换到李代数就可以构建无约束优化问题。在优化问题求导是重要的步骤，这里讨论对空间施加一个变换，考虑对变换的导数。李群没有加法定义，所以不能使用导数定义求导，李群的求导需要使用扰动模型，对李群左乘或者右乘一个微小扰动
<span
class="math inline">\(\exp(\delta^{\wedge})\)</span>，然后计算变化量
<span class="math inline">\(\epsilon\)</span> 对扰动 <span
class="math inline">\(\delta\)</span> 的导数，如下： <span
class="math display">\[
\begin{align}
TP + \epsilon &amp;= \exp (\delta^{\wedge})TP \tag{3.2.8} \\
\delta &amp;\in {\frak se}(3)
\end{align}
\]</span></p>
<p>由式 3.2.8、3.2.7 ，并根据左扰动模型可以得到 <span
class="math inline">\(TP\)</span> 对微小变换的导数为： <span
class="math display">\[
\begin{align}
\frac{\partial TP}{\partial \delta} &amp;= \frac{\partial
\epsilon}{\partial \delta} \\
&amp;= \frac{\partial (\exp (\delta^{\wedge})TP - TP)}{\partial \delta}
\\
&amp;= \frac{\partial ((\pmb I + \delta^{\wedge})TP - TP)}{\partial
\delta}\\
&amp;= \frac{\partial (\delta^{\wedge}TP)}{\partial \delta} \\
&amp;= \frac{\partial
\left[
\begin{matrix}
\phi^{\wedge} &amp; \rho \\
\pmb 0^T&amp; 0
\end{matrix}
\right]
\left[
\begin{matrix}
Rp+t \\
1
\end{matrix}
\right]
}{\partial \delta} \\
&amp;= \frac{\partial
\left[
\begin{matrix}
\phi^{\wedge}(Rp+t)+\rho \\
\pmb 0^T
\end{matrix}
\right]
}{\partial [\rho \quad \phi^{\wedge}]}\\
&amp;=
\left[
\begin{matrix}
\pmb I &amp; -(TP)^{\wedge} \\
\pmb 0^T&amp; 0
\end{matrix}
\right]
\tag{3.2.9}
\end{align}
\]</span> 3.1
节非线性优化模型中，对变量求导之后的更新步骤使用的是加法更新。在扰动模型中，由式
3.2.8 可知应该使用 <span
class="math inline">\(\exp(\delta^{\wedge})T\)</span> 更新矩阵 <span
class="math inline">\(T\)</span>，即： <span class="math display">\[
T_{k+1} = \exp(\delta^{\wedge})T_k \tag{3.2.10}
\]</span></p>
<h3 id="光束法平差">3.3 光束法平差</h3>
<p>根据相机成像模型有： <span class="math display">\[
\begin{align}
s_i
\pmb u_i &amp;=
KTP_i
\tag{3.3.1}\\
\pmb u_i &amp;= \left[
\begin{matrix}
u_i &amp; v_i &amp; 1
\end{matrix}
\right]^T \\
P_i &amp;=
\left[
\begin{matrix}
X_i &amp; Y_i &amp; Z_i &amp; 1
\end{matrix}
\right]^T
\end{align}
\]</span> 式 3.3.1 中 <span class="math inline">\(\pmb u_i\)</span> 第 i
个匹配的像素坐标，<span class="math inline">\(P_i\)</span>
为对应的空间点。由于相机位姿 <span class="math inline">\(T\)</span>
未知，且空间点 <span class="math inline">\(P_i\)</span>
存在一定的噪声，所以对所有的匹配点，式 3.3.1
不一定恒等，即始终存在一个误差，这个误差称为重投影误差，光束法平差目标为最小化所有匹配的重投影误差和，从而获得位姿和估计点最优估计。光束法平差的非线性最小二乘表达如下：
<span class="math display">\[
\hat T,\hat P_i = \arg \min_{T,P_i} \frac{1}{2}\sum_{i=1}^n \vert\vert
\pmb u_i - \frac{1}{s_i} KTP_i \vert \vert_2^2 \tag{3.3.2}
\]</span></p>
<p>定义单个点误差为： <span class="math display">\[
e = \pmb u - \frac{1}{s}KTP \tag{3.3.3}
\]</span> 根据 3.1
节的非线性优化模型，需要得到我们需要得到误差对优化变量 K、P
的雅可比矩阵，以更新迭代待优化变量。</p>
<p>定义变量 <span class="math inline">\(P&#39;\)</span> 满足： <span
class="math display">\[
\begin{align}
P&#39; = (TP)_{1:3} &amp;=
\left[
\begin{matrix}
X&#39; &amp; Y&#39; &amp; Z&#39;
\end{matrix}\
\right]^T \tag{3.3.4}\\
e &amp;= \pmb u - \pmb u&#39; \tag{3.3.5} \\
\pmb u&#39; &amp;= \frac{1}{Z&#39;}KP&#39; \tag{3.3.6}
\end{align}
\]</span> 根据链式求导法则，可得 <span class="math inline">\(e\)</span>
关于 <span class="math inline">\(P\)</span> 的雅可比矩阵为： <span
class="math display">\[
\begin{align}
J_P(P) = \frac{\partial e}{\partial P&#39;} \frac{\partial
P&#39;}{\partial P} \tag{3.3.7}
\end{align}
\]</span> 相机内参矩阵定义为： <span class="math display">\[
K =
\left[
\begin{matrix}
f_x &amp; 0 &amp; c_x \\
0 &amp; f_y &amp; c_y \\
0 &amp; 0 &amp; 1
\end{matrix}
\right]
\tag{3.3.8}
\]</span> 式 3.3.8 带入式 3.3.6 可得： <span class="math display">\[
\begin{align}
\pmb u&#39; &amp;= [u&#39;\quad v&#39;]^T\\
u&#39; = f_x \frac{X&#39;}{Z&#39;} + c_x &amp;,\quad v&#39; =
f_y\frac{Y&#39;}{Z&#39;} + c_y
\tag{3.3.9}\\
\end{align}
\]</span> 由式 3.3.7、3.3.8、3.3.9 可得： <span class="math display">\[
\frac{\partial e}{\partial P&#39;} = -
\left[
\begin{matrix}
\frac{\partial u&#39;}{\partial X&#39;} &amp;
\frac{\partial u&#39;}{\partial Y&#39;} &amp;
\frac{\partial u&#39;}{\partial Z&#39;} \\
\frac{\partial v&#39;}{\partial X&#39;} &amp;
\frac{\partial v&#39;}{\partial Y&#39;} &amp;
\frac{\partial v&#39;}{\partial Z&#39;} \\
\end{matrix}
\right]
=
-
\left[
\begin{matrix}
\frac{f_x}{Z&#39;} &amp; 0 &amp; -\frac{f_xX&#39;}{Z&#39;^2} \\
0 &amp; \frac{f_y}{Z&#39;} &amp; \frac{f_yY&#39;}{Z&#39;^2}
\end{matrix}
\right]
\tag{3.3.10}
\]</span> 由式 3.3.4 可得 <span class="math inline">\(P&#39;\)</span>
对于 <span class="math inline">\(P\)</span> 的导数为： <span
class="math display">\[
\begin{align}
P&#39; &amp;= RP + t \\
\frac{\partial P&#39;}{\partial P} &amp;= R \tag{3.3.11}
\end{align}
\]</span> 式 3.3.10、3.3.11 带入式 3.3.7
可得误差关于空间点的雅可比矩阵为： <span class="math display">\[
J_P(P) = -
\left[
\begin{matrix}
\frac{f_x}{Z&#39;} &amp; 0 &amp; -\frac{f_xX&#39;}{Z&#39;^2} \\
0 &amp; \frac{f_y}{Z&#39;} &amp; \frac{f_yY&#39;}{Z&#39;^2}
\end{matrix}
\right] R
\tag{3.3.12}
\]</span> 由 3.2 节可以得到误差对位姿变化的导数，这里相机位姿使用李代数
<span class="math inline">\(\xi\)</span> 表示，位姿上的扰动为 <span
class="math inline">\(\delta \xi\)</span>。从式 3.2.9、3.3.4、3.3.10
可得： <span class="math display">\[
\begin{align}
J_T(\delta\xi) &amp;= \frac{\partial e}{\partial P&#39;}\frac{\partial
P&#39;}{\partial \delta\xi}\\
&amp;=
-
\left[
\begin{matrix}
\frac{f_x}{Z&#39;} &amp; 0 &amp; -\frac{f_xX&#39;}{Z&#39;^2} \\
0 &amp; \frac{f_y}{Z&#39;} &amp; \frac{f_yY&#39;}{Z&#39;^2}
\end{matrix}
\right]
\left[
\begin{matrix}
\pmb I &amp; -P&#39;^{\wedge}
\end{matrix}
\right] \tag{3.3.13}
\end{align}
\]</span> 由式 3.3.12，3.3.13
可以得到误差对位姿以及空间点的导数，便可以使用高斯牛顿法或者 LM
法迭代更新，位姿更新采用式 3.2.10。</p>
<h3 id="初值构建">3.4 初值构建</h3>
<p>如 3.1
节所述，非线性最小二乘优化的结果不一定是全局最优，所以需要构建良好的初值。对于光束法平差，可以使用
EPNP
等算法快速构建相机位姿的初值，然后使用迭代优化。目标三维点云可由三角测量得到，并作为点云初始值。</p>
<h2 id="四实验结果">四、实验结果</h2>
<h3 id="理论验证">4.1 理论验证</h3>
<p>此部分代码以提交至本人
Github：https://github.com/Weijun-Lin/SLAM-Try/tree/master/BA-ceres</p>
<p>利用生成的数据进行理论验证，使用一个相机的 3D-2D
匹配优化位姿以及点云。步骤如下：</p>
<ol type="1">
<li>构建实验数据，确定相机内参矩阵以及相机真实位姿，并生成点云，根据相机成像模型建立
3D-2D 匹配，相机位姿使用李代数 <span class="math inline">\({\frak
se}(3)\)</span> 表示，前三维为平移，后三维为旋转即 <span
class="math inline">\({\frak so}(3)\)</span></li>
<li>对真实位姿以及 3D 点云添加噪声干扰，得到待优化数据</li>
<li>使用光束法平差（BA）优化</li>
<li>利用均方误差（MSE）作为评价标准</li>
</ol>
<p>原始位姿如下：</p>
<ul>
<li>相机内参：<span class="math inline">\(3\times 3\)</span>
的单位阵</li>
<li>相机真实位姿：<span class="math inline">\([0 \quad 0 \quad -20 \quad
0\quad 0 \quad 0]\)</span></li>
<li>添加噪声后位姿：<span class="math inline">\([3.6e^{-2} \quad
-8.4e^{-2} \quad -19.99 \quad 2.8e^{-3}\quad -1.89e^{-3} \quad
-8.87e^{-4}]\)</span></li>
</ul>
<p>原始点云图：</p>
<figure>
<img src="/assets/ArticleImg/2022/BA-report.assets/src.png"
alt="真实点云图" />
<figcaption aria-hidden="true">真实点云图</figcaption>
</figure>
<p>光束法平差优化后位姿为： <span class="math display">\[
[3.55e^{-2} \quad -7.31e^{-2} \quad -20.036 \quad 1.92e^{-3} \quad
-1.56e^{-3} \quad 1.3e^{-4}]
\]</span> 噪声干扰后点云以及光束法平差优化后点云如下图：</p>
<figure>
<img src="/assets/ArticleImg/2022/BA-report.assets/res.png"
alt="结果图" />
<figcaption aria-hidden="true">结果图</figcaption>
</figure>
<p>均方误差统计如下表：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>位姿误差</th>
<th>点云误差</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>优化前</td>
<td>0.091614</td>
<td>0.78033</td>
</tr>
<tr class="even">
<td>优化后</td>
<td>0.088821</td>
<td>0.59205</td>
</tr>
</tbody>
</table>
<p>可以看出，位姿以及点云在光束法平差后得到了优化。</p>
<h3 id="bal-数据集测试">4.2 BAL 数据集测试</h3>
<p>BAL 数据集地址：https://grail.cs.washington.edu/projects/bal/，BAL
数据集包含了多幅图像，包含了 3D
空间点云，以及在每一副图像上的匹配点。这里使用的是
problem-16-22106-pre.txt.bz2 数据。此部分代码参考自 Github<a
href="#fn15" class="footnote-ref" id="fnref15"
role="doc-noteref"><sup>15</sup></a>，地址为：https://github.com/gaoxiang12/slambook2/tree/master/ch9。</p>
<p>优化之前点云图为：</p>
<p><img
src="/assets/ArticleImg/2022/BA-report.assets/initial.png" /></p>
<p>优化之后点云为：</p>
<p><img src="/assets/ArticleImg/2022/BA-report.assets/final.png" /></p>
<p>可以看出优化之后点云将原常见轮廓更好的体现了出来</p>
<h2 id="五结论">五、结论</h2>
<p>综上，光束法平差对大规模点云优化以及相机位姿估计有很大的作用，但由于优化参数过于庞大，带来的空间以及时间开销都是巨大的。所以需要对问题规模做合理的约束。</p>
<p>光束法平差本质是一个非线性优化，它需要构建良好的初值，初值的确定对其优化效果特别重要。在
4.1
节，优化效果不是特别好，原因在于相机位姿只有一个，当存在多个相机位姿提供多个匹配关系时，优化效果会更加，如
4.2 节所示。</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>chonberger J L, Frahm J M. Structure-from-motion
revisited[C]//Proceedings of the IEEE conference on computer vision and
pattern recognition. 2016: 4104-4113.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Thrun S. Simultaneous localization and
mapping[M]//Robotics and cognitive approaches to spatial mapping.
Springer, Berlin, Heidelberg, 2007: 13-41.<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>高翔
张涛等.视觉SLAM十四讲：从理论到实践（第二版）[M].北京:电子工业出版社,2017<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Zhang Z. Flexible camera calibration by viewing a plane
from unknown orientations[C]//Proceedings of the seventh ieee
international conference on computer vision. Ieee, 1999, 1: 666-673.<a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Lowe D G. Distinctive image features from
scale-invariant keypoints[J]. International journal of computer vision,
2004, 60(2): 91-110.<a href="#fnref5" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Bay H, Tuytelaars T, Van Gool L. Surf: Speeded up robust
features[C]//European conference on computer vision. Springer, Berlin,
Heidelberg, 2006: 404-417.<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Rublee E, Rabaud V, Konolige K, et al. ORB: An efficient
alternative to SIFT or SURF[C]//2011 International conference on
computer vision. Ieee, 2011: 2564-2571.<a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Muja M, Lowe D G. Fast approximate nearest neighbors
with automatic algorithm configuration[J]. VISAPP (1), 2009, 2(331-340):
2.<a href="#fnref8" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Hartley R I. In defense of the eight-point algorithm[J].
IEEE Transactions on pattern analysis and machine intelligence, 1997,
19(6): 580-593.<a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>Li H, Hartley R. Five-point motion estimation made
easy[C]//18th International Conference on Pattern Recognition (ICPR'06).
IEEE, 2006, 1: 630-633.<a href="#fnref10" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>Gao X S, Hou X R, Tang J, et al. Complete solution
classification for the perspective-three-point problem[J]. IEEE
transactions on pattern analysis and machine intelligence, 2003, 25(8):
930-943.<a href="#fnref11" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>Lepetit V, Moreno-Noguer F, Fua P. Epnp: An accurate o
(n) solution to the pnp problem[J]. International journal of computer
vision, 2009, 81(2): 155.<a href="#fnref12" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>高翔
张涛等.视觉SLAM十四讲：从理论到实践（第二版）[M].北京:电子工业出版社,2017<a
href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>Moré J J. The Levenberg-Marquardt algorithm:
implementation and theory[M]//Numerical analysis. Springer, Berlin,
Heidelberg, 1978: 105-116.<a href="#fnref14" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>高翔
张涛等.视觉SLAM十四讲：从理论到实践（第二版）[M].北京:电子工业出版社,2017<a
href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>CV&amp;CG&amp;DIP</category>
        <category>CV</category>
        <category>三维视觉与SLAM</category>
      </categories>
      <tags>
        <tag>SFM</tag>
        <tag>BA</tag>
        <tag>李群李代数</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux/Unix 入门编程手册</title>
    <url>/2023/09/10/2023-09-10-Linux-programming/</url>
    <content><![CDATA[<p>Linux/Unix 入门编程手册，参考自 《Linux/Unix 系统编程手册》Michael
Kerrisk 著。</p>
<p>主要对 Linux/Unix 下文件、信号、进程、线程、IPC 等作简要描述。</p>
<p>篇幅较多，单独收录到：<a
href="https://linuxprogramming.weijun-lin.top/">Readme - Linux/Unix
入门编程 (weijun-lin.top)</a></p>
<p>上次更新: 2023-10-01</p>
<p>不断补充中……</p>
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>英语技术论文写作注意事项</title>
    <url>/2023/10/24/2023-10-24-%E8%8B%B1%E8%AF%AD%E6%8A%80%E6%9C%AF%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<p>一些我们在英语论文写作过程中容易犯的错误以及注意点。</p>
<p>以下内容摘自：<em>The Most Common Habits from more than 200 English
Papers written by Graduate Chinese Engineering Students</em></p>
<span id="more"></span>
<h2 id="section-1">Section 1</h2>
<ol type="1">
<li><p>注意使用 "a, an, the"</p></li>
<li><p>避免超长句子</p></li>
<li><p>先阐述句子的主要观点，然后再描述目的、位置、原因等其它成分</p></li>
<li><p>不要以表示时间作为句子开头，如 "When ..., ..."</p></li>
<li><p>避免把句子最终要的部分直接放在开头来强调</p></li>
<li><p>注意使用 "which/that"</p></li>
<li><p>注意使用 "Respectively" 和
"respective"，当描述两个以上事物且当描述顺序很重要时使用，并注意</p>
<ol type="1">
<li>不要放在句子中间，respectively 一般放在句子末尾并用逗号隔开</li>
<li>当这个顺序用其它形式表达出来了就不要用这个词</li>
<li>避免不必要的使用，比如多个物体但没有明确指出时</li>
</ol></li>
<li><p>避免多次使用 "In this paper" 或者 "In this study"
，这两个一般在开头、结尾或者文章中描述了他人工作后强调自己工作部分时使用，另外
"in this paper" 强调论文表达形式，"in this study"
表示论文所做的工作</p></li>
<li><p>不要在句子开头使用阿拉伯数字</p></li>
<li><p>注意格式，论文分段及其格式</p></li>
<li><p>注意使用 "such as" 和 "etc"，这两个不能同时使用，冗余了，不要用
such as 表示列举完的举例</p></li>
<li><p>"such as"：列举未完成的例子（没有列完）</p></li>
<li><p>"etc"：表示列举没有结束 ## Section 2</p></li>
<li><p>注意单词复数形式，有些不需要加 s，如</p>
<ol type="1">
<li>literature (when referring to research)</li>
<li>equipment,</li>
<li>staff (referring to a group of people)</li>
<li>faculty</li>
</ol></li>
<li><p>避免出现冗余词组表达</p></li>
</ol>
<p><img
src="/assets/ArticleImg/2023/英语技术论文写作注意事项.assets/image.png" /></p>
<ol start="3" type="1">
<li>注意在某些形容词后使用复数形式，如 different, various, two,
etc.</li>
<li>不要用数字或缩写作为句子开头</li>
<li>不要使用 "by this way"，用 "by doing this" 或 "using this method"
替代</li>
<li>不要用 "how to" 作为句子开头</li>
<li>不要用 "the results are showed in Fig. 2"，使用 "are shown in"</li>
<li>变量用斜体表示，或期刊要求的格式</li>
<li>不要在技术论文中使用 "Obviously"</li>
<li>不要在国际论文中加 "at home" 等词</li>
<li>尽量避免使用 "that is to say" 或者 "namely"
短语，尽可能用句子重新表达</li>
<li>不要使用 "too" 作为句子结尾，尤其在技术论文中</li>
</ol>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>论文研读</tag>
        <tag>文章分享</tag>
      </tags>
  </entry>
</search>
